<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Assembler Lab</title>
    <link href="/2025/03/18/Assembler/"/>
    <url>/2025/03/18/Assembler/</url>
    
    <content type="html"><![CDATA[<h1 id="ics-lab6-y86-64-assembler"><a class="markdownIt-Anchor" href="#ics-lab6-y86-64-assembler"></a> ICS Lab6: Y86-64 Assembler</h1><blockquote><p>我Coding + Debugging的总耗时约13小时（Wakatime统计）</p><p>代码量：</p><p><img src="../imgs/image-20250318041709740-1742299662991-1.png" alt="" /></p><p>本篇文章将从整体上拆解一下代码框架和实现思路，以及Debug的时候容易遇到的错误，不涉及具体的实现细节（<strong>无代码剧透</strong>）。</p></blockquote><p>在Lab6，我们继续深入认识Y86-64指令集架构，实现一个Assembler将Y86-64汇编代码转化为Y86-64二进制代码。</p><h2 id="skeleton-code"><a class="markdownIt-Anchor" href="#skeleton-code"></a> Skeleton Code</h2><p>在开始Coding之前，一定要先阅读并梳理代码框架！这里我简单讲解一下：</p><p>我们的Assembler需要负责将y86-64汇编源代码转化为机器能够直接执行的二进制代码。也就是说，Assembler的input是一个y64汇编文件（<code>.ys</code>），output是一个y64二进制文件。</p><p>那么如何做到呢？观察<code>main</code>函数，代码框架处理的思路如下：</p><ol><li>按行扫描并解析input <code>.ys</code> file，存储每一行汇编代码对应的字节码</li><li>重定位第一遍扫描未解析的symbol</li><li>将解析完成的结果（字节流）写入output file中</li></ol><p>具体来说：</p><p><code>assemble</code>函数负责解析input file，一行行读取y64汇编代码。每读取一行，交给<code>parse_line</code>对这一行汇编代码进行分词与解析。然后将该行的解析结果（字节码）存入一个<code>line_t</code>结构，加入到line table中。</p><p><code>assemble</code>会按行将input file从头到尾扫描一遍，将每一行汇编代码转化成字节码存在<code>line_t</code>中，但是可能会留有未解析的<code>symbol</code>。代码框架的策略是当扫描到一个label时，将这个label的内存地址和名字存储在<code>symbol_t</code>结构中，加入到全局的symbol table。当扫描到一个无法解析的<code>symbol</code>时，将该行未完整解析的字节码和<code>symbol</code>的名字存储在<code>reloc_t</code>中，加入到relocation table。</p><p>在<code>assemble</code>扫描完一遍input file过后，<code>relocate</code>会被调用。<code>relocate</code>负责遍历relocation table，对每一个未解析<code>symbol</code>的行，在symbol table中找到这个<code>symbol</code>，用这个<code>symbol</code>的内存地址对应的字节码替换该行字节码中的符号占位。</p><p><code>assemble</code>和<code>relocate</code>结束，就说明整个input <code>.ys</code> file全部解析完成，所有行的字节码都存在了line table中。这时候<code>binfile</code>会被调用。<code>binfile</code>会遍历line table，将每行的字节码写入到ouput file中。</p><h2 id="implementation"><a class="markdownIt-Anchor" href="#implementation"></a> Implementation</h2><h3 id="扫描分词和解析"><a class="markdownIt-Anchor" href="#扫描分词和解析"></a> 扫描，分词和解析</h3><p>我们核心要实现的是<code>parse_line</code>，也就是对一行汇编代码进行分词和解析的工作。</p><p>一行汇编代码可能包含几个部分：注释、标签、指令、汇编器伪指令。你的<code>parse_line</code>需要能识别出这几部分。框架代码提供了很多宏和<code>parse_xxx</code>函数来帮助你解析。</p><p>我在这里梳理一些主要的实现逻辑：</p><ol><li>解析指令</li></ol><p>注释和标签都不需要解析为字节码，因此我们关注的重点在解析指令上：</p><p>根据指令的类型（<code>icode</code>），需要不同的parse逻辑。因此需要一个switch语句分类parse不同类型的指令。可以思考的是哪些指令可以合并parse，查看下图的Y86-64指令集：</p><img src="../imgs/202502171432021-1740397650876-106-1742299662992-2.png" alt="Y86-64指令集" style="zoom: 60%;" /><p>相同字节码格式的指令可以在switch里面合并处理。因为我们关心的只是字节码，与不同指令的执行行为和<code>op code</code>都没有关系。比如<code>rrmovq</code>, <code>cmovXX</code>, <code>OPq</code>可以合并，因为都是只需要解析<code>rA</code>和<code>rB</code>两个寄存器。</p><ol start="2"><li>解析汇编器伪指令</li></ol><p>汇编器伪指令（assembler directives）其实不是真正的指令，但是可以统一当作指令一样处理。因为我们关心的只是翻译成的字节码而已。其中<code>.pos</code>和<code>.align</code>这两条伪指令很特殊，他们并不会翻译成字节码，但是可能会改变当前的内存地址。**想一想这会对我们的字节流的输出产生什么影响？**如果你现在想不到，可以到Debug的时候再处理。</p><ol start="3"><li>处理symbol占位</li></ol><p>有三处位置可能会有symbol占位，在最后<code>relocate</code>部分需要用<code>symbol</code>对应的地址（字节码）替换：</p><ol><li><code>irmovq</code>中的立即数可能是<code>symbol</code></li><li><code>jXX</code>和<code>call</code>后面的<code>Dest</code>可能是<code>symbol</code></li><li>汇编器伪指令<code>.byte</code>, <code>.word</code>, <code>.long</code>, <code>.quad</code>后面的data可能是<code>symbol</code></li></ol><p>因此在遇到label的时候，需要将其存入<code>symbol_t</code>加入到symbol table。在遇到symbol的时候，需要先将该行的其余部分解析完成，将未完整解析的字节码和symbol的名字一起存入<code>reloc_t</code>，加入到relocation table。</p><ol start="4"><li>错误处理</li></ol><p>当遇到解析错误时，需要<code>err_print</code>打印正确的错误信息。</p><h3 id="assemble和binfile"><a class="markdownIt-Anchor" href="#assemble和binfile"></a> <code>assemble</code>和<code>binfile</code></h3><p>在扫描完所有行汇编代码后，assemble还需要做一件事来<strong>确保你解析的汇编代码是正确的</strong>。这个在你实现的时候想不到很正常，可以留到Debug的时候再处理。</p><p><code>binfile</code>需要遍历line table，将每行的字节码写入到ouput file中。这里的写法也有很容易忽略的点，前面其实我已经埋下了伏笔。</p><h2 id="debugging"><a class="markdownIt-Anchor" href="#debugging"></a> Debugging</h2><p>在Coding的过程中，你应该会发现我们的Assembler实现细节非常琐碎，而且我前面也提到容易出错/忽略的点很多（我在下面会罗列出来），因此花费Debug的时间会比较多。</p><ol><li><p>在<code>parse_line</code>中不能移动<code>line-&gt;y64asm</code>指针，这个指针永远指向这一行汇编代码的开头。因为后面<code>print_line</code>需要用到这个指针来打印这一行的汇编代码；并且<code>line-&gt;y64asm</code>是在<code>assemble</code>中用<code>malloc</code>初始化的，因此在<code>finit</code>中需要传递同一个指针给<code>free</code>。</p></li><li><p>注意symbol table和relocation table中的第一个entry是一个dummy head，你第一个向里面添加的<code>symbol_t</code>/<code>reloc_t</code>应该接在这个dummy head后面。</p></li><li><p>只有标签(label)的行需要解析为instruction(<code>TYPE_INS</code>)类型，这样<code>print_line</code>才会打印标签行的内存地址。</p></li><li><p><code>parse_digit</code>需要将<code>*ptr</code>指向的字符串数据解析为<code>long</code>类型的数据。注释里提示的<code>strtoll</code>是将数据解析成(signed) long long类型，因此如果字符串数据大于<code>0x7FFFFFFF</code>就会overflow，会返回signed long long的最大值<code>0x7FFFFFFF</code>。但是我们需要能够解析<code>0 - 0xFFFFFFFF</code>的任意字符串数据，那怎么办呢？可以用<code>strtoull</code>将字符串数据解析为<code>unsigned long long</code>，再cast成<code>long</code>。<code>cast</code>的过程不会改变bit pattern，只不过大于<code>0x7FFFFFFF</code>的数<code>long</code>类型会解析成负数。但只要不改变bit pattern，就不影响最终字节码的翻译。</p></li><li><p><code>.pos</code>和<code>.align</code> directive可能会改变<code>vmaddr</code>，会有什么影响呢？这里就是伏笔回收。这两个汇编器指令的前一条指令和后一条指令间可能会空出来一段内存地址，需要向output binary file中添加padding zeros来填补前后两条指令间的空白。我的做法是不将<code>.pos</code>和<code>.align</code>翻译成字节码，但是在<code>binfile</code>中每次写入output file前检查当前output file中的位置是否等于当前要写入的指令的内存地址。如果不是，说明要向output file中添加padding zeros。</p></li><li><p><code>assemble</code>里面<code>parse</code>完所有的行后还需要做什么？伏笔回收：需要检查<code>JXX</code>/<code>call</code>指令的destination address是否有效。如果这个destination address不等于整个文件中任一一条指令/标签的地址，说明这个destination address是无效的，需要报错。</p></li></ol><p>Debug的时候用好<code>y64asm</code>和<code>y64asm-base</code>程序的<code>-v</code>功能，对照汇编源代码和（你的assembler和标准y64 assembler的）二进制输出，以及比较你的assembler和标准y64 assembler输出的<code>.bin</code>文件的区别。</p><h2 id="test"><a class="markdownIt-Anchor" href="#test"></a> Test</h2><p>To test and evaluate your Assembler:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">yat -h <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Show <span class="hljs-built_in">help</span> information of yat</span><br><br>yat -s &lt;instruction&gt; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Test correctness of single instruction <span class="hljs-keyword">in</span> y64-ins directory</span><br><br>yat -s &lt;error&gt; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Test correctness of processing with specific error <span class="hljs-keyword">in</span> y64-err directory</span><br><br>yat -S <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Test correctness of processing all instructions and errors.</span><br><br>yat -a &lt;program&gt; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Test correctness of processing single .ys file <span class="hljs-keyword">in</span> y64-app directory</span><br><br>yat -A <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Test correctness of processing all .ys files provided <span class="hljs-keyword">in</span> y64-app directory</span><br><br>yat -F <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Test correctness of processing all instructions, error types and programs.</span><br></code></pre></td></tr></table></figure><p>All tests pass!🤗</p><p><img src="../imgs/image-20250318040412107-1742299662992-3.png" alt="" /></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>总体来说，Assembler的实现思路代码框架还是提示的很完整的，也很简洁。但是具体实现起来琐碎的细节很多，需要有耐心慢慢地水磨功夫和Debug。</p><p>经过Lab6和Lab7，现在给我们一段汇编代码，我们的Assembler可以将其转化成二进制代码。我们的Simulator可以根据转化来的二进制代码，模拟硬件的行为执行这段汇编代码。</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
      <category>Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>Assembler</tag>
      
      <tag>Y86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Github Copilot在VSCode中无法使用问题</title>
    <link href="/2025/03/12/copilot-issue/"/>
    <url>/2025/03/12/copilot-issue/</url>
    
    <content type="html"><![CDATA[<h2 id="问题1github-copilot-chat消息发不出去"><a class="markdownIt-Anchor" href="#问题1github-copilot-chat消息发不出去"></a> 问题1：Github Copilot Chat消息发不出去</h2><p>在VSCode中使用Copilot Chat消息发送不出去？很可能是与你别的自动补齐插件冲突了。我的情况是跟fitten code冲突了，卸载fitten code就可以解决。</p><h2 id="问题2远程环境中github-copilot用不了"><a class="markdownIt-Anchor" href="#问题2远程环境中github-copilot用不了"></a> 问题2：远程环境中Github Copilot用不了</h2><p>如果你在远程开发环境（如SSH、Container、WSL）中遇到下图的问题：</p><p><img src="../imgs/image-20250312222516317.png" alt="" /></p><p>可以配置Github Copilot扩展始终在本地客户端运行：</p><ol><li>在VSCode Settings中搜索&quot;Extension Kind&quot;，点击&quot;Edit in settings.json&quot;</li></ol><p><img src="../imgs/image-20250312222732494.png" alt="" /></p><ol start="2"><li><p>添加以下代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;remote.extensionKind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;GitHub.copilot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ui&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;GitHub.copilot-chat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ui&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Copilot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP Chapter4</title>
    <link href="/2025/03/03/CSAPP-Chapter4/"/>
    <url>/2025/03/03/CSAPP-Chapter4/</url>
    
    <content type="html"><![CDATA[<p>这篇笔记将记录我在ICS课上学习CSAPP第四章Processor Architecture(处理器体系结构)的过程。已完结。</p><h1 id="processor-architecture"><a class="markdownIt-Anchor" href="#processor-architecture"></a> Processor Architecture</h1><blockquote><p>参考资料：</p><p><a href="https://fengmuzi2003.gitbook.io/csapp3e/di-4-zhang-chu-li-qi-ti-xi-jie-gou">CSAPP 第四章 gitbook</a></p></blockquote><h2 id="y86-instruction-set"><a class="markdownIt-Anchor" href="#y86-instruction-set"></a> y86 instruction set</h2><p>这部分我们学习y86指令集和ISA，以便实现simulator和assembler lab。其中simulator模拟执行y86代码的硬件行为，assembler负责将y86汇编代码转化为硬件可以直接执行的二进制代码。学习y86指令集和ISA是为后续学习“<strong>程序是如何在CPU上运行的</strong>”打下基础。</p><h3 id="y86-64处理器状态processor-state"><a class="markdownIt-Anchor" href="#y86-64处理器状态processor-state"></a> y86-64处理器状态(Processor State)</h3><ol><li>Program Registers</li></ol><p>y86架构处理器包含15个寄存器，每个寄存器是64位的。</p><p><img src="../imgs/202502171427340-1742058095648-1.png" alt="Program Registers" /></p><ol start="2"><li>Program Counter</li><li>Condition Codes</li></ol><p>Single-bit flags: <code>OF</code>: Overflow  <code>ZF</code>: Zero  <code>SF</code>: Negative</p><ol start="4"><li>Status Code</li></ol><p>Program is running normally or some special event has occurred.</p><ol start="5"><li>Memory</li></ol><p>We can use a big array in the simulator to simulate memory.</p><h3 id="12类y86指令"><a class="markdownIt-Anchor" href="#12类y86指令"></a> 12类y86指令</h3><p>每条指令都访问或改变program state的某些部分。</p><p><img src="../imgs/202502171432021-1742058095649-3.png" alt="Y86-64指令集" /></p><p>每条指令都可以用一个byte来表示：其中前4 bits是instruction code, 后4 bits是function code</p><p><img src="../imgs/202502171439511-1742058095649-4.png" alt="指令编码" /></p><p>每个寄存器用一个4-bit ID表示：其中F代表没有使用寄存器</p><p><img src="../imgs/202502171436912-1742058095649-2.png" alt="寄存器编码" /></p><p>y86 program stack: 栈顶是地址最小的位置，栈向低地址扩张。</p><p><img src="../imgs/202502171442126-1742058095649-6.png" alt="Stack" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushq rA<br>/* <br> * Decrement %rsp by 8<br> * Store word from rA to memory at %rsp<br> * Like x86-64 (pushq %rsp -&gt; save old %rsp)<br> */<br><br>popq rA<br>/* <br> * Read word from memory at %rsp<br> * Save in rA<br> * Increment %rsp by 8<br> * Like x86-64 (popq %rsp -&gt; movq (%rsp) %rsp)<br> */<br></code></pre></td></tr></table></figure><h3 id="y86-64-assembly-code"><a class="markdownIt-Anchor" href="#y86-64-assembly-code"></a> y86-64 assembly code</h3><p>一个简单的C函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">long</span> *start, <span class="hljs-type">long</span> count)</span><br>&#123;<br><span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (count) &#123;<br>sum += *start;<br>start++;<br>count--;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>y86汇编代码：</p><p>&quot;.&quot;开头的词是assembler directives（汇编器伪指令），告诉编译器调整地址。</p><p>注意代码的开头部分在main函数返回后就直接halt。因此这部分代码只能执行一个程序。</p><img src="../imgs/202502171456840-1742058095649-5.png"><img src="../imgs/202502171456435-1742058095649-7.png"><p>simulator在执行结束后需要检查最后的Program State是否正确，以此来判断硬件是否成功运行了y86汇编代码。</p><h3 id="isainstruction-set-architecture"><a class="markdownIt-Anchor" href="#isainstruction-set-architecture"></a> ISA(Instruction Set Architecture)</h3><p>ISA（指令集架构）就是硬件呈现给上层汇编代码的接口，上层汇编代码通过ISA知晓底层硬件长什么样，可以提供哪些功能和接口，以此来调动硬件执行任务。</p><img src="../imgs/image-20250220220533911-1742058095649-9.png" alt="" style="zoom:40%;" /><h2 id="组成cpu的building-blocks"><a class="markdownIt-Anchor" href="#组成cpu的building-blocks"></a> 组成CPU的Building Blocks</h2><p>这部分我们从组成CPU的最基本的两个building blocks入手开始学习：</p><ol><li>组合逻辑电路</li><li>Clocked Registers</li></ol><h3 id="组合电路"><a class="markdownIt-Anchor" href="#组合电路"></a> 组合电路</h3><p>组合电路是由大量逻辑门组成的。HCL就是用来描述硬件行为，生成逻辑电路的语言。<strong>HCL表达式</strong>可以用来生成完成相应任务的逻辑电路。我们写的HCL表达式可以被现成的类似于Compiler的工具翻译成最佳的逻辑电路。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HCL">bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b)<br>bool xor = (!a &amp;&amp; b) || (a &amp;&amp; !b)<br></code></pre></td></tr></table></figure><h3 id="storage-clocked-registers"><a class="markdownIt-Anchor" href="#storage-clocked-registers"></a> Storage (Clocked Registers)</h3><p>当Clock由0-&gt;1跳变，新的Input就可以写入进去，写入之后Output读出来的就是新的值。</p><p>有了Clock Register我们就可以实现存储功能。注意Clock Register不是我们所说的CPU中的寄存器。</p><img src="../imgs/image-20250220234411249-1742058095649-8.png" alt="" style="zoom:50%;" /><h3 id="state-machine"><a class="markdownIt-Anchor" href="#state-machine"></a> State Machine</h3><img src="../imgs/image-20250220235224580-1742058095649-10.png" alt="" style="zoom:40%;" /><p>上图是一个简单的状态机例子。其实我们可以把CPU就看做一个状态机，CPU对指令的执行就是对硬件状态的修改。真实的CPU其实就是更复杂的组合逻辑电路。</p><h3 id="storage-random-access-memories"><a class="markdownIt-Anchor" href="#storage-random-access-memories"></a> Storage (Random-access memories)</h3><ol><li>Register File</li></ol><p>储存Program Registers, Register Identifiers serve as address.</p><p>最多可以同时读取两个寄存器，因此有两个读取端，一个写入端。读取可以直接读出来，写入只能在Clock跳变0-&gt;1时才可以写入。其中src和dst是地址，val是寄存器的值：</p><img src="../imgs/image-20250221000206349-1742058095650-13.png" alt="" style="zoom: 80%;" /><ol start="2"><li>Memory</li></ol><p>Memory是用来存放数据和指令的，有一个error信号端口表示invalid address。</p><img src="../imgs/image-20250221000808416-1742058095650-11.png" alt="" style="zoom: 50%;" /><h2 id="sequential-cpu-implementation"><a class="markdownIt-Anchor" href="#sequential-cpu-implementation"></a> Sequential CPU Implementation</h2><h3 id="multi-stages-design"><a class="markdownIt-Anchor" href="#multi-stages-design"></a> Multi-stages Design</h3><p>将指令的执行分解为一系列的阶段(stage)，为了能够复用硬件（电路）。</p><h3 id="指令执行的6个阶段stage"><a class="markdownIt-Anchor" href="#指令执行的6个阶段stage"></a> 指令执行的6个阶段(stage)</h3><ol><li>Fetch: 从内存中读取指令</li><li>Decode: 读取寄存器</li><li>Execute: 执行ALU操作（计算）</li><li>Memory: 读/写内存</li><li>Write Back: 写入寄存器</li><li>PC: 更新PC</li></ol><p>所有指令都要经过这6个阶段，共用相同的电路。</p><p><img src="../imgs/image-20250225195335684-1742058095650-12.png" alt="" /></p><p>For example, an OPq instruction:</p><img src="../imgs/image-20250225215036893-1742058095650-14.png" style="zoom:67%;" /><blockquote><p>在指令执行的过程中所有的Processor state (memory, registers, CC, program status, PC)都是什么时候修改的？</p></blockquote><p>你可能会想不同的processor state是在不同的阶段更新的。但其实所有的状态都存在clocked registers里面，而clock registers只有在clock从0跳变到1时才会写入新的值，整个CPU共用一个clock，clock跳一下（一个cycle）执行一条指令，因此所有的processor state其实是同时更新的！</p><p>一条指令执行（一个cycle）的大部分时间，都是让信号流满整个组合电路。等所有更新后的状态值都准备好等在clocked registers门口了，clock跳变，将所有新的状态一起写入进去。</p><p><img src="../imgs/image-20250225221408295-1742058095650-15.png" alt="" /></p><h3 id="逻辑电路实现"><a class="markdownIt-Anchor" href="#逻辑电路实现"></a> 逻辑电路实现</h3><p>上面介绍了CPU将指令分解成各个阶段的设计，下面将介绍每个阶段具体的逻辑电路实现。</p><img src="../imgs/image-20250227223029445-1742058095650-16.png" style="zoom:67%;" /><ul><li>Fetch Logic</li></ul><img src="../imgs/image-20250227222756361-1742058095650-17.png" style="zoom:67%;" /><p>Fetch中主要Control Logic的HCL表达式：</p><img src="../imgs/image-20250227223913654-1742058095650-19.png" style="zoom: 40%;" /><img src="../imgs/image-20250227224335402-1742058095650-18.png" style="zoom:40%;" /><p>注意如果mem出错，将<code>icode</code>设为<code>nop</code></p><ul><li>Decode &amp; Write-Back Logic</li></ul><img src="../imgs/image-20250227224513614-1742058095650-20.png" style="zoom: 50%;" /><p>Decode中主要Control Logic的HCL表达式：</p><img src="../imgs/image-20250227225209729-1742058095650-21.png" style="zoom:40%;" /><p>Write-Back中主要Control Logic的HCL表达式：</p><img src="../imgs/image-20250227225453563-1742058095650-23.png" alt="" style="zoom:40%;" /><p>对<code>cmovXX</code>需要单独给他增加一条规则：如果Cnd为1，则dstE是rB，否则是RNONE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HCL">icode == IRRMOVQ &amp;&amp; Cnd : rB;<br></code></pre></td></tr></table></figure><ul><li>Execute Logic</li></ul><img src="../imgs/image-20250227230029619-1742058095650-22.png" style="zoom: 50%;" /><p>Execute中主要Control Logic的HCL表达式：</p><img src="../imgs/image-20250227230449629-1742058095650-24.png" style="zoom:40%;" /><img src="../imgs/image-20250227230542728-1742058095650-25.png" alt="" style="zoom:40%;" /><ul><li>Memory Logic</li></ul><img src="../imgs/image-20250227230637783-1742058095650-26.png" style="zoom:50%;" /><p>Memory中主要Control Logic的HCL表达式：</p><img src="../imgs/image-20250227231059194-1742058095650-28.png" style="zoom:40%;" /><ul><li>PC Update Logic</li></ul><img src="../imgs/image-20250227231156293-1742058095650-27.png" style="zoom:50%;" /><p>PC Update中主要Control Logic的HCL表达式：</p><img src="../imgs/image-20250303100657316-1742058095650-29.png" alt="" style="zoom: 40%;" /><h3 id="seq总结"><a class="markdownIt-Anchor" href="#seq总结"></a> SEQ总结</h3><p>SEQ CPU执行起来是很慢的。一个cycle（clock跳变一次）只会执行一条指令。大部分时间都浪费掉了，没有发挥出CPU的潜力！</p><h2 id="principles-of-pipeline"><a class="markdownIt-Anchor" href="#principles-of-pipeline"></a> Principles of Pipeline</h2><p>让多条指令同时充满整个CPU的所有stage。一次clock跳变每条指令前进一个stage。可以提升整体指令执行的吞吐量。通过Pipeline Registers存储指令执行阶段的中间值。</p><img src="../imgs/image-20250303115438797-1742058095650-31.png" alt="3-Way Pipeline" style="zoom: 50%;" /><h3 id="limitations-of-pipeline"><a class="markdownIt-Anchor" href="#limitations-of-pipeline"></a> Limitations of Pipeline</h3><ol><li>Nonuniform delays:</li></ol><p>吞吐量会受最慢的stage的限制。在下图的例子中，一个cycle就是170ps。A阶段和C阶段会有大量的空闲时间</p><img src="../imgs/image-20250303115609302-1742058095651-32.png" style="zoom: 67%;" /><ol start="2"><li>(Pipeline) Register Overhead</li></ol><p>如果每个阶段分得过细，那么加载pipeline register的overhead会很大。</p><ol start="3"><li>Data Dependency</li></ol><p>相邻的指令可能会依赖对方操作后的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">irmovq $50, %rax<br>addq %rax, %rbx<br>mrmovq 100(%rbx), %rdx<br></code></pre></td></tr></table></figure><p><strong>Data Hazards</strong>:</p><p>这种情况就退化回了SEQ:</p><img src="../imgs/image-20250303120422436-1742058095650-30.png" alt="" style="zoom: 40%;" /><ol start="4"><li>Control Dependency</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">loop:<br>subq %rdx, %rbx<br>jne targ<br>irmovq $10, %rdx<br>jmp loop<br>targ:<br>halt<br></code></pre></td></tr></table></figure><p>The <code>jne</code> instruction create a control dependency — Which instruction will be executed?</p><h3 id="seq-hardware"><a class="markdownIt-Anchor" href="#seq-hardware"></a> SEQ+ Hardware</h3><p>将PC Update阶段与Fetch阶段合并，不用实际的硬件寄存器存放PC，而是根据前一条指令的状态信息来动态计算PC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HCL">int pc= [<br>picode == ICALL : pValC;<br>picode == IJXX &amp;&amp; pCnd : pValC;<br>picode == IRET : pValM;<br>1 : pValP;<br>];<br></code></pre></td></tr></table></figure><p>Fetch Logic:</p><ul><li>Select current PC</li><li>Read instruction</li><li>Compute incremented PC</li></ul><h3 id="五级流水线"><a class="markdownIt-Anchor" href="#五级流水线"></a> 五级流水线</h3><img src="../imgs/image-20250303115100611-1742058095651-33.png" style="zoom:67%;" /><ul><li>Forward Paths</li></ul><p>Values passed from one stage to next（不能跳过某一阶段）</p><ul><li>Feedback Paths</li></ul><p>PC Updates需要根据指令的类型，可能需要其他阶段的执行结果来决定next PC</p><p>Register Updates需要等Write Back阶段结束后才能将信号拉回来</p><img src="../imgs/image-20250303122158896-1742058095651-35.png" alt="" style="zoom:67%;" /><ul><li>预测PC</li></ul><p>当前指令执行完fetch阶段后就会开始fetch新的指令，没办法可靠地决定新的指令的PC，因此需要先猜测一个PC值，如果猜错了后面再恢复。</p><blockquote><p>What is our prediction strategy?</p></blockquote><ul><li>Instructions that don't transfer control, always <code>next PC = valP</code></li><li>Call and Unconditional Jumps, always <code>next PC = valC</code></li><li>Conditional jumps, predict <code>next PC = valC</code>, only correct if branch is taken(一般正确率在60%)</li><li>Return Instruction, don't try to predict</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HCL">Int F_predPC = [<br>f_icode in &#123;IJXX, ICALL&#125; : f_valC;<br>1: f_valP;<br>];<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250303122845813-1742058095651-36.png" alt="" style="zoom:67%;" /><p>Recover from PC misprediction:</p><img src="../imgs/image-20250303123312158-1742058095651-34.png" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HCL">int f_PC = [<br>#mispredicted branch. Fetch at incremented PC<br>  M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;<br>#completion of RET instruciton<br>  W_icode == IRET : W_valM;<br>#default: Use predicted value of PC<br>  1: F_predPC<br>];<br></code></pre></td></tr></table></figure><h2 id="hazard"><a class="markdownIt-Anchor" href="#hazard"></a> Hazard</h2><p>Pipeline比起SEQ会带来Hazard的问题：</p><ol><li>Data Hazard: 前一条指令修改某个寄存器，还没来得及将结果写入Register FIile, 后一条指令就需要读这个寄存器。这种情况在代码中非常普遍</li><li>Control Hazard: jXX指令要根据前一条指令的ALU运算结果设置的CC才能确定下一条指令的PC</li></ol><h3 id="data-hazard"><a class="markdownIt-Anchor" href="#data-hazard"></a> Data Hazard</h3><ul><li>Naive Solution 1: <code>nop</code></li></ul><p>最Naive的解决方案是在两条相互依赖的指令之间插<code>nop</code>指令（编译器可以分析你的代码，然后帮你做到这一点）。</p><ul><li>Naive Solution 2: Stalling</li></ul><p>在cpu内部解决，将指令停在decode阶段，（每个cycle）都往上（execution阶段）插入bubble。</p><img src="../imgs/image-20250306135337760-1742058095651-38.png" alt="连插三个bubble" style="zoom: 50%;" /><p>但是这两种解决方案Pipeline的效果就变差了，因为相互依赖的指令在实际代码中非常普遍。</p><p>有没有什么办法可以减少<code>nop/bubble</code>的插入？</p><ul><li>Data Forwarding</li></ul><p>我们其实可以把我们要的数据提前拉过来，而不一定要等上一条指令最后Write Back阶段结束后再从寄存器读出来。这种实现技术就叫Data Forwarding</p><p>可以在decode阶段，加一个选择器。如果出现data dependency情况，就从later stage拉回来的信号取值，否则就正常从Register File中取值。</p><p>什么时候可以从later stage里将信号拉回来取决于指令的类型，如果是从寄存器/立即数写入寄存器(<code>irmovq</code>, <code>rrmovq</code>)，那么可以在execute阶段结束将<code>e_valE</code>拉回来，如果是要从memory中写入寄存器(<code>mrmovq</code>)，那要在memory阶段结束将<code>m_valM</code>拉回来。</p><img src="../imgs/image-20250306155549361-1742058095651-39.png" style="zoom:67%;" /><h3 id="control-hazard"><a class="markdownIt-Anchor" href="#control-hazard"></a> Control Hazard</h3><p>前面一条指令会改变执行流。因此我们需要猜测后一条指令的地址（PC Prediction）。</p><ul><li><code>ret</code></li></ul><p>对于<code>ret</code>指令，我们无法猜测后一条指令的地址，因此需要采取前面提到的Stalling技术，在fetch阶段将指令截停：</p><img src="../imgs/image-20250306162310356-1742058095651-37.png" style="zoom:67%;" /><p>一个return就要插入三个bubble，所以其实return对于pipeline的overhead是比较大的。</p><ul><li><code>jXX</code></li></ul><p>对于jump指令，我们猜测他会跳转：<code>next PC = valC</code>。那如果猜错了怎么办呢？</p><p>最Naive的方式就是在跳转处插入两个<code>nop</code>，这样无论猜没猜错都不需要擦除任何指令。但是这样跟不猜PC没区别了。</p><img src="../imgs/image-20250306163041978-1742058095651-40.png" alt="" style="zoom:67%;" /><p>因此我们的解决方案是让跳转后的指令先执行，如果发现猜错了，就将执行的指令的<code>icode</code>改为<code>nop</code>(变成bubble)。通常情况下，跳转后执行的两条指令在decode和execute阶段不会修改状态(只有在execute阶段末尾才会修改<code>CC</code>)。因此我们可以做到在指令修改<code>CC</code>前及时将其擦除掉，不会产生程序员可见的状态修改。</p><img src="../imgs/image-20250306163945466-1742058095651-41.png" style="zoom:67%;" /><p>但是如果跳转后执行的指令本身是错误的指令呢？这两条指令本身就不该执行，但由于我们猜错了PC，这两条错误的指令执行的时候就会修改Program Status。</p><img src="../imgs/image-20250306171525626-1742058095651-42.png" alt="" style="zoom:67%;" /><p>我们需要专门的mechanism来处理执行流中遇到的错误，以能够避免上述情况。</p><h3 id="exception-handling"><a class="markdownIt-Anchor" href="#exception-handling"></a> Exception Handling</h3><p>y86中的异常类型：</p><ol><li>Invalid address</li><li>Invalid instruction</li><li>Halt</li></ol><p>正常执行流中遇到了异常，就需要exception handling。对y86来说，exception handling需要做到的是：program在遇到异常后停在正确的状态下，异常的指令停在当前位置，异常指令前的指令正常执行完，异常指令后的指令不执行。</p><p>exception handling遇到的困难是：指令可能在流水线的不同阶段检测到异常。</p><img src="../imgs/image-20250306170849215-1742058095651-43.png" style="zoom:67%;" /><p>如何让异常前的指令正常执行完呢？我们的解决方案是：在指令遇到异常的阶段，先将status写入pipeline register，然后将指令变为nop，当作无事发生继续执行，如果指令到Write Back了status依然是异常，那么此时再处理。注意对于因为分支预测错误执行的指令来说，应当在发现预测错误后擦除状态（将status改回成<code>OK</code>）。</p><img src="../imgs/image-20250306172322252-1742058095651-45.png" alt="" style="zoom: 80%;" /><p>如何保证异常指令后面的指令不会产生效果（修改状态）？当一条指令来到Memory阶段status是异常，说明该指令一定是异常指令（后续Write Back的时候会处理），此时Memory及时关闭肯定来得及，但CC呢？只要在Memory阶段发现错误时立即关闭CC，就可以保证在后一条指令执行完execute前CC就被关闭了，所以也来得及！</p><h2 id="pipe-cpu-implementation"><a class="markdownIt-Anchor" href="#pipe-cpu-implementation"></a> Pipe CPU Implementation</h2><h3 id="pipe-stage-implementations"><a class="markdownIt-Anchor" href="#pipe-stage-implementations"></a> PIPE Stage Implementations</h3><ul><li>Fetch</li></ul><img src="../imgs/image-20250311163417401-1742058095651-44.png" style="zoom:67%;" /><p>对于设置status来说：</p><p>先取指令的地址，如果地址错误设置为<code>SADR</code>；再检查指令的<code>icode</code>，如果<code>icode</code>无效设置为<code>SINS</code>；再看<code>icode</code>是否为halt，如果是则设置为<code>SHLT</code>；如果都没发生，就设置为<code>SAOK</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HCL">int f_stat = [<br>imem_error:     SADR;<br>!instr_valid:     SINS;<br>f_icode == IHALT: SHLT;<br>1:        SAOK;<br>];<br></code></pre></td></tr></table></figure><ul><li>Decode and Write-Back</li></ul><p>Forwarding Logic: The Order Matters!</p><img src="../imgs/image-20250311164815350-1742058095651-46.png" style="zoom:67%;" /><p>对于Write Back阶段，需要将bubble的status设置为OK：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HCL">word Stat = [<br>W_stat == SBUB : SAOK;<br>1 : W_stat;<br>]<br></code></pre></td></tr></table></figure><ul><li>Execute</li></ul><img src="../imgs/image-20250311165558162-1742058095651-47.png" style="zoom:67%;" /><p>需要检查能否修改CC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HCL"># Should the condition codes be updated?<br>bool set_cc = (E_icode == IOPL)<br># State changes only during normal operation<br>      &amp;&amp; !m_stat in &#123; SADR, SINS, SHLT &#125; <br>      &amp;&amp; !W_stat in &#123; SADR, SINS, SHLT &#125;;<br></code></pre></td></tr></table></figure><ul><li>Memory</li></ul><img src="../imgs/image-20250311165818294-1742058095651-48.png" style="zoom:67%;" /><p>如果访问地址出错，需要设置status：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HCL">int m_stat = [<br>dmem_error : SADR;<br>1 : M_stat;<br>];<br></code></pre></td></tr></table></figure><h3 id="pipeline-control-logic"><a class="markdownIt-Anchor" href="#pipeline-control-logic"></a> Pipeline Control Logic</h3><p>Pipeline中有一些情况仅靠data forwarding和branch prediction无法解决。</p><ul><li>Load/Use Hazard</li></ul><p>Load指从memory写到register，Use指用到这个register。光用Forwarding来不及。</p><p>前一条指令要写的寄存器是后一条指令要读的寄存器：</p><img src="../imgs/image-20250311171641923-1742058095651-49.png" alt = "Detect Load/Use Hazard" style="zoom:67%;" /><p>需要在Fetch和Decode阶段插stall，在execute阶段插一个bubble。</p><ul><li>Mispredicted Branch</li></ul><img src="../imgs/image-20250311172757769-1742058095651-51.png" style="zoom:67%;" /><p>jump指令去到了Memory，需要将decode和execute阶段的两条指令一起擦成bubble。</p><ul><li>Return</li></ul><p>不预测PC，需要在Fetch阶段插入stall，在decode阶段连续插入三次bubble。</p><ul><li>Exception</li></ul><p>发现异常后在Write Back阶段插入stall，将错误指令停在Write Back阶段。在Memory阶段插入bubble。</p><h2 id="performance-analysis"><a class="markdownIt-Anchor" href="#performance-analysis"></a> Performance Analysis</h2><h3 id="performance-metrics"><a class="markdownIt-Anchor" href="#performance-metrics"></a> Performance Metrics</h3><ol><li>Clock Rate</li><li>CPI (cycles per instruction)</li></ol><p>理想情况下CPI = 1，但是流水线有时需要插入bubble，有时需要stall。</p><p>$ CPI   =   C/I   =   (I+B)/I   =  1.0 + B/I $</p><p><code>B/I</code>就是流水线设计的overhead。</p><h3 id="modern-processor"><a class="markdownIt-Anchor" href="#modern-processor"></a> Modern Processor</h3><p>前面的流水线设计一个cycle最多执行一条指令。但是如果指令之间没有依赖关系，其实可以并行执行。Modern Processor有更多的硬件资源和指令分析能力，能够支持指令的并行执行。</p><ul><li><p>Superscalar：每个clock cycle并行执行多条操作。</p></li><li><p>Out-of-order execution（乱序执行）</p></li></ul><p>现代处理器主要由以下两部分组成：</p><ol><li>Instruction Control Unit (ICU)</li><li>Execution Unit (EU)</li></ol><img src="../imgs/image-20250316001349190-1742058095651-50.png" style="zoom: 67%;" /><p>ICU中的Fetch Control负责从Instruction Cache中读取指令。</p><p>ICU中的Instruction Decode负责将上层指令分解为primitive operations（微指令）</p><p>比如：</p><img src="../imgs/image-20250316001611080-1742058095651-52.png" style="zoom: 50%;" /><p>EU是Multi-functional Units，指令可以并行。每个functional unit可能是pipelined的。</p><img src="../imgs/image-20250316003959533-1742058095651-53.png" style="zoom: 80%;" /><p>每个functional unit执行完产生的结果会放到总线上，在所有function units间共享，这就是现代处理器的data forwarding技术。</p><p>Reorder buffer根据上层register renaming操作的结果，判断指令的依赖关系，将重新排序的指令交给Dispatch，Dispatch负责将不同的指令交给不同的functional unit执行。</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Y86</tag>
      
      <tag>ICS</tag>
      
      <tag>Processor</tag>
      
      <tag>Pipeline</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP Chapter6</title>
    <link href="/2025/03/03/CSAPP-Chapter6/"/>
    <url>/2025/03/03/CSAPP-Chapter6/</url>
    
    <content type="html"><![CDATA[<p>这篇笔记将记录我在ICS课上学习CSAPP第六章The Memory Hierarchy的过程。已完结。</p><h1 id="the-memory-hierarchy"><a class="markdownIt-Anchor" href="#the-memory-hierarchy"></a> The Memory Hierarchy</h1><h2 id="memory-hierarchy"><a class="markdownIt-Anchor" href="#memory-hierarchy"></a> Memory Hierarchy</h2><h3 id="memory"><a class="markdownIt-Anchor" href="#memory"></a> Memory</h3><p><strong>RAM</strong>：基础存储单元是一个cell，一个cell存储一个bit。</p><ul><li>Static RAM：更稳定、更快、更贵</li><li>Dynamic RAM：需要持续充电保证内部状态稳定</li></ul><p>SRAM和DRAM都是volatile memories，断电后数据会丢失。</p><p><strong>ROM</strong>：nonvolatile memories，断电后数据不会丢失。</p><p><strong>Firmware</strong>：存储在ROM中的程序，可编程。</p><p>CPU和memory通过bus连接起来。</p><h3 id="disk"><a class="markdownIt-Anchor" href="#disk"></a> Disk</h3><p>一个platter有两个surface，一个surface上有很多track，每个track会切成一个个间隔开的sector。</p><p><img src="../imgs/image-20250428162521686-1746688219507-1.png" alt="Disk geometry" /></p><p>磁盘自身会旋转，手臂的head在不同track之间移动。</p><p><img src="../imgs/image-20250428162912022-1746688219508-2.png" alt="Disk dynamics" /></p><h3 id="memory-mapped-io"><a class="markdownIt-Anchor" href="#memory-mapped-io"></a> Memory-mapped I/O</h3><p>内存映射区域：I/O设备映射到地址空间的一部分区域。</p><p>CPU访问这部分区域，通过总线向外部设备的port发送读写指令。</p><img src="../imgs/image-20250428191539907-1746688219508-3.png" style="zoom:67%;" /><p>通常CPU会进行异步I/O，将后续事情交给disk controller来做。磁盘通过DMA将数据从磁盘写入memory。当DMA transfer完成后，disk controller会通过中断通知CPU的pin（引脚）。</p><h3 id="solid-state-disk-ssd"><a class="markdownIt-Anchor" href="#solid-state-disk-ssd"></a> Solid State Disk (SSD)</h3><p>– 基于flash memory</p><p>– Flash translation layer = disk controller</p><img src="../imgs/image-20250505231752337-1746688219508-4.png" alt="SSD" style="zoom: 50%;" /><p>一个page只能写一次，重新写要先擦掉。一次性会擦掉一整个block（因为擦除操作开销很大）。</p><p>一个block重复写多次（100000次）后会wear out。</p><p>顺序读写很快 随机写很慢。</p><h3 id="locality"><a class="markdownIt-Anchor" href="#locality"></a> Locality</h3><ul><li>Temporal locality（时间局部性）</li></ul><p>最近被访问的数据，倾向于很快会再次被访问。</p><ul><li>Spatial locality（空间局部性）</li></ul><p>访问的数据临近的其他数据，倾向于会一起访问。</p><h3 id="caches"><a class="markdownIt-Anchor" href="#caches"></a> Caches</h3><p>金字塔的越上面越小、越快、越贵。</p><p>每个上面一层都是下一层的cache。</p><img src="../imgs/image-20250506013836648-1746688219508-5.png" alt="An example memory hierarchy" style="zoom:50%;" /><p>Cache Misses:</p><ol><li>Cold miss：cache为空</li><li>Capcity miss：cache已满</li><li>Conflict miss：cache中有空间，但是有多个数据映射到cache的相同位置，与硬件设计相关</li></ol><p>Cache Memory在CPU芯片上：</p><img src="../imgs/image-20250506131756031-1746688219508-6.png" alt="Cache Memory" style="zoom:50%;" /><h4 id="generic-cache-memory-organization"><a class="markdownIt-Anchor" href="#generic-cache-memory-organization"></a> Generic Cache Memory Organization</h4><p>Cache由一组set组成，每个set包含一条或多条line。</p><img src="../imgs/image-20250506132646806-1746688219508-7.png" alt="General organization of cache" style="zoom:67%;" /><p>先通过set index确定set，然后匹配tag，最后访问block offset：</p><img src="../imgs/image-20250506170350460-1746688219508-8.png" alt="Address" style="zoom:67%;" /><p>Direct-mapped cache: 一个set只包含一条line。L1 cache最早会用这种设计。速度较快，但是thrashing(conflict)会比较严重。</p><p>Set associative cache: 一个set包含多条line，line match的时候一起匹配。</p><p>越上层的cache的associate越小。</p><h4 id="line-replacement-on-misses"><a class="markdownIt-Anchor" href="#line-replacement-on-misses"></a> Line Replacement on Misses</h4><blockquote><p>如何选择要驱逐的line？</p></blockquote><ul><li><p>LFU (least-frequently-used)</p></li><li><p>LRU (least-recently-used)</p></li></ul><h4 id="write-cache-friendly-code"><a class="markdownIt-Anchor" href="#write-cache-friendly-code"></a> Write cache-friendly code</h4><p>有better locality的程序会有较低的miss rate。</p><img src="../imgs/image-20250508144228078-1746688219508-9.png" alt="A memory mountain" style="zoom: 80%;" />]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICS</tag>
      
      <tag>Memory Hierarchy</tag>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab 6</title>
    <link href="/2025/02/27/cs144-lab6/"/>
    <url>/2025/02/27/cs144-lab6/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-checkpoint-6-building-an-ip-router"><a class="markdownIt-Anchor" href="#lab-checkpoint-6-building-an-ip-router"></a> Lab Checkpoint 6: building an IP router</h1><blockquote><p><a href="https://cs144.github.io/assignments/check6.pdf">Checkpoint6 spec</a></p></blockquote><div class="note note-warning">            <p>注意，这篇笔记My implementation部分全程代码剧透！</p>          </div><h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p>In this lab, you will implement an IP router on top of your existing <code>NetworkInterface</code>. A router has several network interfaces, and can receive Internet datagrams on any of them. The router’s job is to forward the datagrams it gets according to the <strong>routing table</strong>: a list of rules that tells the router, for any given datagram:</p><ul><li><p>What interface to send it out</p></li><li><p>The IP address of the next hop</p></li></ul><p>Your job is to implement a router that can figure out these two things for any given datagram.</p><img src="../imgs/image-20250226155033564-1740593730414-1.png" style="zoom: 80%;" /><p>根据上图，一个router包含多个network interface，router根据routing table得知其收到的datagram的next hop，然后将其放到合适的outbound interface上。</p><p>注意这个lab不需要你实现Network Control Plane中生成routing table的routing algorithm（如RIP, OSPF, BGP, SDN controller），只需要实现Network Data Plane的功能：根据routing table来实现forwarding algorithm，也就是根据<strong>longest-prefix-match</strong> logic在routing table中寻找next hop和outbound interface</p><h2 id="my-implementation"><a class="markdownIt-Anchor" href="#my-implementation"></a> My implementation</h2><p>我们的router需要干两件事情：</p><ol><li>维护并添加routing table中的条目</li><li>根据longest-prefix-match，将下层Network Interface的datagrams送往合适的next hop和outbound interface</li></ol><p>那么首先第一步，就是要确定用什么数据结构表示routing table，用来存储route prefix， prefix_length以及对应的next hop，outbound interface。lab的spec里面说我们不需要什么fancy的数据结构和算法来支持寻找longest-prefix-match的操作，<code>O(N)</code>的时间复杂度就够用。所以很简单，就用一个map，将&lt;route prefix, prefix_length&gt;作为key，&lt;next hop, outbound interface&gt;作为value就可以了。寻找longest-prefix-match就是遍历这个map，找到match的条目中prefix_length最长的。所以我希望这个map能按照prefix_length从大到小排序，这样从头开始遍历找到的第一个match的条目就是longest-prefix-match！</p><p>要让map按照prefix_length从大到小排序，我得自己给这个map定义一个比较函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Define a comparison function for the routing table</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RouteCompare</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-type">const</span> std::pair&lt;<span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint8_t</span>&gt;&amp; a, <span class="hljs-type">const</span> std::pair&lt;<span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint8_t</span>&gt;&amp; b )</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// Sort by prefix_length in descending order (from largest to smallest)</span><br>        <span class="hljs-keyword">if</span> ( a.second != b.second ) &#123;<br>            <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>        &#125;<br>        <span class="hljs-comment">// If prefix_length is the same, sort by route_prefix in ascending order</span><br>        <span class="hljs-keyword">return</span> a.first &lt; b.first;<br>    &#125;<br>&#125;;<br><br>std::map&lt;std::pair&lt;<span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint8_t</span>&gt;, std::pair&lt;std::optional&lt;<span class="hljs-type">uint32_t</span>&gt;, <span class="hljs-type">size_t</span>&gt;, RouteCompare&gt; routing_table_ &#123;&#125;;<br></code></pre></td></tr></table></figure><p><code>add_route</code>负责向routing table中添加条目，注意如果next_hop为空说明datagram要去往的network是直接与当前router连接着的，与当前条目匹配的datagram的next hop就是其destination ip address。这就是为什么上面的routing table结构中next_hop可能为空，要用<code>std::optional&lt;&gt;</code>来封装。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// route_prefix: The &quot;up-to-32-bit&quot; IPv4 address prefix to match the datagram&#x27;s destination address against</span><br><span class="hljs-comment">// prefix_length: For this route to be applicable, how many high-order (most-significant) bits of</span><br><span class="hljs-comment">//    the route_prefix will need to match the corresponding bits of the datagram&#x27;s destination address?</span><br><span class="hljs-comment">// next_hop: The IP address of the next hop. Will be empty if the network is directly attached to the router (in</span><br><span class="hljs-comment">//    which case, the next hop address should be the datagram&#x27;s final destination).</span><br><span class="hljs-comment">// interface_num: The index of the interface to send the datagram out on.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Router::add_route</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> route_prefix,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> prefix_length,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">const</span> optional&lt;Address&gt; next_hop,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> interface_num )</span></span><br><span class="hljs-function"></span>&#123;<br>    cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="hljs-built_in">from_ipv4_numeric</span>( route_prefix ).<span class="hljs-built_in">ip</span>() &lt;&lt; <span class="hljs-string">&quot;/&quot;</span><br>        &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;( prefix_length ) &lt;&lt; <span class="hljs-string">&quot; =&gt; &quot;</span> &lt;&lt; ( next_hop.<span class="hljs-built_in">has_value</span>() ? next_hop-&gt;<span class="hljs-built_in">ip</span>() : <span class="hljs-string">&quot;(direct)&quot;</span> )<br>        &lt;&lt; <span class="hljs-string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-comment">// debug( &quot;unimplemented add_route() called&quot; );</span><br><br>    optional&lt;<span class="hljs-type">uint32_t</span>&gt; next_hop_ip;<br><br>    <span class="hljs-keyword">if</span> ( !next_hop.<span class="hljs-built_in">has_value</span>() ) &#123;<br>        next_hop_ip = <span class="hljs-literal">nullopt</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        next_hop_ip = next_hop-&gt;<span class="hljs-built_in">ipv4_numeric</span>();<br>    &#125;<br><br>    routing_table_.<span class="hljs-built_in">insert</span>( &#123; <span class="hljs-built_in">make_pair</span>( route_prefix, prefix_length ), <span class="hljs-built_in">make_pair</span>( next_hop_ip, interface_num ) &#125; );<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是实现<code>route</code>，负责将router在所有Network Interface上接收到的datagrams都在routing table中寻找longest-prefix-match，由合适的Network Interface将他们送到各自的next hop。</p><p>这需要我们遍历router的所有Network Interface，将等待在queue中的datagram一个个拿过来，去routing table中寻找longest-prefix-match，然后根据match结果送往合适的outbound interface（或drop）。</p><p>寻找longest-prefix-match的过程我用helper functions来完成，每扫描一个条目，用<code>is_prefix_match</code>判断是否match，直到找到第一个match的条目。</p><p><code>is_prefix_match</code>的实现也很简单，就是比较两个32 bits数高N位是否相等的问题，用掩码轻松搞定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_longest_prefix_match</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> dest_ip, <span class="hljs-type">uint32_t</span>&amp; next_hop_ip, <span class="hljs-type">size_t</span>&amp; interface_num )</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; it : routing_table_ ) &#123;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">is_prefix_match</span>( dest_ip, it.first.first, it.first.second ) ) &#123;<br>            <span class="hljs-keyword">if</span> ( !it.second.first.<span class="hljs-built_in">has_value</span>() ) &#123;<br>                next_hop_ip = dest_ip;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                next_hop_ip = *it.second.first;<br>            &#125;<br>            interface_num = it.second.second;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prefix_match</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> address, <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> prefix, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> prefix_length )</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Special case: if prefix_length is 0, all addresses match</span><br>    <span class="hljs-keyword">if</span> ( prefix_length == <span class="hljs-number">0</span> ) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-type">uint32_t</span> mask = <span class="hljs-number">0xffffffff</span> &lt;&lt; ( <span class="hljs-number">32</span> - prefix_length );<br><br>    <span class="hljs-keyword">return</span> ( address &amp; mask ) == ( prefix &amp; mask );<br>&#125;<br></code></pre></td></tr></table></figure><p>但是要注意<code>prefix_length = 0</code>的special case，routing table中可能会有0.0.0.0/0的条目，也就是无论datagram的destination ip address是多少都match。如果用<code>mask = 0xffffffff &lt;&lt; ( 32 - prefix_length )</code>来构造掩码会造成未定义行为，因此要特殊处理，否则test会报错：</p><p><img src="../imgs/image-20250227011740171-1740592750517-3-1740593730414-2.png" alt="shift 32 bits" /></p><p>有了<code>find_longest_prefix_match</code>这个helper function，<code>route</code>就很简单了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Go through all the interfaces, and route every incoming datagram to its proper outgoing interface.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Router::route</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// debug( &quot;unimplemented route() called&quot; );</span><br><br>    <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ( i &lt; interfaces_.<span class="hljs-built_in">size</span>() ) &#123;<br>        queue&lt;InternetDatagram&gt;&amp; datagrams_queue = <span class="hljs-built_in">interface</span>( i )-&gt;<span class="hljs-built_in">datagrams_received</span>();<br>        <span class="hljs-keyword">while</span> ( !datagrams_queue.<span class="hljs-built_in">empty</span>() ) &#123;<br>            InternetDatagram dgram = datagrams_queue.<span class="hljs-built_in">front</span>();<br>            datagrams_queue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> ( dgram.header.ttl &lt;= <span class="hljs-number">1</span> ) &#123;<br>                <span class="hljs-comment">// If the TTL field is already 0, or hits 0 after the decrement, drop the datagram.</span><br>                cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Dropped datagram: ttl = &quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;( dgram.header.ttl )<br>                    &lt;&lt; <span class="hljs-string">&quot;, src = &quot;</span> &lt;&lt; Address::<span class="hljs-built_in">from_ipv4_numeric</span>( dgram.header.src ).<span class="hljs-built_in">ip</span>()<br>                    &lt;&lt; <span class="hljs-string">&quot;, dst = &quot;</span> &lt;&lt; Address::<span class="hljs-built_in">from_ipv4_numeric</span>( dgram.header.dst ).<span class="hljs-built_in">ip</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            dgram.header.ttl--;<br><br>            <span class="hljs-type">uint32_t</span> next_hop_ip;<br>            <span class="hljs-type">size_t</span> interface_num;<br>            <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">find_longest_prefix_match</span>( dgram.header.dst, next_hop_ip, interface_num ) ) &#123;<br>                <span class="hljs-comment">// If no route is found, drop the datagram.</span><br>                cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: No route found for datagram: ttl = &quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;( dgram.header.ttl )<br>                    &lt;&lt; <span class="hljs-string">&quot;, src = &quot;</span> &lt;&lt; Address::<span class="hljs-built_in">from_ipv4_numeric</span>( dgram.header.src ).<span class="hljs-built_in">ip</span>()<br>                    &lt;&lt; <span class="hljs-string">&quot;, dst = &quot;</span> &lt;&lt; Address::<span class="hljs-built_in">from_ipv4_numeric</span>( dgram.header.dst ).<span class="hljs-built_in">ip</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">interface</span>( interface_num )-&gt;<span class="hljs-built_in">send_datagram</span>( dgram, Address::<span class="hljs-built_in">from_ipv4_numeric</span>( next_hop_ip ) );<br>            cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Routed datagram: ttl = &quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;( dgram.header.ttl )<br>                &lt;&lt; <span class="hljs-string">&quot;, src = &quot;</span> &lt;&lt; Address::<span class="hljs-built_in">from_ipv4_numeric</span>( dgram.header.src ).<span class="hljs-built_in">ip</span>()<br>                &lt;&lt; <span class="hljs-string">&quot;, dst = &quot;</span> &lt;&lt; Address::<span class="hljs-built_in">from_ipv4_numeric</span>( dgram.header.dst ).<span class="hljs-built_in">ip</span>()<br>                &lt;&lt; <span class="hljs-string">&quot;, to next hop = &quot;</span> &lt;&lt; Address::<span class="hljs-built_in">from_ipv4_numeric</span>( next_hop_ip ).<span class="hljs-built_in">ip</span>() &lt;&lt; <span class="hljs-string">&quot; on interface &quot;</span><br>                &lt;&lt; interface_num &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>        ++i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我故意留了一个小错误，也是我自己实现的时候忽略的，导致我在下面的test fail处卡了很久：</p><img src="../imgs/image-20250227010828254-1740590197937-1-1740593730414-5.png" alt="bad IPv4 datagram"  /><p>你看出来问题出在哪了吗？我当时百思不得其解，明明router接收到的datagram还是正常的，为什么发送出去的就是<code>bad IPv4 datagram</code>呢？</p><p>原来我在将datagram header中的<code>TTL</code>减1后忘记重新计算header的<code>checksum</code>了！如果这样发送出去接收到datagram的host/router检查了<code>checksum</code>之后就会判定datagram损坏了！仅仅漏这一行代码，这个router发送出去的所有datagram都是坏了没法用的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">...<br>dgram.header.ttl--;<br>dgram.header.<span class="hljs-built_in">compute_checksum</span>();<br>...<br></code></pre></td></tr></table></figure><h2 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish!</h2><p>Your router will be tested in the simulated network below:</p><img src="../imgs/image-20250227000328851-1740593730414-3.png" alt="The simulated test network" style="zoom:67%;" /><p>All tests in check5 pass!</p><img src="../imgs/image-20250227011618187-1740593730414-4.png" alt="check6" style="zoom:80%;" /><h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h2><p>写完这个lab后，你应该能感受到Internet分层分工设计的优雅之处。我们的router不需要关心上层的TCP，下层的Link Layer长什么样（不用关心Ethernet frame，或者link layer的ARP协议），只需要关心Network Datagrams，剩下的就交给下层的Network Interface处理就行了。我们不需要关心Network Interface是怎么从外部接收到Network Datagrams的，也不需要关心他是怎么把Network Datagrams送出到next hop的，只需要把router需要他做到的事情交给他做，并信任他能够做到就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Protocol Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeTop每日刷题</title>
    <link href="/2025/02/26/CodeTop/"/>
    <url>/2025/02/26/CodeTop/</url>
    
    <content type="html"><![CDATA[<p>从今天开始，我将每天坚持按<code>CodeTop</code>面试出现频度从高到低排序从第一题开始刷起，暂定每日刷两题。将会持续更新题解……</p><h1 id="day1226"><a class="markdownIt-Anchor" href="#day1226"></a> Day1(2.26)</h1><h2 id="leetcode-3-无重复字符的最长子串medium"><a class="markdownIt-Anchor" href="#leetcode-3-无重复字符的最长子串medium"></a> <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">Leetcode 3. 无重复字符的最长子串(Medium)</a></h2><blockquote><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>  请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul></blockquote><p>这道题我看了提示第一句：“Generate all possible substrings”被误导了（好吧是我理解的问题），我第一反应是从长到短遍历所有substrings，直到找到第一个不含重复字符的字符串，然后返回其长度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> len = s.<span class="hljs-built_in">length</span>(); len &gt; <span class="hljs-number">0</span>; len--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>() - len + <span class="hljs-number">1</span>; i++) &#123;<br>                    string substring = s.<span class="hljs-built_in">substr</span>(i, len);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isUnique</span>(substring)) &#123;<br>                        <span class="hljs-keyword">return</span> substring.<span class="hljs-built_in">length</span>();<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnique</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            unordered_set&lt;<span class="hljs-type">char</span>&gt; set;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>                <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">find</span>(ch) != set.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                set.<span class="hljs-built_in">insert</span>(ch);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然而这个算法时间复杂度是糟糕的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，连test都要超时，要更换思路。</p><p>我想到可以从左到右扫描字符串，用<strong>哈希表</strong>存储扫描到的字符和字符的最后出现位置(index)，用一个<strong>Sliding Window</strong>表示当前扫描到的无重复字符的substring。当遇到重复的字符且该字符在Sliding Window里面，那就需要更新Sliding Window的起始位置；否则的话检查当前的substring的长度是否超过了之前记录的最大长度<code>maxlen</code>，如果是那就更新<code>maxlen</code>。同时每扫描一个字符，都在哈希表中重新更新当前字符的最后出现位置。</p><p>这样的话只需要扫描一遍字符串，而在哈希表中通过key寻找值的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，因此总体的时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>! 这就很快了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; charLastIndex;<br>        <span class="hljs-type">size_t</span> start_pos = <span class="hljs-number">0</span>;   <span class="hljs-comment">// Sliding window的起始位置</span><br>        <span class="hljs-type">size_t</span> max_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (charLastIndex.<span class="hljs-built_in">find</span>(s[i]) != charLastIndex.<span class="hljs-built_in">end</span>() &amp;&amp; charLastIndex[s[i]] &gt;= start_pos) &#123;<br>                <span class="hljs-comment">// 如果当前字符在窗口内出现过，更新窗口的起始位置</span><br>                start_pos = charLastIndex[s[i]] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果当前字符在窗口内没有出现过，检查当前窗口的长度是否是最大的</span><br>                max_len = <span class="hljs-built_in">max</span>(max_len, i - start_pos + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 更新当前字符最后出现的位置</span><br>            charLastIndex[s[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250226002119210-1740507847618-1.png" style="zoom:67%;" /><h2 id="leetcode-146-lru缓存机制medium"><a class="markdownIt-Anchor" href="#leetcode-146-lru缓存机制medium"></a> <a href="https://leetcode.cn/problems/lru-cache">Leetcode 146. LRU缓存机制(Medium)</a></h2><blockquote><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code></li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul></blockquote><p>这道题核心关键点在<strong>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</strong>。</p><p><code>get</code>根据key要在常数项时间内得到value，唯一方法就是用哈希表<code>unordered_map</code>存储<code>key-value</code>，但是要evict的时候，单靠哈希表没办法获得LRU key。因此还需要一个数据结构能够在常数项时间内找到LRU key并删除他，同时也需要在访问key之后在常数项时间内重新排序key。要重新排序key，那就肯定要先删除这个key，再将其移动到别的位置。</p><p>也就是说，这个数据结构需要能够在常数项时间内删除任意位置的元素，那基本就锁定了，就是链表<code>list</code>!</p><p>但是<code>list</code>要在常数项时间内删除任意位置的元素，前提是你要给他指向这个元素的迭代器。 不然的话你通过key遍历链表找到要删除的元素那时间复杂度就是<code>O(N)</code>了。那有什么办法能够给定key，马上得到其在list中的迭代器呢？</p><p>那就只能在将key插入链表后，将指向key的迭代器也放入哈希表中。这样你就能通过key在哈希表中得知这个key在list中的位置，然后就能以常数项时间在list中删除key，并将其插入头/尾部了。</p><p>确定好数据结构后，实现起来就简单了。我的方法是将新访问/插入的key加到链表的末尾，同时如果key本身在链表中，还要先从当前位置删除，再加到链表末尾。而evict LRU就从链表的头部evict，你也可以将两者反过来，反正<code>list</code>是双端链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123; capacity_ = capacity; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = lru_cache_.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (it == lru_cache_.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        lru_list_.<span class="hljs-built_in">erase</span>(it-&gt;second.first);<br>        lru_list_.<span class="hljs-built_in">push_back</span>(key);<br>        it-&gt;second.first = --lru_list_.<span class="hljs-built_in">end</span>();<br>        <span class="hljs-keyword">return</span> it-&gt;second.second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = lru_cache_.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (it != lru_cache_.<span class="hljs-built_in">end</span>()) &#123;<br>            lru_list_.<span class="hljs-built_in">erase</span>(it-&gt;second.first);<br>            lru_list_.<span class="hljs-built_in">push_back</span>(key);<br>            it-&gt;second.first = --lru_list_.<span class="hljs-built_in">end</span>();<br>            it-&gt;second.second = value;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cache_full</span>()) &#123;<br>                <span class="hljs-built_in">evict_lru</span>();<br>            &#125;<br>            lru_list_.<span class="hljs-built_in">push_back</span>(key);<br>            lru_cache_[key] = &#123;--lru_list_.<span class="hljs-built_in">end</span>(), value&#125;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> capacity_;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::pair&lt;std::list&lt;<span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">int</span>&gt;&gt; lru_cache_;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; lru_list_;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cache_full</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> lru_cache_.<span class="hljs-built_in">size</span>() == capacity_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">evict_lru</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> lru_key = lru_list_.<span class="hljs-built_in">front</span>();<br>        lru_list_.<span class="hljs-built_in">pop_front</span>();<br>        lru_cache_.<span class="hljs-built_in">erase</span>(lru_key);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250226022026507-1740507847619-2.png" style="zoom:67%;" /><h1 id="day2227"><a class="markdownIt-Anchor" href="#day2227"></a> Day2(2.27)</h1><h2 id="leetcode-206-反转链表easy"><a class="markdownIt-Anchor" href="#leetcode-206-反转链表easy"></a> <a href="https://leetcode.cn/problems/reverse-linked-list">Leetcode 206. 反转链表(Easy)</a></h2><blockquote><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/rev1ex1-1740730077355-1.jpg" alt="" /></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="../imgs/rev1ex2-1740730077355-2.jpg" alt="" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶</strong>：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p></blockquote><p>目标：分别用迭代和递归的方式解决这道题</p><h3 id="迭代法"><a class="markdownIt-Anchor" href="#迭代法"></a> 迭代法</h3><p>我的第一想法是一个个遍历<code>head-&gt;next</code>，重新创建一个新结点指向原来的头结点作为新的头结点，然后就将<code>head-&gt;next</code>删掉，删法就是让<code>head-&gt;next</code>指向<code>head-&gt;next-&gt;next</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Iterative solution 1.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *new_head = head;<br><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span> &amp;&amp; head-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            new_head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(head-&gt;next-&gt;val, new_head);<br>            head-&gt;next = head-&gt;next-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> new_head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是这样每遍历一个元素，就要多创建一个<code>ListNode</code>非常占用空间，怎么才能仅通过修改指针的方式就翻转整个链表？</p><p>答案是每遍历过去一个结点，用<code>pre</code>指针记录下这个结点。这样当遍历到下一个结点的时候，就可以将他的<code>next</code>指针指向<code>pre</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Iterative solution 2 (better).</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *pre = <span class="hljs-literal">NULL</span>;<br><br>        ListNode *p = head;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            ListNode* next = p-&gt;next;<br>            p-&gt;next = pre;<br>            pre = p;<br>            p = next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样内存消耗就是O(1)复杂度。<code>pre</code>和<code>p</code>指针只要创建一个，随着遍历向后移动。</p><img src="../imgs/image-20250228155901013-1740730077356-5.png" style="zoom:67%;" /><h3 id="递归法"><a class="markdownIt-Anchor" href="#递归法"></a> 递归法</h3><p>迭代法往往思路上更简洁优雅，这题也不例外。反转链表，本质上就是重新排序链表中的所有元素。迭代法的想法就是：</p><ol><li>先翻转（排序）好头结点之后的所有元素，返回新的头结点</li><li>再将原本的头结点加到链表末尾</li><li>最后返回新的头结点</li></ol><p>迭代结束的条件就是当前要排序的链表为空或元素个数为1，直接返回当前头结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Recursive solution.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束条件，返回新的头结点</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode *new_head = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br><br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">return</span> new_head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250227172552837-1740730077356-3.png" style="zoom:67%;" /><h2 id="leetcode-215-数组中的第k个最大元素medium"><a class="markdownIt-Anchor" href="#leetcode-215-数组中的第k个最大元素medium"></a> <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">Leetcode 215. 数组中的第K个最大元素(Medium)</a></h2><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你<strong>必须设计并实现时间复杂度为 <code>O(n)</code> 的算法</strong>解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4], k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul></blockquote><p>这题非常好！可以复习快速排序和堆排序，尤其是快速排序的各种变型！</p><p>这道题核心是要求<strong>时间复杂度为 <code>O(n)</code></strong></p><h3 id="快速选择"><a class="markdownIt-Anchor" href="#快速选择"></a> 快速选择</h3><p>第一种选择：使用快速选择算法。快速选择与快速排序是同样的核心思想，但是快速选择不需要完全排序整个数组，只要在partition的过程中正好找到那个正确位置的pivot就可以了。</p><p>快速选择其实有现成的STL算法提供：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基本语法</span><br><span class="hljs-built_in">nth_element</span>(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);<br><br><span class="hljs-comment">// 带比较器的语法</span><br><span class="hljs-built_in">nth_element</span>(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);<br></code></pre></td></tr></table></figure><p><code>nth_element</code>能够将在正常排序后会位于指定位置<code>nth</code>的元素放在这个指定位置<code>nth</code>（默认的排序方式是从小到大，也可以自定义比较器。</p><p>那这题就秒掉了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">nth_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">begin</span>() + nums.<span class="hljs-built_in">size</span>() - k, nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是我头铁想要手撕快速选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 手撕快速选择算法</span><br><span class="hljs-comment">// 随机选择pivot</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> nums[left];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> pivotIndex = left + <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">swap</span>(nums[pivotIndex], nums[right]);<br><br>        <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(nums, left, right);<br><br>        <span class="hljs-keyword">if</span> (pivot_index == nums.<span class="hljs-built_in">size</span>() - K) &#123;<br>            <span class="hljs-keyword">return</span> nums[pivot_index];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivot_index &lt; nums.<span class="hljs-built_in">size</span>() - K) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, pivot_index + <span class="hljs-number">1</span>, right, K);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, left, pivot_index - <span class="hljs-number">1</span>, K);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[right];<br>        <span class="hljs-type">int</span> i = left;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = left; j &lt; right; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt;= pivot) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>                ++i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(nums[i], nums[right]);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样随机选择pivot在大部分case（随机数据）情况下都是<code>O(N)</code>的时间复杂度，除了leetcode上最后一个test case：</p><img src="../imgs/image-20250227195951624-1740730077356-4.png" style="zoom: 67%;" /><p>这个test case包含有大量的重复数字，常规的随机选择pivot拼尽全力也无法战胜。leetcode官方题解为了应对这个精心构造的数据，用了双指针的方法用来在partition的时候<strong>快速向中间收敛</strong>。</p><p>修改后用随机选择pivot + 双指针的快速选择算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 手撕快速选择算法</span><br><span class="hljs-comment">// 随机选择pivot + 双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> nums[left];<br>        &#125;<br><br>        <span class="hljs-type">int</span> pivotIndex = left + <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">swap</span>(nums[pivotIndex], nums[right]);<br><br>        <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(nums, left, right);<br><br>        <span class="hljs-keyword">if</span> (pivot_index == nums.<span class="hljs-built_in">size</span>() - K) &#123;<br>            <span class="hljs-keyword">return</span> nums[pivot_index];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivot_index &lt; nums.<span class="hljs-built_in">size</span>() - K) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, pivot_index + <span class="hljs-number">1</span>, right, K);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, left, pivot_index - <span class="hljs-number">1</span>, K);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[right];<br>        <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> j = right;<br><br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-comment">// 从左向右找到第一个大于等于pivot的元素</span><br>            <span class="hljs-keyword">while</span> (++i &lt; right &amp;&amp; nums[i] &lt; pivot);<br>            <span class="hljs-comment">// 从右向左找到第一个小于等于pivot的元素</span><br>            <span class="hljs-keyword">while</span> (--j &gt;= left &amp;&amp; nums[j] &gt; pivot);<br><br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(nums[i], nums[right]);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250228001315221-1740730077356-7.png" style="zoom: 67%;" /><h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3><p>也可以用堆排序算法。同样可以用STL中的priority_queue秒掉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// STL priority_queue 堆排序算法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">max_heap</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            max_heap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_heap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>建堆的时间复杂度是<code>O(N)</code>, <code>pop</code>的时间复杂度是<code>O(K * logN)</code>，所以总复杂度还是<code>O(N)</code>符合要求。</p><p>但是一样，还是头铁，我要自己建堆！</p><p>建堆的过程就是从原先的vector对应的二叉树的最后一个非叶子节点作为根节点的子树开始调整，调整为大根堆，然后依次向上继续调整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 手撕堆排序算法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">buildMaxHeap</span>(nums);<br><br>        <span class="hljs-type">int</span> heapSize = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; ++i) &#123;<br>            nums[<span class="hljs-number">0</span>] = nums[heapSize - <span class="hljs-number">1</span>];<br>            heapSize--;<br>            <span class="hljs-built_in">maxHeapify</span>(nums, <span class="hljs-number">0</span>, heapSize);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> heapSize = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 从最后一个非叶子节点为根节点的子树开始，将其调整为大根堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = heapSize / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-built_in">maxHeapify</span>(nums, i, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> largest = i;<br><br>        <span class="hljs-keyword">if</span> (left &lt; heapSize &amp;&amp; nums[left] &gt; nums[largest]) &#123;<br>            largest = left;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; heapSize &amp;&amp; nums[right] &gt; nums[largest]) &#123;<br>            largest = right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (largest != i) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[largest]);<br>            <span class="hljs-built_in">maxHeapify</span>(nums, largest, heapSize);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250228011721923-1740730077356-6.png" style="zoom:67%;" /><h1 id="day3228"><a class="markdownIt-Anchor" href="#day3228"></a> Day3(2.28)</h1><h2 id="leetcode-25-k-个一组翻转链表hard"><a class="markdownIt-Anchor" href="#leetcode-25-k-个一组翻转链表hard"></a> <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group">Leetcode 25. K 个一组翻转链表(Hard)</a></h2><blockquote><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/reverse_ex1-1740714561484-25-1740820376665-1.jpg" alt="img" /></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="../imgs/reverse_ex2-1740820376666-2.jpg" alt="img" /></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[3,2,1,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p>**进阶：**你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p></blockquote><h3 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h3><p>我第一个想到的办法是复用之前<a href="https://leetcode.cn/problems/reverse-linked-list">Leetcode 206. 反转链表(Easy)</a>的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Recursive solution.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束条件，返回新的头结点</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode *new_head = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br><br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">return</span> new_head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我之前用递归的方法<strong>翻转一个链表</strong>。这题K个结点一组翻转链表无非就是<strong>翻转N/K个子链表</strong>。需要变化的点就是原先翻转后的链表末尾指向<code>NULL</code>，而这题中翻转后的<strong>子链表的末尾应该指向下一个子链表的头结点</strong>。并且递归条件从原本的<code>head-&gt;next == NULL</code>改成<code>k == 1</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 翻转一个从head开始K个结点的子链表，翻转后的链表末尾指向tail</span><br><span class="hljs-comment">// 返回翻转后的子链表的头结点</span><br><span class="hljs-function">ListNode *<span class="hljs-title">reverseKList</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k, ListNode *tail)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 递归结束条件，返回新的头结点</span><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    ListNode *new_head = <span class="hljs-built_in">reverseKList</span>(head-&gt;next, k - <span class="hljs-number">1</span>, tail);<br><br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = tail;<br><br>    <span class="hljs-keyword">return</span> new_head;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了这个helper function，下一步就是翻转一个个子链表(Group)然后让他们首尾相接就可以了。我还是用递归的方法实现<code>reverseKGroup</code>：</p><ol><li>先翻转第一个Group之后的所有Group让他们首尾相接，返回翻转好的链表的头结点</li><li>再翻转第一个Group，并将翻转好的第一个Group的末尾指向后面翻转好的链表的头结点</li><li>最后返回新的头结点</li></ol><p>要特别注意的是<code>reverseKGroup</code>递归的结束条件是当前要翻转的链表中的结点数量小于K（不到一个Group），这种情况就不进行翻转直接返回原先的头结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode *tail = head;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (tail != <span class="hljs-literal">NULL</span> &amp;&amp; count &lt; k )<br>    &#123;<br>        tail = tail-&gt;next;<br>        ++count;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt; k) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    tail = <span class="hljs-built_in">reverseKGroup</span>(tail, k);<br>    head = <span class="hljs-built_in">reverseKList</span>(head, k, tail);<br><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250228142239754-1740820376666-3.png" style="zoom:67%;" /><p>这个算法需要递归调用<code>reverseKGroup</code> N/K次，因此空间复杂度是<code>O(N/K)</code>。</p><p>那怎么才能实现进阶要求的<code>O(1)</code>空间复杂度呢？那<code>reverseKGroup</code>和<code>reverseKList</code>就不能用递归，得用迭代。</p><h3 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Iterative solution</span><br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br><br>        ListNode* pre = dummy;<br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            ListNode *tail = pre;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>                tail = tail-&gt;next;<br>                <span class="hljs-keyword">if</span> (tail == <span class="hljs-literal">NULL</span>) &#123;<br>                    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 此时的tail就指向我们当前要翻转的子链表的尾结点</span><br>            ListNode *next  = tail-&gt;next;<br>            <span class="hljs-built_in">tie</span>(head, tail) = <span class="hljs-built_in">reverseKList</span>(head, tail);<br>            <span class="hljs-comment">// 将翻转后的子链表接回原链表</span><br>            tail-&gt;next = next;<br>            pre-&gt;next = head;<br>            <span class="hljs-comment">// 移动指针到下一个子链表的开头</span><br>            pre = tail;<br>            head = next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 翻转一个头结点为head，尾结点为tail的子链表</span><br>    <span class="hljs-comment">// 返回翻转后的子链表的头结点和尾结点</span><br>    <span class="hljs-function">pair&lt;ListNode*, ListNode*&gt; <span class="hljs-title">reverseKList</span><span class="hljs-params">(ListNode *head, ListNode *tail)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *pre = tail-&gt;next;<br><br>        ListNode *p = head;<br>        <span class="hljs-keyword">while</span> (pre != tail) &#123;<br>            ListNode* next = p-&gt;next;<br>            p-&gt;next = pre;<br>            pre = p;<br>            p = next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;pre, head&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们每翻转完一个Group的子链表，将子链表的尾结点作为<code>pre</code>记录下来，这样当翻转完下一个子链表的时候就可以将翻转后的子链表接回去。</p><p>那第一个Group的子链表没有<code>pre</code>怎么办呢？难道要特殊处理吗？</p><p>我们这里用到了一个tricky的方法，在整个链表的头结点前加一个dummy node指向头结点，这的<code>pre</code>的初始值就是dummy，不需要特殊处理。这个dummy node还有一个好处就是当最后返回整个翻转后的链表的头结点的时候，<code>dummy-&gt;next</code>就正好是我们要找的头结点！一举两得！</p><img src="../imgs/image-20250228154706185-1740820376666-4.png" style="zoom:67%;" /><p>这样实现我们只需要构造常数个变量，<code>pre</code>,<code>head</code>,<code>tail</code>指针都会跟着链表的遍历向后变化。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>从实现的思路上来看，我觉得递归法比迭代法更简洁直观，也更容易写对（不用dummy node这种trick）。但是从内存消耗上来说，迭代法只需要创建常量个变量，而递归法需要消耗栈空间。</p><h2 id="leetcode-15-三数之和medium"><a class="markdownIt-Anchor" href="#leetcode-15-三数之和medium"></a> <a href="https://leetcode.cn/problems/3sum">Leetcode 15. 三数之和(Medium)</a></h2><blockquote><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h3 id="两数之和"><a class="markdownIt-Anchor" href="#两数之和"></a> 两数之和</h3><p>这题是两数之和问题的扩展，因此我先做了两数之和问题：</p><blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p></blockquote><p>这题就很简单，因为题目前提是只会存在一个有效答案，因此不需要担心重复问题。只需要用一个哈希表存储每个元素值和其对应的index。这样就可以以O(1)的时间复杂度找到对应值的index。因此总体的时间复杂度就是遍历一遍<code>nums</code>的<code>O(N)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            hashmap.<span class="hljs-built_in">insert</span>(&#123;nums[i], i&#125;);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; index;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> range = hashmap.<span class="hljs-built_in">equal_range</span>(target - nums[i]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = range.first; it != range.second; it++)<br>                <span class="hljs-comment">// 找到第一个不是当前i的index</span><br>                <span class="hljs-keyword">if</span> (it-&gt;second != i)<br>                &#123;<br>                    index.<span class="hljs-built_in">push_back</span>(i);<br>                    index.<span class="hljs-built_in">push_back</span>(it-&gt;second);<br>                    <span class="hljs-keyword">return</span> index;<br>                &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然而此题三数之和问题如果沿用哈希表，先解决两数之和问题，再加上第三个数，就会得到大量的重复的三元组，还要用哈希表做去重操作，非常消耗时间和空间。因此需要更换思路。</p><h3 id="三数之和排序双指针"><a class="markdownIt-Anchor" href="#三数之和排序双指针"></a> 三数之和：排序+双指针</h3><p>三数之和这道题可以用双指针精妙地将原本三层遍历<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的时间复杂度降到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​，具体的证明过程非常建议去看一下leetcode官方题解，讲得非常好！在这里我尝试简单说明一下：</p><p>首先我们要解决的是重复性问题，怎么才能保证不会得到重复的三元组？</p><p>我们仍需要使用三重循环，第一重大循环获取第一个数，第二、三重循环获取第二、三个数，我们只需要规定好每重循环枚举到的元素大小顺序就可以了。</p><p>具体来说，我们规定三重遍历中第二重循环枚举到的元素比第一重循环枚举到的元素大，第三重循环枚举到的元素比第二重循环枚举到的元素大，这样我们获得的三元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b, c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>的大小顺序一定是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mo>=</mo><mi>b</mi><mo>&lt;</mo><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a &lt;= b &lt;= c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>。要实现这一点，我们就需要先对数组从小到大排序。同时，对数组从小到大排序后，我们每层循环时，就可以跳过相邻的重复元素。</p><p>解决了重复性问题，接下来就是怎么才能将原本的三重循环降到只需要遍历两次数组呢？</p><p>可以这样思考，一旦固定了第二个数，那么第三个数就唯一确定了。并且由于我们是从左到右（从小到大）遍历第二个数，那么我们可以同时从右到左遍历第三个数。一旦第三个数找到了，他右边的数就再也不会用到了（因为我们接下来遍历到的第二个数只会更大，所以以后只需要继续遍历这第三个数左边的数）。</p><p>到这里解法就很清晰了，要用左右双指针分别指向遍历到的第二个数和第三个数。左指针只需要向右遍历，右指针只需要向左遍历，因此第二、三重循环加起来只需要遍历一次数组。再加上第一层大循环，总的时间复杂度就变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        // 将nums数组从小到大排序<br>        nums.sort(nums.begin(), nums.end());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = 0; i &lt; nums.size(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            // 定义双指针<br>            <span class="hljs-type">int</span> l = i + 1;<br>            <span class="hljs-type">int</span> r = num.size() - 1;<br>            <span class="hljs-type">int</span> target = -nums[i];<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                // 如果<br>                // 1. 当前左指针指向的数与前一个数相同；<br>                // 2. 或者左右指针指向的数相加小于target(说明再向左移动右指针也不可能找到等于target的和了)；<br>                // 则向右移动左指针，右指针不动<br>                <span class="hljs-keyword">if</span> ((l != i + 1 &amp;&amp; nums[l] == nums[l - 1]) || nums[l] + nums[r] &lt; target) &#123;<br>                    l++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[l] + nums[r] == target) &#123;<br>                    result.push_back(&#123;nums[i], nums[l], nums[r]&#125;);<br>                    l++;<br>                    r--;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                // 到这一步，说明nums[l] + nums[r] &gt; target，那就要向左移动右指针, 左指针不动<br>                r--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250301171414009.png" style="zoom:67%;" /><h1 id="day431"><a class="markdownIt-Anchor" href="#day431"></a> Day4(3.1)</h1><h2 id="leetcode-53-最大子数组和medium"><a class="markdownIt-Anchor" href="#leetcode-53-最大子数组和medium"></a> <a href="https://leetcode.cn/problems/maximum-subarray">Leetcode 53. 最大子数组和(Medium)</a></h2><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p></blockquote><h3 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h3><p>这题是非常经典可以用动态规划算法来解决的。求解一个数组的最大子数组问题，可以分解为求解以每个位置结尾的最大子数组和，然后取最大值。</p><p>用数学语言表述就是：我们用<code>f(i)</code>代表以第 i 个数结尾的「连续子数组的最大和」，我们要求解的最大子数组就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow></msub><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">max_{0≤i≤n−1}{f(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">n</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></span></p><p>那么我们如何求解每个位置的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>呢？这里就是动态规划的核心解决的问题：<strong>子问题重叠</strong>。每个位置的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，都与前一个位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>有关。当我们在寻找以<code>nums[i]</code>为结尾的最大子数组时，可以比较<code>f(i - 1) + nums[i]</code>大，还是<code>nums[i]</code>大，来决定是将<code>nums[i]</code>加入到前一个元素为结尾的最大子数组中，还是单独新成立一个子数组。即，</p><p><code>f(i) = max(f(i-1) + nums[i], nums[i])</code></p><p>这就是本题动态规划的<strong>状态转移方程</strong>建立的递推关系。</p><p>在空间利用上，我们只需要一个<code>max_fi</code>存储全局的最大子数组之和，一个<code>pre_fi</code>来存储前一个位置的状态（最大子数组之和）。因为计算当前位置的状态只需要用到前一个位置的状态。因此空间复杂度是<code>O(1)</code>。同时因为只需要遍历一遍数组，时间复杂度是<code>O(N)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 动态规划</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> max_fi = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-type">int</span> pre_fi = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> fi = <span class="hljs-built_in">max</span>(nums[i], pre_fi + nums[i])<br>                <span class="hljs-keyword">if</span> (fi &gt; max_fi) &#123;<br>                    max_fi = fi;<br>                &#125;<br>            pre_fi = fi;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_fi;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250303003651920.png" alt="" style="zoom:67%;" /><h2 id="leetcode-补充题4-手撕快速排序medium"><a class="markdownIt-Anchor" href="#leetcode-补充题4-手撕快速排序medium"></a> <a href="https://leetcode.cn/problems/sort-an-array">Leetcode 补充题4. 手撕快速排序(Medium)</a></h2><blockquote><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p>你必须在 <strong>不使用任何内置函数</strong> 的情况下解决问题，时间复杂度为 <code>O(nlog(n))</code>，并且空间复杂度尽可能小。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">5,2,3,1</span>]<br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,1,1,2,0,0]</span><br>输出：<span class="hljs-string">[0,0,1,1,2,5]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li><li><code>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></li></ul></blockquote><p>时间复杂度为 O(nlog(n))的排序数组方式有很多种，但CodeTop这题指定我们手撕快速排序。快速排序是非常重要经常考察的一种排序方式。在Day2中我刚刚手撕过快速排序的变型快速选择，今天借着这道题就来熟练一下手撕快速排序！</p><h3 id="第一版随机快排递归"><a class="markdownIt-Anchor" href="#第一版随机快排递归"></a> 第一版：随机快排+递归</h3><p>这基本就是常规的快排写法，唯一的优化就是随机选取pivot。这题的测试集有一个顺序排序好的数组，如果不随机选pivot时间复杂度会变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，过不了test</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 随机快排 + 递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 初始化随机数种子</span><br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br>        <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (begin &gt;= end)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Randomly select the pivot</span><br>        <span class="hljs-type">int</span> pivot_index = begin + <span class="hljs-built_in">rand</span>() % (end - begin + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">swap</span>(nums[pivot_index], nums[end]);<br><br>        pivot_index = <span class="hljs-built_in">partition</span>(nums, begin, end);<br><br>        <span class="hljs-built_in">quickSort</span>(nums, begin, pivot_index - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(nums, pivot_index + <span class="hljs-number">1</span>, end);<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Return the index of the pivot after partitioning</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[end];<br>        <span class="hljs-comment">// i指向小于pivot的区域的最后一个元素</span><br>        <span class="hljs-type">int</span> i = begin - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = begin; j &lt; end; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; pivot)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[++i], nums[j]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(nums[i + <span class="hljs-number">1</span>], nums[end]);<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这也是leetcode官方题解的写法。然而实测速度非常感人。原因是测试集里那个全是相同数的数组。二路分区（分为小于pivot的部分和大于pivot的部分）的策略也会导致相同的数都归到pivot同一侧，时间复杂度变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><img src="../imgs/image-20250302230928277-1740932494020-1.png" alt="" style="zoom:67%;" /><p>那么这题就不能用快排来写吗？不！我还要优化！</p><h3 id="第二版三路随机快排尾递归优化"><a class="markdownIt-Anchor" href="#第二版三路随机快排尾递归优化"></a> 第二版：三路随机快排+尾递归优化</h3><p>为了能handle那个逆天的全是相同数字的数组，我决定采用<strong>三路分区</strong>来完成partition。也就是说，将数组分为小于pivot，等于pivot，和大于pivot三个部分。这样partition过后只需要对小于pivot的部分和大于pivot的部分进行快排就行了。</p><p>第二个优化的点就是我将<code>quickSort</code>中连续的两个递归转化成了先递归pivot一侧的元素，然后迭代进行第二次递归pivot另一侧的元素，应该能够减少一点栈空间的消耗。虽然实测效果不明显。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 三路随机快排+尾递归优化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 初始化随机数种子</span><br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br>        <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span> (begin &lt; end)<br>        &#123;<br>            <span class="hljs-comment">// Randomly select the pivot</span><br>            <span class="hljs-type">int</span> pivot_index = begin + <span class="hljs-built_in">rand</span>() % (end - begin + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">swap</span>(nums[pivot_index], nums[end]);<br><br>            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pivot_range = <span class="hljs-built_in">threeWayPartition</span>(nums, begin, end);<br><br>            <span class="hljs-comment">// 先处理较小的分区，迭代处理较大的分区</span><br>            <span class="hljs-keyword">if</span> (pivot_range.first - begin &lt; end - pivot_range.second)<br>            &#123;<br>                <span class="hljs-built_in">quickSort</span>(nums, begin, pivot_range.first - <span class="hljs-number">1</span>);<br>                begin = pivot_range.second + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">quickSort</span>(nums, pivot_range.second + <span class="hljs-number">1</span>, end);<br>                end = pivot_range.first - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 三路分区</span><br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">threeWayPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[end];<br>        <span class="hljs-type">int</span> lt = begin;<br>        <span class="hljs-type">int</span> gt = end;<br>        <span class="hljs-type">int</span> i = begin;<br><br>        <span class="hljs-keyword">while</span> (i &lt;= gt)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; pivot)<br>                <span class="hljs-built_in">swap</span>(nums[i++], nums[lt++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; pivot)<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[gt--]);<br>            <span class="hljs-keyword">else</span><br>                i++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;lt, gt&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>不多说，效果见图，神中神！ 谁说这题不能用快排写？</p><img src="../imgs/image-20250302231029479-1740932494020-2.png" alt="" style="zoom:67%;" /><h1 id="day533"><a class="markdownIt-Anchor" href="#day533"></a> Day5(3.3)</h1><h2 id="leetcode-21-合并两个有序链表easy"><a class="markdownIt-Anchor" href="#leetcode-21-合并两个有序链表easy"></a> <a href="https://leetcode.cn/problems/merge-two-sorted-lists">Leetcode 21. 合并两个有序链表(Easy)</a></h2><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/merge_ex1-1740997005127-1.jpg" alt="img" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul></blockquote><h3 id="迭代-2"><a class="markdownIt-Anchor" href="#迭代-2"></a> 迭代</h3><p>这题我想到的解法是用迭代法，用一个指针p来指向合并的链表末尾，用两个指针p1和p2分别指向当前需要比较的两个list的元素。我还在合并的链表的头结点前面加了一个dummy node，方便最后返回合并链表的头结点<code>dummy-&gt;next</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 迭代法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode *list1, ListNode *list2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* p1 = list1;<br>        ListNode* p2 = list2;<br>        ListNode* p = dummy;<br><br>        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">NULL</span> &amp;&amp; p2 != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;<br>                p-&gt;next = p1;<br>                p1 = p1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p-&gt;next = p2;<br>                p2 = p2-&gt;next;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!p2) p-&gt;next = p1;<br>        <span class="hljs-keyword">if</span> (!p1) p-&gt;next = p2;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="递归-2"><a class="markdownIt-Anchor" href="#递归-2"></a> 递归</h3><p>递归法其实感觉才是yyds，因为思路很简洁清晰，很容易写对。</p><p>两个链表的merge操作用递归定义其实就是：</p><p><img src="../imgs/image-20250303144645759-1740997005128-2.png" alt="摘自Leetcode官方题解" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode *list1, ListNode *list2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!list1) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (!list2) <span class="hljs-keyword">return</span> list1;<br><br>        <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>            list1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1-&gt;next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        <br>        list2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1, list2-&gt;next);<br>        <span class="hljs-keyword">return</span> list2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3><p>迭代和递归法时间复杂度都是O(N + M)。</p><p>迭代法空间复杂度是O(1)，只需要维护常数个变量；递归法空间复杂度是O(N+M)，因为递归调用需要消耗栈空间，递归调用深度是O(N + M)。</p><h2 id="leetcode-5-最长回文子串medium"><a class="markdownIt-Anchor" href="#leetcode-5-最长回文子串medium"></a> <a href="https://leetcode.cn/problems/longest-palindromic-substring">Leetcode 5. 最长回文子串(Medium)</a></h2><blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul></blockquote><h3 id="中心扩展-双指针"><a class="markdownIt-Anchor" href="#中心扩展-双指针"></a> 中心扩展 + 双指针</h3><p>这题我自己的解法是运用双指针来完成中心扩展。可以这样想：回文字符串，是从最中心的1个字符或2个（相等）字符向外扩展的。因此当我们每遍历1个字符，或2个相邻的相同字符，就分别向左向右扩展1个字符（用左右双指针），查看这两个字符是否相等，如果相等那我们就得到了新的更长的字符串（接下来就记录下来当前的子串，然后继续向左向右扩展），否则就可以返回我们上次记录下来的子串。这个返回的子串就是以我们遍历到的那1个字符或2个（相等）字符为回文中心的最长子串。</p><p>这个算法的时间复杂度是多少呢？最外层是遍历(N次)字符寻找回文中心，第二层是根据回文中心向外扩展。要注意的是回文中心有长度为1和长度为2两种情况，因此第二层实际上是两次循环。总时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度是O(1)，只需要一个全局的<code>longest</code>来记录当前遍历过得回文中心里最长的子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; longest;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= i + <span class="hljs-number">1</span>; ++j) &#123;<br>                    <span class="hljs-type">int</span> l = i;<br>                    <span class="hljs-type">int</span> r = j;<br>                    <span class="hljs-keyword">if</span> (r &gt;= s.<span class="hljs-built_in">size</span>() || s[l] != s[j]) <span class="hljs-keyword">break</span>;<br>                    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pre = &#123;l, r&#125;;<br>                    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt;= s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (s[l] != s[r]) <span class="hljs-keyword">break</span>;<br>                        pre = &#123;l, r&#125;;<br>                        l--;<br>                        r++;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (pre.second - pre.first &gt; longest.second - longest.first) &#123;<br>                        longest = pre;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(longest.first, longest.second - longest.first + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250303172305424-1740997005128-3.png" style="zoom:67%;" /><h3 id="动态规划-2"><a class="markdownIt-Anchor" href="#动态规划-2"></a> 动态规划</h3><p>上面中心扩展的方法效果已经够好了，为什么还要用动态规划写一遍呢？因为动态规划的解法具有更强的普适性。</p><p>为什么这题可以用动态规划求解？可以这样思考：我们要判定一个子串是否是回文子串，与这个子串去掉最左右两个字符的子串是否是回文数列有关。P(i, j)为true表示以下标i为开头，j为结尾的子串是回文子串。可以写出动态规划的<strong>状态转移方程</strong>：</p><p>$ P(i,j)=P(i+1,j−1)∧(S_i==S_j) $</p><p>因此可以用一个二维数组表示dp，其中数组的两个下标分别代表i, j，数组的值就是bool值表示当前子串是否是回文子串。数组的初始值先都设置为false，除了i = j的数组元素设置为true。</p><p>注意在状态转移方程中，我们是从<strong>长度较短的字符串向长度较长的字符串进行转移</strong>的，因此循环的顺序是从短字符到长字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 动态规划 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>            vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<br>            <span class="hljs-comment">// 初始化dp数组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                dp[i][i] = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 从短字符开始循环更新dp数组，向长字符转移</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> L = <span class="hljs-number">2</span>; L &lt;= n; ++L) &#123;<br>                <span class="hljs-comment">// 先固定左指针，就能根据长度唯一确定右指针</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; n; ++l) &#123;<br>                    <span class="hljs-type">int</span> r = l + L - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (r &gt;= n) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (s[l] != s[r]) <span class="hljs-keyword">continue</span>;<br><br>                    <span class="hljs-comment">// 运行到这里，说明s[l] = s[r]，更新dp数组</span><br>                    <span class="hljs-keyword">if</span> (r - l &lt; <span class="hljs-number">3</span>) &#123;<br>                        dp[l][r] = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[l][r] = dp[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>];<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (dp[l][r] &amp;&amp; L &gt; maxLen) &#123;<br>                        begin = l;<br>                        maxLen = L;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(begin, maxLen);<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>动态规划的总时间复杂度还是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为判断子串是否是回文子串可以根据转移前的状态来判断，时间复杂度是<code>O(1)</code></p><p>但是空间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为需要构建二维dp数组来保存所有子串的状态（是否是回文子串）</p><p>这里再总结一下动态规划的解题步骤：</p><ol><li>确定dp数组及下标的含义（有哪些变量？状态是什么？）</li><li>确定状态转移方程/递推公式（如何根据前面已得知的状态推导出当前要求解的状态）</li><li>初始化dp数组（包括边界条件）</li><li>确定遍历顺序（已知的状态-&gt;未知的状态）</li></ol><h1 id="day634"><a class="markdownIt-Anchor" href="#day634"></a> Day6(3.4)</h1><h2 id="leetcode-102-二叉树的层序遍历medium"><a class="markdownIt-Anchor" href="#leetcode-102-二叉树的层序遍历medium"></a> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal">Leetcode 102. 二叉树的层序遍历(Medium)</a></h2><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/tree1-1741019452271-54-1741022849649-1.jpg" alt="img" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h3><p>二叉树的层序遍历，就是经典的BFS(深度优先搜索)算法，用一个queue来完成。每遍历一层，将每个节点的左右孩子push进queue，然后pop当前节点。每层遍历完后，正好这层的所有节点都pop出去了，下一层的所有节点都在queue中，通过<code>queue.size()</code>就可以知道下一层的节点个数，以此确定下层的循环遍历次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>            queue&lt;TreeNode *&gt; queue;<br>            <span class="hljs-keyword">if</span> (root) queue.<span class="hljs-built_in">push</span>(root);<br><br>            <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><br>                <span class="hljs-type">int</span> n = queue.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                    TreeNode* cur = queue.<span class="hljs-built_in">front</span>();<br>                    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                    <span class="hljs-keyword">if</span> (cur-&gt;left) queue.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    <span class="hljs-keyword">if</span> (cur-&gt;right) queue.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    queue.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <br>                result.<span class="hljs-built_in">push_back</span>(vec);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h3><p>每个节点进队出队各一次，时间复杂度是O(N)；</p><p>队列中的元素不超过N个，空间复杂度是O(N)。</p><img src="../imgs/image-20250304010913490-1741022849650-2.png" alt="" style="zoom: 67%;" /><h2 id="leetcode-1-两数之和easy"><a class="markdownIt-Anchor" href="#leetcode-1-两数之和easy"></a> <a href="https://leetcode.cn/problems/two-sum">Leetcode 1. 两数之和(Easy)</a></h2><blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p></blockquote><p>这题在Day3做三数之和问题的时候已经提前做过了，这里就当再复习一遍吧。</p><p>题目前提是只会存在一个有效答案，因此不需要担心重复问题。只需要用一个哈希表存储每个元素值和其对应的index。这样就可以以O(1)的时间复杂度找到对应值的index。因此总体的时间复杂度就是遍历一遍<code>nums</code>的<code>O(N)</code>，空间复杂度也是<code>O(N)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            hashmap.<span class="hljs-built_in">insert</span>(&#123;nums[i], i&#125;);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; index;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> range = hashmap.<span class="hljs-built_in">equal_range</span>(target - nums[i]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = range.first; it != range.second; it++)<br>                <span class="hljs-comment">// 找到第一个不是当前i的index</span><br>                <span class="hljs-keyword">if</span> (it-&gt;second != i)<br>                &#123;<br>                    index.<span class="hljs-built_in">push_back</span>(i);<br>                    index.<span class="hljs-built_in">push_back</span>(it-&gt;second);<br>                    <span class="hljs-keyword">return</span> index;<br>                &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="day735"><a class="markdownIt-Anchor" href="#day735"></a> Day7(3.5)</h1><h2 id="leetcode-33-搜索旋转排序数组medium"><a class="markdownIt-Anchor" href="#leetcode-33-搜索旋转排序数组medium"></a> <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array">Leetcode 33. 搜索旋转排序数组(Medium)</a></h2><blockquote><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul></blockquote><h3 id="二分查找变型"><a class="markdownIt-Anchor" href="#二分查找变型"></a> 二分查找（变型）</h3><p>这题就是在一个（类似）排序好的数组里找某个值的位置，显然是用二分法来查找。</p><p>但是这个数组并不是完全排序好的，而是<strong>由两段排序好的子数组拼接而成</strong>，那么我们自然思路就是先找到拼接的分界点，然后根据target的大小选择其中一段子数组来进行二分查找。</p><p>我们可以注意到第一段子数组的第一个元素和第二段子个数组的最后一个元素在旋转前的数组中是相邻的两个数。我们可以用类似于二分法的方式找到这两段子数组的拼接点，具体来说就是找到第二段子数组的第一个元素的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回数组最小的元素下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (nums[m] &gt;= nums[<span class="hljs-number">0</span>] &amp;&amp; nums[m + <span class="hljs-number">1</span>] &lt; nums[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">return</span> m + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nums[m] &gt;= nums[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, m + <span class="hljs-number">1</span>, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, l, m - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>找到这个拼接点的下标后，就可以根据target的大小选择其中一个子数组进行二分查找了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> min_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; nums[n - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-comment">// 找到数组中最小值的下标，也就是两个子数组的拼接点</span><br>        min_index = <span class="hljs-built_in">binary_search</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (target &lt;= nums[n - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, min_index, n - <span class="hljs-number">1</span>, target);<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, <span class="hljs-number">0</span>, min_index - <span class="hljs-number">1</span>, target);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nums[m] == target) &#123;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nums[m] &lt; target) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, m + <span class="hljs-number">1</span>, r, target); <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, l, m - <span class="hljs-number">1</span>, target);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a class="markdownIt-Anchor" href="#复杂度分析-3"></a> 复杂度分析</h3><p>这题就是做两次二分查找，第一次先找到拼接点的下标，第二次在其中一个子数组中做普通的二分查找。因此总时间复杂度是<code>O(logN)</code></p><p>我是用递归的方法做二分查找的，递归深度是<code>logN</code>，因此空间复杂度是<code>O(logN)</code></p><h2 id="leetcode-200-岛屿数量medium"><a class="markdownIt-Anchor" href="#leetcode-200-岛屿数量medium"></a> <a href="https://leetcode.cn/problems/number-of-islands">Leetcode 200. 岛屿数量(Medium)</a></h2><blockquote><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li></ul></blockquote><h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h3><p>用DFS解这题的思路很简单，每遍历到一个陆地（‘1’），就用DFS将其连接的陆地（‘1’）都变为‘0’。最后岛屿的数量就是遍历到的陆地数量。</p><p>我们先回顾一下dfs的代码框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">void dfs(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本节点所连接的其他节点) &#123;<br>        处理节点;<br>        dfs(图，选择的节点); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这题处理节点就是将当前节点变为0，然后dfs当前节点相邻的四个节点，dfs终止条件就是当前节点是0。不需要存放任何结果，因此回溯时也不用撤销处理结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// DFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> num_islands = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; rows; ++row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; cols; ++col) &#123;<br>                <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 新的岛屿，开始进行DFS</span><br>                ++num_islands;<br>                <span class="hljs-built_in">dfs</span>(grid, row, col);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num_islands;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br>        grid[row][col] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span> (row - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row - <span class="hljs-number">1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, row - <span class="hljs-number">1</span>, col);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (row + <span class="hljs-number">1</span> &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; grid[row + <span class="hljs-number">1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, row + <span class="hljs-number">1</span>, col)<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row][col - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, row, col - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col + <span class="hljs-number">1</span> &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[row][col + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, row, col + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度是<code>O(M * N)</code>，空间复杂度由DFS深度决定，深度最多是M * N（网格上全是陆地），因此空间复杂度是<code>O(M * N)</code></p><h3 id="bfs-2"><a class="markdownIt-Anchor" href="#bfs-2"></a> BFS</h3><p>岛屿问题也可以用BFS来解决，同样也是每遍历到一个岛屿，就用BFS将其连接的陆地（‘1’）都变为‘0’。只不过BFS是将遍历到的岛屿作为中心一圈一圈向外扩展，而DFS是找到一条路径搜到底，然后再回溯。</p><p>BFS需要用一个队列来存储当前遍历到的位置，要注意的是每次元素<strong>入队后应立即对其进行标记</strong>，避免重复访问。</p><p>回顾一下BFS的代码框架：（针对四方格地图）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 表示四个方向</span><br><span class="hljs-comment">// grid是地图，也就是一个二维数组</span><br><span class="hljs-comment">// visited标记访问过的节点，不要重复访问</span><br><span class="hljs-comment">// x, y表示开始搜索的节点下标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// 定义队列</span><br>    que.<span class="hljs-built_in">push</span>(&#123;x, y&#125;); <span class="hljs-comment">// 起始节点加入队列</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//只要加入队列，立刻标记为访问过的节点</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 从队头取元素</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second; <span class="hljs-comment">// 当前节点坐标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-comment">// 开始向当前节点的四个方向左右上下去遍历</span><br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 坐标越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty]) &#123;<br>                <span class="hljs-comment">// 如果节点没被访问过</span><br>                que.<span class="hljs-built_in">push</span>(&#123;nextx, nexty&#125;); <span class="hljs-comment">// 队列添加该节点为下一轮要遍历的节点</span><br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记，避免重复访问</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这题就很简单了，往模版里套就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// BFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> num_islands = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 4个方向</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; rows; ++row)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; cols; ++col)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 新的岛屿，开始进行BFS</span><br>                ++num_islands;<br>                queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>                q.<span class="hljs-built_in">push</span>(&#123;row, col&#125;);<br>                grid[row][col] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = q.<span class="hljs-built_in">front</span>();<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>                    &#123;<br>                        <span class="hljs-type">int</span> next_row = cur.first + dir[i][<span class="hljs-number">0</span>];<br>                        <span class="hljs-type">int</span> next_col = cur.second + dir[i][<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span> (next_row &gt;= <span class="hljs-number">0</span> &amp;&amp; next_row &lt; rows &amp;&amp; next_col &gt;= <span class="hljs-number">0</span> &amp;&amp; next_col &lt; cols &amp;&amp; grid[next_row][next_col] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                        &#123;<br>                            q.<span class="hljs-built_in">push</span>(&#123;next_row, next_col&#125;);<br>                            grid[next_row][next_col] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num_islands;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度是<code>O(M * N)</code>；空间复杂度是<code>O(min&#123;M, N&#125;)</code>，因为在最坏情况下，也就是网格中全是陆地（‘1’），队列中最多同时存在<code>min&#123;M, N&#125;</code>个元素。</p><h1 id="day836"><a class="markdownIt-Anchor" href="#day836"></a> Day8(3.6)</h1><h2 id="leetcode-46-全排列medium"><a class="markdownIt-Anchor" href="#leetcode-46-全排列medium"></a> <a href="https://leetcode.cn/problems/permutations">Leetcode 46. 全排列(Medium)</a></h2><blockquote><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul></blockquote><h3 id="递归-3"><a class="markdownIt-Anchor" href="#递归-3"></a> 递归</h3><p>我想到的解法是用递归。大循环遍历数组中的每个数作为我们选定的数，然后先获取除了我们选定的这个数以外的所有数的全排列，然后将我们选定的这个数作为所有我们得到的排列的最后一个数。这样我们就获得了以我们选定的数为结尾的全排列。因此当我们的大循环遍历完所有的数后，就得到了整体的全排列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_list</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">permute</span>(nums_list);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(list&lt;<span class="hljs-type">int</span>&gt; &amp;nums_list)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums_list.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, nums_list.<span class="hljs-built_in">front</span>()));<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums_list.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> front = nums_list.<span class="hljs-built_in">front</span>();<br>            nums_list.<span class="hljs-built_in">pop_front</span>();<br><br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sub_permute = <span class="hljs-built_in">permute</span>(nums_list);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : sub_permute) &#123;<br>                it.<span class="hljs-built_in">push_back</span>(front);<br>                result.<span class="hljs-built_in">push_back</span>(it);<br>            &#125;<br><br>            nums_list.<span class="hljs-built_in">push_back</span>(front);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为什么我要用个list来复制nums数组呢？因为我要获取我选定的数以外的数的全排列的时候，需要先将该数拿出去，获取完选下一个数之前再拿回来。用list方便从头尾部插入删除元素。</p><p>也可以用原先的vector，将选定的数先swap到vector的末尾，放回去的时候再swap回原来的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">1</span>, nums);<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(nums[n - <span class="hljs-number">1</span>], nums[i]);<br>            <span class="hljs-type">int</span> back = nums.<span class="hljs-built_in">back</span>();<br>            nums.<span class="hljs-built_in">pop_back</span>();<br><br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sub_permute = <span class="hljs-built_in">permute</span>(nums);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : sub_permute) &#123;<br>                it.<span class="hljs-built_in">push_back</span>(back);<br>                result.<span class="hljs-built_in">push_back</span>(it);<br>            &#125;<br><br>            nums.<span class="hljs-built_in">push_back</span>(back);<br>            <span class="hljs-built_in">swap</span>(nums[n - <span class="hljs-number">1</span>], nums[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h3><p>这题用回溯法的思路会稍微复杂一点，我们可以想象有 n 个排列成一行的空格。我们需要从左往右依此填入题目给定的 n个数，每个数只能使用一次。每次backtracking就是往<code>begin</code>位置填入一个数，[0, begin - 1]的位置已经填好数了，然后在<code>begin + 1</code>位置继续调用backtracking。当最后<code>begin = n</code>的时候说明整个一行都填完了，这就得到了其中一个排列，加入到最后的<code>result</code>里面。</p><p>事实上我们不需要单独创建一个数组来作为填入的一行，也不需要标记原数组中哪些元素已填入了这一行中，可以直接在原数组上进行操作。每次调用backtracking往<code>begin</code>位置填入时，将要填入的数与<code>begin</code>位置的数交换，然后再从<code>begin + 1</code>处填下一个数。这样的话，每次调用backtracking往<code>begin</code>位置填入时，原数组的[0, begin - 1]就是已经填入的数，寻找要填入的数时在[begin, n)位置寻找就可以了。</p><p>要注意，每次回溯后需要撤销处理结果，也就是将填入的数再与原先begin位置的数交换回来，然后继续寻找下一个要在<code>begin</code>位置填入的数。</p><p>回顾一下回溯法的代码框架：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">void backtracking(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">backtracking</span>(result, nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (begin == len) &#123;<br>            result.<span class="hljs-built_in">emplace_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = begin; i &lt; len; ++i) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[begin], nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(result, nums, begin + <span class="hljs-number">1</span>, len);<br>            <span class="hljs-built_in">swap</span>(nums[begin], nums[i]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-4"><a class="markdownIt-Anchor" href="#复杂度分析-4"></a> 复杂度分析</h3><p>上面递归和回溯算法的时间复杂度都是<code>O(N * N!)</code></p><p>回溯法的空间复杂度只与递归深度有关，递归深度为N，因此空间复杂度是O(N)；</p><p>递归法的递归深度也是N，但是每层递归都需要创建一个临时数组来存储子问题的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sub_permute = <span class="hljs-built_in">permute</span>(nums);<br></code></pre></td></tr></table></figure><p>这个临时数组有多大呢？当处理长度为n的数组时，<code>sub_permute</code>会存储(n-1)!个排列，每个排列有(n-1)个元素，因此这个临时数组占用空间为O((n-1) × (n-1)!) = O(n × (n-1)!) = O(n!)</p><p>因此这个递归法的空间复杂度是<code>O(n!)</code></p><h2 id="leetcode-121-买卖股票的最佳时机easy"><a class="markdownIt-Anchor" href="#leetcode-121-买卖股票的最佳时机easy"></a> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">Leetcode 121. 买卖股票的最佳时机(Easy)</a></h2><blockquote><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul></blockquote><h3 id="naive-solution"><a class="markdownIt-Anchor" href="#naive-solution"></a> Naive Solution</h3><p>外层大循环遍历股票买入日期，内层循环遍历股票卖出日期，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// O(N^2)时间复杂度</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>            <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-type">int</span> max_profit = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; prices.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (prices[j] - prices[i] &gt; max_profit) &#123;<br>                        max_profit = prices[j] - prices[i];<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (max_profit &gt; result) &#123;<br>                    result = max_profit;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><h3 id="动态规划-3"><a class="markdownIt-Anchor" href="#动态规划-3"></a> 动态规划</h3><p>这题是经典的动态规划例题，能够将Naive算法的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>时间复杂度降到<code>O(N)</code>。</p><p>动态规划的思想是当前位置的状态可以由前一个位置的状态通过递归算式推导出。可以这样想，如果我们将股票第<code>i</code>天卖出可以获取到的最大利润定义为<code>f(i)</code>，那么第<code>i + 1</code>天可以获取到的最大利润<code>f(i + 1)</code>就可以这样表示：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>+</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i + 1) = max(f(i) + prices[i] - prices[i - 1], 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>​</p><p>上面这就是本题动态规划的<strong>状态转移方程（递推公式）</strong></p><p>那么最后要求的买卖股票最大利润就是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><msub><mi mathvariant="normal">∣</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mtext>  </mtext><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f(i)|_{max} \ \ 0&lt;=i&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p><p>因此我们的实现只需要遍历一次数组，每遍历到一个日期，求以该日期为卖出日期能够获取到的最大利润。我用了一个<code>pre_max_profit</code>变量保存以该日期的前一个日期为卖出日期能获取到的最大利润，这样就能根据上面的递推公式求出当前的状态，并更新<code>pre_max_profit</code>，然后遍历到下一个日期。再用一个全局变量<code>max_profit</code>保存全局的最大利润。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>            <span class="hljs-type">int</span> max_profit = <span class="hljs-number">0</span>; <br><br>            <span class="hljs-type">int</span> pre_max_profit = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                pre_max_profit = <span class="hljs-built_in">max</span>(prices[i] - prices[i - <span class="hljs-number">1</span>] + pre_max_profit, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (pre_max_profit &gt; max_profit) &#123;<br>                    max_profit = pre_max_profit;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> max_profit;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>如前所述，用动态规划解本题的时间复杂度是<code>O(N)</code>，并且只需要创建常数个变量，空间复杂度是<code>O(1)</code>。</p><h1 id="day937"><a class="markdownIt-Anchor" href="#day937"></a> Day9(3.7)</h1><h2 id="leetcode-88-合并两个有序数组easy"><a class="markdownIt-Anchor" href="#leetcode-88-合并两个有序数组easy"></a> <a href="https://leetcode.cn/problems/merge-sorted-array">Leetcode 88. 合并两个有序数组(Easy)</a></h2><blockquote><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p>**注意：**最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,0,0,0]</span>, m = 3, nums2 = <span class="hljs-comment">[2,5,6]</span>, n = 3<br>输出：<span class="hljs-comment">[1,2,2,3,5,6]</span><br>解释：需要合并 <span class="hljs-comment">[1,2,3]</span> 和 <span class="hljs-comment">[2,5,6]</span> 。<br>合并结果是 <span class="hljs-comment">[1,2,2,3,5,6]</span> ，其中斜体加粗标注的为 nums1 中的元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1]</span>, m = 1, nums2 = <span class="hljs-comment">[]</span>, n = 0<br>输出：<span class="hljs-comment">[1]</span><br>解释：需要合并 <span class="hljs-comment">[1]</span> 和 <span class="hljs-comment">[]</span> 。<br>合并结果是 <span class="hljs-comment">[1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[0]</span>, m = 0, nums2 = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br>解释：需要合并的数组是 <span class="hljs-comment">[]</span> 和 <span class="hljs-comment">[1]</span> 。<br>合并结果是 <span class="hljs-comment">[1]</span> 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul><p>**进阶：**你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p></blockquote><h3 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h3><p>合并两个有序排列问题，就是用<strong>双指针</strong>来解决。</p><p>本题的特殊点在于需要将合并的数组存在<code>nums1</code>中，而不是单开一个空的数组向里面填。可以注意到<code>nums1</code>中后面n个数都是0，也就是待填入的数。因此我们可以从后往前遍历<code>nums1</code>和<code>nums2</code>，将较大的数从<code>nums1</code>的后面往前面写。</p><p>如果退出循环的时候是<code>nums2</code>遍历完了，说明<code>nums2</code>中的数已经都插入到<code>nums1</code>中了，可以直接退出；如果是<code>nums1</code>遍历完了，那说明<code>nums1</code>中的数都放到了正确的位置，接下来只要把<code>nums2</code>中剩余的数平移到<code>nums1</code>中就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums2, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> p1 = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p2 = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> p = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p1 &gt;= <span class="hljs-number">0</span> &amp;&amp; p2 &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;<br>                nums1[p] = nums2[p2];<br>                p2--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums1[p] = nums1[p1];<br>                p1--;<br>            &#125;<br>            p--;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p2; p2 &gt;= <span class="hljs-number">0</span>; --p2) &#123;<br>                nums1[p2] = nums2[p2];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>很显然，时间复杂度是<code>O(M + N)</code>，空间复杂度是<code>O(1)</code></p><h2 id="leetcode-20-有效的括号easy"><a class="markdownIt-Anchor" href="#leetcode-20-有效的括号easy"></a> <a href="https://leetcode.cn/problems/valid-parentheses">Leetcode 20. 有效的括号(Easy)</a></h2><blockquote><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><blockquote><p>**输入：**s = &quot;()&quot;</p><p>**输出：**true</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>**输入：**s = &quot;()[]{}&quot;</p><p>**输出：**true</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>**输入：**s = &quot;(]&quot;</p><p>**输出：**false</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>**输入：**s = &quot;([])&quot;</p><p>**输出：**true</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>'()[]&#123;&#125;'</code> 组成</li></ul></blockquote><h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3><p>本题的关键点在于**“左括号必须以正确的顺序闭合”**，也就是说&quot;( [ ) ]&quot;的顺序是错误的。</p><p>本题是运用<strong>栈</strong>的经典例题。当我们遇到左括号，就压入栈中；如果遇到右括号，检查当前栈顶是不是相对应的左括号，如果是那么将栈顶元素出栈，如果不是说明出错。</p><p>如果遍历到最后还没出错，并且栈最后为空，说明这是一个有效的字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            stack&lt;<span class="hljs-type">char</span>&gt; brackets;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                    brackets.<span class="hljs-built_in">push</span>(c);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (brackets.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> ((c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; brackets.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span>) || (c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; brackets.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>) || c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; brackets.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                        brackets.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> (brackets.<span class="hljs-built_in">empty</span>()) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>很显然，时间复杂度是<code>O(N)</code>；空间复杂度是<code>O(N)</code>，因为最坏情况下所有元素都是左括号都压入栈中。</p><h1 id="day1038"><a class="markdownIt-Anchor" href="#day1038"></a> Day10(3.8)</h1><h2 id="leetcode-103-二叉树的锯齿形层次遍历medium"><a class="markdownIt-Anchor" href="#leetcode-103-二叉树的锯齿形层次遍历medium"></a> <a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal">Leetcode 103. 二叉树的锯齿形层次遍历(Medium)</a></h2><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/tree1-1741417327569-3-1741450172381-1.jpg" alt="" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[20,9]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></blockquote><h3 id="栈-2"><a class="markdownIt-Anchor" href="#栈-2"></a> 栈</h3><p>都说层次遍历/BFS要用队列写，诶我偏用栈写一次（事实证明确实麻烦了）</p><p>如果用栈的话，每次都要为下一层单独开一个stack，遍历当前层的stack的时候，将下一层的元素压入下一层的stack中。然后在遍历完当前层的stack后，将下一层的stack赋值给当前层的stack，开始遍历下一层。</p><p>用栈的好处是：我们从栈中遍历的顺序就是锯齿形的顺序。每次从栈顶取到的元素直接放入结果的数组中就可以了，只要交替变换每层之间左右孩子被压入栈中的顺序就行了。而下面用队列的方法其实并不会改变普通层次遍历的遍历顺序，只是放入结果的位置改变了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-type">bool</span> left_first = <span class="hljs-literal">true</span>;<br><br>        stack&lt;TreeNode*&gt; cur_stack;<br>        stack&lt;TreeNode*&gt; next_stack;<br>        <span class="hljs-keyword">if</span> (root) cur_stack.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; cur_level;<br>        <span class="hljs-keyword">while</span> (!cur_stack.<span class="hljs-built_in">empty</span>() || !next_stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* cur = cur_stack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (left_first) &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) next_stack.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) next_stack.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) next_stack.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) next_stack.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            &#125;<br>            cur_stack.<span class="hljs-built_in">pop</span>();<br>            cur_level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur_stack.<span class="hljs-built_in">empty</span>()) &#123;<br>                cur_stack = next_stack;<br>                next_stack = std::<span class="hljs-built_in">move</span>(<span class="hljs-built_in">stack</span>&lt;TreeNode*&gt;());<br>                result.<span class="hljs-built_in">push_back</span>(cur_level);<br>                cur_level.<span class="hljs-built_in">clear</span>();<br>                left_first = !left_first;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="队列双端队列"><a class="markdownIt-Anchor" href="#队列双端队列"></a> 队列+双端队列</h3><p>当然，层次遍历还是用队列最方便。但是此题需要返回锯齿形的遍历顺序，那么我们就不能按每层中遍历到的元素顺序直接返回。具体来说，奇数层需要返回从右到左的元素顺序。但我们从队列中遍历的顺序是从左到右的呀，那怎么办呢？很简单，对奇数层来说，从左到右每从queue中遍历到一个元素，就将其插入到我们选定的容器的开头(front)，这样一层遍历完之后容器开头就是最右侧的元素了。而对于偶数层来说，从左到右每从queue中遍历到一个元素，就将其插入到我们选定的容器的末尾(back)。</p><p>那么问题就来了，什么容器可以既方便从开头插入元素，又方便从末尾插入元素？没错，就是双端队列(deque)！将每层的遍历结果都用deque来存储，然后赋值给vector加入结果中就可以了！</p><p>这个方法的好处就是我们不需要修改普通二叉树的层次遍历逻辑，只要修改存储遍历结果的方式就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode *root)<br>    &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-type">bool</span> left_first = <span class="hljs-literal">true</span>;<br><br>        queue&lt;TreeNode *&gt; que;<br>        <span class="hljs-keyword">if</span> (root)<br>            que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            deque&lt;<span class="hljs-type">int</span>&gt; deq;<br><br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>            &#123;<br>                TreeNode *cur = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (cur-&gt;left)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br><br>                <span class="hljs-keyword">if</span> (left_first) &#123;<br>                    deq.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    deq.<span class="hljs-built_in">push_front</span>(cur-&gt;val);<br>                &#125;<br>            &#125;<br><br>            result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;deq.<span class="hljs-built_in">begin</span>(), deq.<span class="hljs-built_in">end</span>()&#125;);<br>            left_first = !left_first;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-5"><a class="markdownIt-Anchor" href="#复杂度分析-5"></a> 复杂度分析</h3><p>BFS的时间复杂度就是<code>O(N)</code>，每个元素只需要遍历一次。空间复杂度是<code>O(N)</code>，因为无论是用栈还是队列，最坏情况下都需要存储N个元素，并且还需要一个容器来存储每层的结果。</p><h2 id="leetcode-236-二叉树的最近公共祖先medium"><a class="markdownIt-Anchor" href="#leetcode-236-二叉树的最近公共祖先medium"></a> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">Leetcode 236. 二叉树的最近公共祖先(Medium)</a></h2><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="../imgs/binarytree-1741450172382-2.png" alt="" /></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="../imgs/binarytree-1741450172382-2.png" alt="" /></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">5</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span> 。因为根据定义最近公共祖先节点可以为节点本身。<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[1,2]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul></blockquote><h3 id="递归-4"><a class="markdownIt-Anchor" href="#递归-4"></a> 递归</h3><p>这题都知道要用递归来写，但是要想清楚思路还是有些难度。只要能够想清楚递归的思路，代码写起来是很简单的！</p><p>我们可以这样想，如果我们要找的p和q分别在当前节点的左右子树，那么当前节点就是p和q的最近共同祖先。如果p和q都在其中一个（左或右）子树，那么这棵子树的根节点，（也就是root的左或右节点），就是离p和q更近的共同祖先。接下来就在这棵子树中寻找最近的共同祖先。</p><p>因此我们递归的返回条件是什么呢？<strong>只要我们找到p或q节点，就直接返回</strong>。因为我们每次递归调用的时候，root节点都是p和q的共同祖先。而一旦root节点是p或者q，那么很显然root就一定会是p和q的共同祖先。</p><p>那怎么判断当前递归调用时的root节点是否是p和q最近的共同祖先呢？结合递归的返回条件，我们可以分别递归调用左子树和右子树。如果在左子树中找到了p或q节点，又在右子树中找到了p或q节点，那么说明p和q节点分别在root的左右子树，显然root就是p和q的最近祖先。而如果只在其中一侧找到了p或q节点，说明p和q节点都在这棵子树上，那么就返回这一侧的递归结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-comment">// 只要找到p和q的其中一个，就返回</span><br>        <span class="hljs-keyword">if</span> (!root || root == p || root == q) <span class="hljs-keyword">return</span> root;<br><br>        TreeNode* l = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* r = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-keyword">if</span> (l &amp;&amp; r) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (l) <span class="hljs-keyword">return</span> l;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-6"><a class="markdownIt-Anchor" href="#复杂度分析-6"></a> 复杂度分析</h3><p>二叉树的每个节点都只会访问一次，时间复杂度是<code>O(N)</code>；</p><p>空间复杂度取决于递归调用的深度，而递归调用的深度取决于二叉树的高度。最坏情况下二叉树会退化成链表，高度为N。因此空间复杂度是<code>O(N)</code></p><h1 id="day1139"><a class="markdownIt-Anchor" href="#day1139"></a> Day11(3.9)</h1><h2 id="leetcode-141-环形链表easy"><a class="markdownIt-Anchor" href="#leetcode-141-环形链表easy"></a> <a href="https://leetcode.cn/problems/linked-list-cycle">Leetcode 141. 环形链表(Easy)</a></h2><blockquote><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/circularlinkedlist-1741513173102-1.png" alt="" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="../imgs/circularlinkedlist_test2-1741513173102-3.png" alt="" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="../imgs/circularlinkedlist_test3-1741513173102-2.png" alt="" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p>**进阶：**你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p></blockquote><h3 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h3><p>最容易想到的是用哈希表存储我们访问过的节点。每遍历到一个节点，先检查该节点是否在哈希表中，如果是说明是环形链表。遍历到最后都没找到重复遍历过的节点，说明不是环形链表。</p><p>代码很容易，这里就不写了。这个算法的空间复杂度是<code>O(N)</code>，有没有一种<code>O(1)</code>的空间复杂度的算法解此题呢？</p><h3 id="双指针快慢指针"><a class="markdownIt-Anchor" href="#双指针快慢指针"></a> 双指针（快慢指针）</h3><p>这题可以用双指针的一个trick：<strong>快慢指针</strong>。我们通常使用双指针都是两个指针每次移动一格，速度一样。这题在我们判断环形链表的时候，可以使用一慢一快两个指针：慢指针一次移动一格，快指针一次移动两格。那么如果链表不是环形的，快指针应该会一直在慢指针的前方。而如果是环形链表，那么两个指针走着走着一定会重合。可以想象龟兔赛跑的场景：乌龟和兔子在链表上移动，兔子跑得快，如果链表是环形的，那么就会套圈，与乌龟相遇。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            TreeNode* one_step = head;<br>            TreeNode* two_step = head-&gt;next;<br><br>            <span class="hljs-keyword">while</span> (one_step &amp;&amp; two_step) &#123;<br>                <span class="hljs-keyword">if</span> (one_step == two_step) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                one_step = one_step-&gt;next;<br>                <span class="hljs-keyword">if</span> (!two_step-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                two_step = two_step-&gt;next-&gt;next;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><h2 id="leetcode-92-反转链表-iimedium"><a class="markdownIt-Anchor" href="#leetcode-92-反转链表-iimedium"></a> <a href="https://leetcode.cn/problems/reverse-linked-list-ii">Leetcode 92. 反转链表 II(Medium)</a></h2><blockquote><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/rev2ex2-1741513173102-4.jpg" alt="" /></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span><br>输出：<span class="hljs-selector-attr">[5]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p></blockquote><p>此题难度并不大，就是翻转链表的变型。比普通的翻转一整个链表要多做的事情就是将[left, right]的子链表翻转后接回原本的链表，那就需要一个变量<code>pre_last</code>保存子链表的前一个节点，还需要一个<code>cur_first</code>指向翻转后的子链表的最后一个节点（这样就可以在翻转子链表的循环结束后将翻转后的子链表的最后一个节点的next指向原本子链表的后一个节点，也就是接回原链表）。翻转链表就是常规的套路：用一个<code>pre</code>节点保存遍历到的前一个节点，将当前节点指向<code>pre</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>            ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>            head = dummy;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; left; ++i) &#123;<br>                head = head-&gt;next;<br>            &#125;<br>            ListNode* pre_last = head; <span class="hljs-comment">// 将要翻转的第一个节点的前一个节点</span><br>            head = head-&gt;next;<br>            ListNode* cur_first = head; <span class="hljs-comment">// 将要翻转的第一个节点，也是翻转后的子链表的最后一个节点</span><br><br>            ListNode* pre = pre_last;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= right - left; ++i) &#123;<br>                ListNode* next = head-&gt;next;<br>                head-&gt;next = pre;<br>                pre = head;<br>                head = next;<br>            &#125;<br>            <span class="hljs-comment">// 循环结束后，pre指向翻转后的子链表的第一个节点，head指向翻转的子链表的后面一个节点</span><br>            pre_last-&gt;next = pre;<br>            cur_first-&gt;next = head;<br><br>            <span class="hljs-keyword">return</span> dummy-&gt;next;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>这样就可以保证只需要扫描一次就完成翻转，时间复杂度是<code>O(N)</code>；并且只需要常数个变量，空间复杂度是<code>O(1)</code>。</p><h1 id="day12310"><a class="markdownIt-Anchor" href="#day12310"></a> Day12(3.10)</h1><h2 id="leetcode-23-合并k个排序链表hard"><a class="markdownIt-Anchor" href="#leetcode-23-合并k个排序链表hard"></a> <a href="https://leetcode.cn/problems/merge-k-sorted-lists">Leetcode 23. 合并K个排序链表(Hard)</a></h2><blockquote><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br><span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul></blockquote><h3 id="优先级队列"><a class="markdownIt-Anchor" href="#优先级队列"></a> 优先级队列</h3><p>这题可以使用优先级队列进行合并。先将每个链表的头节点放入<strong>最小堆</strong>中，然后每次从堆顶取出一个节点（这个节点就是当前所有链表中的最小值，接入结果链表中），然后将这个节点所在链表的next节点放入堆中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *tail = dummy;<br><br>        <span class="hljs-comment">// 将每个链表的头节点放入堆中</span><br>        <span class="hljs-keyword">for</span> (ListNode* node : lists)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (node) minHeap.<span class="hljs-built_in">push</span>(node);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!minHeap.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            ListNode *smallest_node = minHeap.<span class="hljs-built_in">top</span>();<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (smallest_node-&gt;next) minHeap.<span class="hljs-built_in">push</span>(smallest_node-&gt;next);<br><br>            tail-&gt;next = smallest_node;<br>            tail = tail-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 自定义比较器</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CompareListNode</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode *a, ListNode *b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;   <span class="hljs-comment">// 最小堆中，大的元素放小的元素下方</span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 创建最小堆</span><br>    priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, CompareListNode&gt; minHeap;<br>&#125;;<br></code></pre></td></tr></table></figure><p>堆中的元素是每个链表当前需要比较的最小值，因此最多有K个，空间复杂度是<code>O(K)</code>；</p><p>堆的插入和删除操作时间复杂度都是<code>O(logK)</code>，K个链表中的每个元素都需要插入和删除各一次，因此总时间复杂度是<code>O(N * K * logK)</code></p><h3 id="分治合并"><a class="markdownIt-Anchor" href="#分治合并"></a> 分治合并</h3><p>这题也可以用分治的思想进行合并，可以这样思考递归的思路：合并K个链表，就是先将前K/2个链表合并，再将后K/2个链表合并，然后将合并后的这两个链表合并。递归的结束条件是当前要合并的链表数量只有一个，那么直接返回当前链表。</p><p>而合并两个链表的实现很简单，在Day5中已经做过了，就是用双指针。</p><p>如下图：第一轮两两合并，第二轮再将第一轮合并后的链表两两合并，直到最后两个链表合并得到最终的合并链表。</p><p><img src="../imgs/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image-1741598703839-1.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 分治合并</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (lists.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将第l个链表到第r个链表合并成一个链表</span><br>    <span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> lists[l];<br><br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(<span class="hljs-built_in">merge</span>(lists, l, mid), <span class="hljs-built_in">merge</span>(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* tail = dummy;<br><br>        ListNode* p1 = list1;<br>        ListNode* p2 = list2;<br>        <span class="hljs-keyword">while</span> (p1 &amp;&amp; p2) &#123;<br>            <span class="hljs-keyword">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;<br>                tail-&gt;next = p1;<br>                p1 = p1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = p2;<br>                p2 = p2-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!p1) tail-&gt;next = p2;<br>        <span class="hljs-keyword">if</span> (!p2) tail-&gt;next = p1;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>分治合并的递归深度是<code>log(K)</code>，空间复杂度就是消耗的栈空间<code>O(logK)</code>；</p><p>时间复杂度需要好好计算以下，我们考虑递归<strong>向上回升</strong>的过程。第一轮是两两合并链表，共合并<code>K/2</code>组链表，合并每组的时间复杂度是<code>O(2N)</code>；第二层共合并<code>K/4</code>组链表，合并每组的时间复杂度是<code>O(4N)</code>...，而递归的层数是<code>log(K)</code>，因此总时间复杂度是<code>O(N * K * logK)</code></p><h2 id="leetcode-54-螺旋矩阵medium"><a class="markdownIt-Anchor" href="#leetcode-54-螺旋矩阵medium"></a> <a href="https://leetcode.cn/problems/spiral-matrix">Leetcode 54. 螺旋矩阵(Medium)</a></h2><blockquote><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/spiral1-1741598703840-2.jpg" alt="" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="../imgs/spiral-1741598703840-3.jpg" alt="" /></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul></blockquote><h3 id="模拟"><a class="markdownIt-Anchor" href="#模拟"></a> 模拟</h3><p>本题就是模拟螺旋数组访问的路径，分别用4个变量维护四个方向的boundry：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> rows = matrix.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> cols = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br><span class="hljs-type">int</span> upper_boundry = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> lower_boundry = rows - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> left_boundry = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right_boundry = cols - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>用一个大循环表示路径访问了一圈，大循环中四个小循环分别表示四个路径访问方向。保证访问的路径始终落在boundry范围里面。每访问完一行或一列，更新boundry。如果更新后的boundry越界，说明整个数组访问结束，退出大循环。</p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;matrix)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-type">int</span> rows = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> upper_boundry = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lower_boundry = rows - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left_boundry = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right_boundry = cols - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (; j &lt;= right_boundry; ++j)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>            &#125;<br>            j = right_boundry;<br>            i = upper_boundry + <span class="hljs-number">1</span>;<br>            upper_boundry++;<br>            <span class="hljs-keyword">if</span> (upper_boundry &gt; lower_boundry) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (; i &lt;= lower_boundry; ++i)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>            &#125;<br>            i = lower_boundry;<br>            j = right_boundry - <span class="hljs-number">1</span>;<br>            right_boundry--;<br>            <span class="hljs-keyword">if</span> (right_boundry &lt; left_boundry) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (; j &gt;= left_boundry; --j)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>            &#125;<br>            j = left_boundry;<br>            i = lower_boundry - <span class="hljs-number">1</span>;<br>            lower_boundry--;<br>            <span class="hljs-keyword">if</span> (upper_boundry &gt; lower_boundry) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (; i &gt;= upper_boundry; --i)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>            &#125;<br>            i = upper_boundry;<br>            j = left_boundry + <span class="hljs-number">1</span>;<br>            left_boundry++;<br>            <span class="hljs-keyword">if</span> (right_boundry &lt; left_boundry) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>除了结果数组，只需要创建常数个变量维护boundry，空间复杂度是<code>O(1)</code>；</p><p>矩阵中每个元素被访问一次，时间复杂度是<code>O(mn)</code>，其中m和n分别是矩阵的行数和列数。</p><h1 id="day13311"><a class="markdownIt-Anchor" href="#day13311"></a> Day13(3.11)</h1><h2 id="leetcode-300-最长上升子序列medium"><a class="markdownIt-Anchor" href="#leetcode-300-最长上升子序列medium"></a> <a href="https://leetcode.cn/problems/longest-increasing-subsequence">Leetcode 300. 最长上升子序列(Medium)</a></h2><blockquote><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul></blockquote><h3 id="动态规划-4"><a class="markdownIt-Anchor" href="#动态规划-4"></a> 动态规划</h3><p>这题的关键难点在于搞清楚<code>dp</code>数组究竟应该存储什么状态。可以这样想：一个数组我们求解出的最长递增子序列一定有一个末尾元素（虽然是废话），因此我们可以求出以每个元素作为末尾元素的最长递增子序列的长度。最后看谁最长，就是整个数组的最长递增子序列长度。</p><p>我们用<code>dp</code>数组保存以每个元素作为末尾元素的最长递增子序列的长度，<code>dp[i]</code>表示以数组中第<code>i</code>个元素作为末尾元素的最长递增子序列长度。那怎么求<code>dp[i]</code>呢？根据动态规划的状态转移特性，我们求<code>dp[i]</code>的时候已经求得了<code>dp[0...i−1]</code>的值，因此状态方程可以写为：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mtext>，其中</mtext><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi><mtext>且</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[j]) + 1，其中0 &lt;= j &lt; i且nums[j] &lt; nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>​</p><p>也就是找在以 当前元素前面的元素 为末尾的最长递增子序列中能接上当前元素的子序列中最大的子序列。</p><p>最后的结果就是<code>dp</code>数组中的最大值。</p><p>可以看到，本题的动态规划求解当前状态时，不仅仅需要前一个位置的状态，而是要遍历前面所有位置的状态，因此必须要用<code>dp</code>数组来保存所有位置的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j] &gt; max &amp;&amp; nums[j] &lt; nums[i]) max = dp[j];<br>            &#125;<br>            dp[i] = max + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> max_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; max_length) max_length = dp[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_length;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>本题动态规划的空间复杂度是<code>O(N)</code>，因为需要一个一维的<code>dp</code>数组；</p><p>时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为求解每个位置的状态时，需要遍历前面所有位置的状态。</p><h2 id="leetcode-415-字符串相加easy"><a class="markdownIt-Anchor" href="#leetcode-415-字符串相加easy"></a> <a href="https://leetcode.cn/problems/add-strings">Leetcode 415. 字符串相加(Easy)</a></h2><blockquote><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;123&quot;</span><br>输出：<span class="hljs-string">&quot;134&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;456&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;77&quot;</span><br>输出：<span class="hljs-string">&quot;533&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-string">&quot;0&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num1.length, num2.length &lt;= 104</code></li><li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li><li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li></ul></blockquote><h3 id="模拟-2"><a class="markdownIt-Anchor" href="#模拟-2"></a> 模拟</h3><p>本题其实就是模拟<strong>竖式加法</strong>的过程。从两个字符串的最后一个数（整数的个位数）开始加起，如果进位设置<code>of</code>加到下一位中。这里我用了一个trick：向较短的字符串前面补上0，让两个字符串一样长，方便循环做加法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length1 = num1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> length2 = num2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> length = <span class="hljs-built_in">max</span>(length1, length2);<br><br>        <span class="hljs-type">int</span> zeros;<br>        <span class="hljs-keyword">if</span> (length1 &gt; length2) &#123;<br>            zeros = length1 - length2;<br>            num2 = <span class="hljs-built_in">string</span>(zeros, <span class="hljs-string">&#x27;0&#x27;</span>) + num2;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            zeros = length2 - length1;<br>            num1 = <span class="hljs-built_in">string</span>(zeros, <span class="hljs-string">&#x27;0&#x27;</span>) + num1;<br>        &#125;<br><br>        string result;<br>        <span class="hljs-type">int</span> of = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 是否有overflow</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">int</span> sum = (num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + (num2[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + of;<br>            <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">9</span>) &#123;<br>                sum -= <span class="hljs-number">10</span>;<br>                of = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                of = <span class="hljs-number">0</span>;<br>            &#125;<br>            result = (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;0&#x27;</span> + sum) + result;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (of) result = <span class="hljs-string">&#x27;1&#x27;</span> + result;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个算法的时间复杂度是<code>O(max&#123;len1, len2&#125;)</code>；</p><p>空间复杂度是<code>O(n)</code>，因为我通过向较短的字符串前面添加'0'字符使两个字符串长度相等，这会创建新的string对象，最坏情况下会需要<code>O(n)</code>的额外空间（当一个字符串远长于另一个时）。</p><h1 id="day14312"><a class="markdownIt-Anchor" href="#day14312"></a> Day14(3.12)</h1><h2 id="leetcode-160-相交链表easy"><a class="markdownIt-Anchor" href="#leetcode-160-相交链表easy"></a> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists">Leetcode 160. 相交链表(Easy)</a></h2><blockquote><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交：</p><p><img src="../imgs/160_statement-1741768368110-3.png" alt="" /></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/160_example_1_1-1741768368110-2.png" alt="" /></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br>— 请注意相交节点的值不为 <span class="hljs-number">1</span>，因为在链表 <span class="hljs-keyword">A</span> 和链表 B 之中值为 <span class="hljs-number">1</span> 的节点 (<span class="hljs-keyword">A</span> 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <span class="hljs-keyword">A</span> 和链表 B 中值为 <span class="hljs-number">8</span> 的节点 (<span class="hljs-keyword">A</span> 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="../imgs/160_example_2-1741768368110-1.png" alt="" /></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。  <br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="../imgs/160_example_3-1741768368110-4.png" alt="" /></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：No <span class="hljs-built_in">int</span>ersection<br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p>**进阶：**你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p></blockquote><h3 id="哈希集合"><a class="markdownIt-Anchor" href="#哈希集合"></a> 哈希集合</h3><p>用哈希集合解这题就很简单，先遍历一遍A链表，将遍历过的节点存在哈希集合里。再遍历B链表，每遍历到一个节点先检查是否在哈希集中，如果是则返回该节点。最后如果遍历完B链表了说明与A链表无相交。代码省略。</p><p>该算法的空间复杂度是<code>O(N)</code>，有没有<code>O(1)</code>空间复杂度的算法呢？答案就是双指针！</p><h3 id="双指针-2"><a class="markdownIt-Anchor" href="#双指针-2"></a> 双指针</h3><p>这题与其说是双指针的套路题，不如说是一道脑筋急转弯，因为就算告诉你这题用双指针你也不会做。</p><p>这题的关键点在于怎么让两个指针<code>pA</code>和<code>pB</code>同时走到第一个相交的节点？要知道A链表和B链表在他们相交前各自的长度是未知的。这里就是核心的trick了：我们让<code>pA</code>和<code>pB</code>以相同的速度先在各自的链表上同步走，然后<strong>让<code>pA</code>走完A链表后继续从B链表的开头开始走起，让<code>pB</code>走完B链表后继续从A链表的开头开始走起。</strong></p><p>想明白了吗？没想明白的话，建议自己画图模拟一下。这样<code>pA</code>和<code>pB</code>在走完自己的路，又走完对方走过的路后，一定会同时到达两个链表第一次相交的节点。而如果两个链表不相交，那<code>pA</code>和<code>pB</code>在走完自己和对方的路后会同时抵达终点<code>NULL</code>。</p><img src="../imgs/2b1d9a2937b3d27709359bda0a4c378-1741768368110-6.jpg" alt = "蓝色是pA的路线，红色是pB的路线" style="zoom: 40%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!headA || !headB)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        ListNode *pA = headA;<br>        ListNode *pB = headB;<br><br>        <span class="hljs-keyword">while</span> (pA || pB)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (pA == pB) <span class="hljs-keyword">return</span> pA;<br>        <br>            pA = (!pA) ? headB : pA-&gt;next;<br>            pB = (!pB) ? headA : pB-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>显然这个算法的时间复杂度是<code>O(M + N)</code>，空间复杂度是<code>O(1)</code></p><p>最后放一个leetcode评论区神评：</p><img src="../imgs/image-20250312152905663-1741768368110-7.png" style="zoom: 80%;" /><p>你悟了吗？</p><h2 id="leetcode-143-重排链表medium"><a class="markdownIt-Anchor" href="#leetcode-143-重排链表medium"></a> <a href="https://leetcode.cn/problems/reorder-list">Leetcode 143. 重排链表(Medium)</a></h2><blockquote><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-symbol">L1</span> → … → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-built_in">Ln</span><br></code></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-built_in">Ln</span> → <span class="hljs-symbol">L1</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-symbol">L2</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">2</span> → …<br></code></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/1626420311-PkUiGI-image-1741768368110-5.png" alt="" /></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">1,4,2,3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="../imgs/1626420320-YUiulT-image-1741768368110-8.png" alt="" /></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[1,5,2,4,3]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表的长度范围为 <code>[1, 5 * 104]</code></li><li><code>1 &lt;= node.val &lt;= 1000</code></li></ul></blockquote><h3 id="双端队列"><a class="markdownIt-Anchor" href="#双端队列"></a> 双端队列</h3><p>这题一看，先要从链表末尾拿一个元素，再从链表开头拿一个元素，……，而链表本身不支持随机访问。因此很容易想到可以用一个支持<strong>随机访问/快速访问和删除首尾元素</strong>的容器来装链表。Leetcode官方题解选的是前者，用<code>vector</code>。</p><p>我选择的是后者，用一个双端队列。先将链表装到双端队列里面。每次取节点要么取<code>deque</code>的最后一个元素，要么取第一个元素，每次取完将该元素从<code>deque</code>中删除，以上操作都是<code>O(1)</code>的时间复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span>;<br><br>        deque&lt;ListNode *&gt; list;<br><br>        ListNode *p = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (p)<br>        &#123;<br>            list.<span class="hljs-built_in">push_back</span>(p);<br>            p = p-&gt;next;<br>        &#125;<br><br>        p = head;<br>        <span class="hljs-type">bool</span> back = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!list.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (back)<br>            &#123;<br>                p-&gt;next = list.<span class="hljs-built_in">back</span>();<br>                list.<span class="hljs-built_in">pop_back</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p-&gt;next = list.<span class="hljs-built_in">front</span>();<br>                list.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            p = p-&gt;next;<br>            back = !back;<br>        &#125;<br><br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有一个容易忽略的点：要设置最后一个元素指向<code>NULL</code>。</p><p>显然，这个算法的时间复杂度是<code>O(N)</code>；空间复杂度也是<code>O(N)</code>。</p><h1 id="day15315"><a class="markdownIt-Anchor" href="#day15315"></a> Day15(3.15)</h1><h2 id="leetcode-56-合并区间medium"><a class="markdownIt-Anchor" href="#leetcode-56-合并区间medium"></a> <a href="https://leetcode.cn/problems/merge-intervals">Leetcode 56. 合并区间(Medium)</a></h2><blockquote><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul></blockquote><h3 id="第一版排序-直接在vector上修改"><a class="markdownIt-Anchor" href="#第一版排序-直接在vector上修改"></a> 第一版：排序 + 直接在vector上修改</h3><p>先将区间按左端点从小到大排序，然后从vector的开头开始合并，如果要跟下一个区间合并，则设置当前区间的右端点，然后将下一个区间删除。如果不合并，则将下一个区间设置为当前区间。</p><p>然而在vector的任意位置删除的开销很大，总时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因此我想到可以用方便在任意位置删除元素的容器来存储以及合并区间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Less</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Less</span>());<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; intervals.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &lt; intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;<br>                ++i;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(intervals[i][<span class="hljs-number">1</span>], intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            intervals.<span class="hljs-built_in">erase</span>(intervals.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> intervals;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="第二版排序-链表"><a class="markdownIt-Anchor" href="#第二版排序-链表"></a> 第二版：排序 + 链表</h3><p>什么容器方便在任意位置删除元素？链表！因此我决定先将区间放到链表中。然后同理还是先按左端点从小到大排序。从开头开始合并区间，如果要跟下一个区间合并，则设置当前区间的右端点，并删除下一个区间。如果不合并，则将下一个区间设置为当前区间。</p><p>注意点：<code>list</code>排序要用容器内部的<code>sort</code>函数，不能用<code>sort(list.begin(), list.end())</code>，因为<code>list</code>的迭代器不支持随机访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Less</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;intervals)<br>    &#123;<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">list</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br><br>        list.<span class="hljs-built_in">sort</span>(<span class="hljs-built_in">Less</span>());<br><br>        <span class="hljs-keyword">auto</span> it = list.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">auto</span> next_it = <span class="hljs-built_in">next</span>(it);<br>        <span class="hljs-keyword">while</span> (next_it != list.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((*it)[<span class="hljs-number">1</span>] &lt; (*next_it)[<span class="hljs-number">0</span>])<br>            &#123;<br>                ++it;<br>                ++next_it;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            (*it)[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>((*it)[<span class="hljs-number">1</span>], (*next_it)[<span class="hljs-number">1</span>]);<br>            next_it = list.<span class="hljs-built_in">erase</span>(next_it);<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(list.<span class="hljs-built_in">begin</span>(), list.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>链表的删除操作时间复杂度是<code>O(1)</code>，因此总时间复杂度就是排序链表的复杂度<code>O(NlogN)</code>；空间复杂度是<code>O(N)</code>。</p><h2 id="leetcode-42-接雨水hard"><a class="markdownIt-Anchor" href="#leetcode-42-接雨水hard"></a> <a href="https://leetcode.cn/problems/trapping-rain-water">Leetcode 42. 接雨水(Hard)</a></h2><blockquote><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="../imgs/rainwatertrap-1742049673383-1.png" alt="" /></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul></blockquote><h3 id="动态规划推荐"><a class="markdownIt-Anchor" href="#动态规划推荐"></a> 动态规划（推荐）</h3><p>接雨水的核心点：<strong>对于下标<code>i</code>处的位置，水能达到的最大高度等于下标<code>i</code>两边的最大高度的最小值。</strong></p><p>搞清楚这一点，那么其实我们要求的东西就变成了：对于每个下标<code>i</code>，其左边的最大高度和其右边的最大高度。这就很明显可以用动态规划求解了。</p><p>怎么求下标<code>i</code>的左边（包括下标<code>i</code>）的最大高度<code>leftMax[i]</code>呢？如果我们知道了下标<code>i - 1</code>的左边（包括下标<code>i - 1</code>）的最大高度<code>leftMax[i - 1]</code>，那么就很容易求出<code>leftMax[i]</code>了：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mtext>，其中</mtext><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">leftMax[i] = max(leftMax[i - 1], height[i])，其中leftMax[0] = height[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></p><p>那么同理，</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mtext>，其中</mtext><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">rightMax[i] = max(rightMax[i + 1], height[i])，其中rightMax[n - 1] = height[n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p>以上两个递推公式就是此题动态规划的状态转移方程。</p><p>因此从左向右遍历一遍<code>height</code>数组就可以求出<code>leftMax</code>数组；从右向左再遍历一遍<code>height</code>数组就可以求出<code>rightMax</code>数组。时间复杂度是<code>O(N)</code>。</p><p>最后求每个下标<code>i</code>处能接到的雨水数量就等于<code>min(leftMax(i), rightMax(i)) - height[i]</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftMax</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightMax</span><span class="hljs-params">(n)</span></span>;<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        rightMax[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            leftMax[i] = <span class="hljs-built_in">max</span>(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            rightMax[i] = <span class="hljs-built_in">max</span>(rightMax[i + <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> drip = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            drip += <span class="hljs-built_in">min</span>(leftMax[i], rightMax[i]) - height[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> drip;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>显然动态规划的解法时间复杂度是<code>O(N)</code>，空间复杂度也是<code>O(N)</code>。</p><h3 id="双指针-3"><a class="markdownIt-Anchor" href="#双指针-3"></a> 双指针</h3><p>还是这个核心思想：<strong>对于下标<code>i</code>处的位置，水能达到的最大高度等于下标<code>i</code>两边的最大高度的最小值。</strong></p><p>我们还是需要知道对于每个下标<code>i</code>处的位置，到底是其左边的最大高度大，还是其右边的最大高度大。如果是其左边的最大高度大，那我们需要知道其右边的最大高度是多少；反之如果是其右边的最大高度大，那我们需要知道其左边的最大高度是多少。</p><p>但我们可以对空间利用进行优化，不需要两个数组分别存储每个下标<code>i</code>处的左边最大高度和右边最大高度。</p><p>想象以下这个假设：对于一个下标<code>i</code>，如果我们知道了他的<code>leftMax</code>（左边的最大高度）一定比他的<code>rightMax</code>（右边的最大高度）的最小值还要小，那我们只要取<code>leftMax</code>来计算当前位置雨水的高度就行了，我们不需要知道下标<code>i</code>的<code>rightMax</code>具体是多少。反过来也一样，对于一个下标<code>i</code>，如果我们知道了他的<code>rightMax</code>（右边的最大高度）一定比他的<code>leftMax</code>（左边的最大高度）的最小值还要小，那我们只要取<code>rightMax</code>来计算当前位置雨水的高度就行了，我们不需要知道下标<code>i</code>的<code>leftMax</code>具体是多少。</p><p>为了应用以上假设，我们需要双指针<code>l</code>和<code>r</code>分别指向数组的开头和末尾下标，还需要两个变量<code>l_leftMax</code>和<code>r_rightMax</code>。注意！这两个变量与上面我说的下标<code>i</code>的<code>leftMax</code>（左边的最大高度）和<code>rightMax</code>（右边的最大高度）不同！<code>l_leftMax</code>应当理解为当前下标<code>l</code>的<code>leftMax</code>（左边的最大高度），<code>r_rightMax</code>应当理解为当前下标<code>r</code>的<code>rightMax</code>（右边的最大高度）。</p><p>然后我们就可以让<code>l</code>和<code>r</code>双指针向中间移动收敛了。最初双指针<code>l</code>和<code>r</code>分别指向数组的开头和末尾下标。当<code>l</code>或<code>r</code>每移动一格，就更新<code>l_leftMax</code>和<code>r_rightMax</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// l_leftMax是下标l（包括下标l）的左边最大高度；</span><br>l_leftMax = <span class="hljs-built_in">max</span>(l_leftMax, height[l]); <br><span class="hljs-comment">// r_rightMax是下标r（包括下标r）的右边最大高度；</span><br>r_rightMax = <span class="hljs-built_in">max</span>(r_rightMax, height[r]);<br></code></pre></td></tr></table></figure><p>这部分很简单，就是上面动态规划的思想。</p><p>然后就是关键点了：我们比较当前的<code>l_leftMax</code>和<code>r_rightMax</code>：</p><ol><li><p>如果<code>l_leftMax &lt; r_rightMax</code>，而显然<code>r_rightMax（下标r的rightMax) &lt;= 下标l的rightMax</code>，因此根据符号的传递性，<code>l_leftMax（下标l的leftMax） &lt; 下标l的rightMax</code>。</p><p>因此对于下标<code>l</code>来说，我们知道了其左边的最大高度更小，而这个值我们刚好知道，就是<code>l_leftMax</code>！这样就可以计算出下标<code>l</code>处的水滴数量 = <code>l_leftMax - height[l]</code>。加入结果中后，将<code>l</code>指针向右移动一格，等待计算下一格的水滴数量。</p></li><li><p>同理，如果<code>l_leftMax &gt;= r_rightMax</code>，而显然<code>下标r的leftMax &gt;= l_leftMax（下标l的leftMax）</code>，因此根据符号的传递性，<code>下标r的leftMax &gt;= r_rightMax（下标r的rightMax）</code>。</p><p>因此对于下标<code>r</code>来说，我们知道了其右边的最大高度更小，而这个值我们刚好知道，就是<code>r_rightMax</code>！这样就可以计算出下标<code>r</code>处的水滴数量 = <code>r_rightMax - height[r]</code>。加入结果中后，将<code>r</code>指针向左移动一格，等待计算下一格的水滴数量。</p></li></ol><p>思路好像挺复杂，但代码写起来很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;height)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> l_leftMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r_rightMax = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> drip = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-comment">// l_leftMax是下标l（包括下标l）的左边最大高度；</span><br>            l_leftMax = <span class="hljs-built_in">max</span>(l_leftMax, height[l]); <br>            <span class="hljs-comment">// r_rightMax是下标r（包括下标r）的右边最大高度；</span><br>            r_rightMax = <span class="hljs-built_in">max</span>(r_rightMax, height[r]);<br><br>            <span class="hljs-keyword">if</span> (l_leftMax &lt; r_rightMax) &#123;<br>                <span class="hljs-comment">// 下标l的rightMax &gt;= 下标r的rightMax = r_rightMax &gt; l_leftMax = 下标l的leftMax；</span><br>                drip += l_leftMax - height[l];<br>                l++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 下标r的rightMax = r_rightMax &lt;= l_leftMax = 下标l的leftMax &lt;= 下标r的leftMax；</span><br>                drip += r_rightMax - height[r];<br>                r--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> drip;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>显然双指针的解法时间复杂度是<code>O(N)</code>，空间复杂度是<code>O(1)</code>。</p><h3 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h3><p>与上面两种方法求每个下标<code>i</code>的左右最大高度不同，这题也可以用到单调递减栈来求解。什么是单调递减栈？就是从栈底到栈顶元素大小单调递减。</p><p>从左到右遍历数组<code>height</code>，每遍历到一个下标<code>i</code>，如果<code>height[i] &lt;= height[top]（top是栈顶下标）</code>，就将下标入栈；否则的话如果栈中至少有两个下标，我们就找到了一个可以接雨水的区域。该区域的宽度是<code>i - left - 1</code>，高度是<code>min(height[left], height[i]) - height[top]</code>。根据宽度和高度即可计算得到该区域能接到的雨水量。为了得到<code>left</code>，需要先将<code>top</code>出栈，在对<code>top</code>计算能接的雨水量之后，<code>left</code>变成新的<code>top</code>，重复上述操作，直到栈变空，或者<code>height[top]</code>大于等于当前遍历到的<code>height[i]</code>。然后将当前的下标<code>i</code>入栈，继续遍历后面的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单调栈</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;height)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br>        <span class="hljs-type">int</span> drip = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || height[i] &lt;= height[st.<span class="hljs-built_in">top</span>()])<br>            &#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前下标的高度大于栈顶下标的高度，如果栈中只有一个下标，替换他</span><br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            <span class="hljs-comment">// 到这一步，栈中至少有两个下标，并且当前下标的高度大于栈顶的高度；</span><br>            <span class="hljs-comment">// 意味着我们找到了一个可以接雨水的区域</span><br>            <span class="hljs-keyword">while</span> (height[i] &gt; height[st.<span class="hljs-built_in">top</span>()])<br>            &#123;<br>                <span class="hljs-type">int</span> top = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-comment">// 计算这个接雨水区域的宽度和高度</span><br>                <span class="hljs-type">int</span> w = i - left - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[i], height[left]) - height[top];<br>                drip += w * h;<br>            &#125;<br>            <span class="hljs-comment">// 到这里，当前下标的高度终于比栈顶高度小了（也可能栈空了）</span><br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> drip;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>显然这个算法的时间复杂度是<code>O(N)</code>，空间复杂度也是<code>O(N)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
      <category>CodeTop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeTop</tag>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simulator Lab</title>
    <link href="/2025/02/24/Simulator/"/>
    <url>/2025/02/24/Simulator/</url>
    
    <content type="html"><![CDATA[<h1 id="ics-lab5-y86-64-simulator"><a class="markdownIt-Anchor" href="#ics-lab5-y86-64-simulator"></a> ICS Lab5: Y86-64 Simulator</h1><p>在Lab5中，我们要实现一个Y86-64 Simulator来模拟执行y86二进制代码的硬件行为。</p><p><code>y86sim.c</code>程序读进一个y86 instruction文件，根据y86指令结构来parse二进制代码。分析并确定指令后，该程序修改y86处理器状态。</p><h2 id="skeleton-code"><a class="markdownIt-Anchor" href="#skeleton-code"></a> Skeleton Code</h2><p>开始coding之前先认真看一下skeleton code的结构：</p><p>关键是<code>y64sim_t</code>结构，用了4个变量分别表示y86处理器状态：PC, 寄存器，内存和CC，其中寄存器和内存各自用一块连续空间的数组表示，通过register specifer和内存地址作为数组index访问相应的寄存器和内存地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem</span> &#123;</span><br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">byte_t</span> *data;<br>&#125; <span class="hljs-type">mem_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">y64sim</span> &#123;</span><br>    <span class="hljs-type">long_t</span> pc;<br>    <span class="hljs-type">mem_t</span> *r;<br>    <span class="hljs-type">mem_t</span> *m;<br>    <span class="hljs-type">cc_t</span> cc;<br>&#125; <span class="hljs-type">y64sim_t</span>;<br></code></pre></td></tr></table></figure><h2 id="implementation-code-alert"><a class="markdownIt-Anchor" href="#implementation-code-alert"></a> Implementation (Code Alert!)</h2><p>这个lab的关键在于实现<code>nexti</code>函数，这个函数的输入是当前的y86 image（包括PC， 寄存器，内存和CC）。</p><p>首先第一步是parse指令，根据instruction code来获取寄存器和立即数。获取到的寄存器分别存在rA和rB里面，立即数存在valC里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">byte_t</span> codefun = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 1 byte */</span><br><span class="hljs-type">itype_t</span> icode;<br><span class="hljs-type">alu_t</span> ifun;<br><span class="hljs-type">long_t</span> next_pc = sim-&gt;pc;<br><br><span class="hljs-comment">/* get code and function （1 byte) */</span><br><span class="hljs-keyword">if</span> (!get_byte_val(sim-&gt;m, next_pc, &amp;codefun))<br>&#123;<br>    err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid instruction address&quot;</span>, sim-&gt;pc);<br>    <span class="hljs-keyword">return</span> STAT_ADR;<br>&#125;<br><span class="hljs-comment">/* get the instruction code */</span><br>icode = GET_ICODE(codefun);<br><span class="hljs-comment">/* get the ALU code */</span><br>ifun = GET_FUN(codefun);<br>next_pc++;<br><br><span class="hljs-comment">/* get registers if needed (1 byte) */</span><br><span class="hljs-type">reg_t</span> rA = &#123;<span class="hljs-number">0</span>&#125;, rB = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">if</span> (get_register_needed(icode))<br>&#123;<br>    <span class="hljs-comment">/* get the register specifier */</span><br>    <span class="hljs-keyword">if</span> (!get_byte_val(sim-&gt;m, next_pc, &amp;codefun))<br>    &#123;<br>        err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid instruction address&quot;</span>, sim-&gt;pc);<br>        <span class="hljs-keyword">return</span> STAT_ADR;<br>    &#125;<br>    rA = reg_table[GET_REGA(codefun)];<br>    rB = reg_table[GET_REGB(codefun)];<br>    next_pc++;<br>&#125;<br><br><span class="hljs-comment">/* get immediate if needed (8 bytes) */</span><br><span class="hljs-type">long_t</span> valC = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (get_immediate_needed(icode))<br>&#123;<br>    <span class="hljs-keyword">if</span> (!get_long_val(sim-&gt;m, next_pc, &amp;valC))<br>    &#123;<br>        err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid instruction address&quot;</span>, sim-&gt;pc);<br>        <span class="hljs-keyword">return</span> STAT_ADR;<br>    &#125;<br>    next_pc += <span class="hljs-number">8</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我用了两个helper function: <code>get_register_needed</code>和<code>get_immediate_needed</code>来根据instruction code确定是否需要获取register specifier和8位的immediate，参考下图y86指令集：</p><img src="../imgs/202502171432021-1740397650876-106.png" alt="Y86-64指令集" style="zoom:67%;" /><p>然后就是补全switch语句根据指令前4 bits的instruction code来分别执行相应的操作，需要注意以下几类指令：</p><ol><li><p><code>OPq</code>: 根据function code确定具体需要执行的ALU操作。需要实现<code>compute_alu</code>执行ALU操作，<code>compute_cc</code>根据ALU操作结果设置CC。</p><blockquote><p>如何判断ADD和SUB操作有无overflow?</p></blockquote><p>如果两个<code>long_t</code>类型数相加，得到的和的符号与原本两个数符号相反，则overflow：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ovf = ((argA ^ val) &amp; (argB ^ val)) &gt;&gt; <span class="hljs-number">63</span>;<br></code></pre></td></tr></table></figure><p>减法可以转化成第一个数加第二个数的相反数，与加法overflow判断方式相同。</p></li><li><p><code>jXX</code>和<code>cmovXX</code>: 需要实现<code>cond_doit</code>，先根据function code和当前的cc来判断能否执行。</p><blockquote><p>如何判断Less和Greater?</p></blockquote><p>两个数相减，如果是负数且没有overflow，或是正数但overflow，那么说明第一个数Less than第二个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> C_L:<br>        <span class="hljs-keyword">return</span> (sf ^ of);<br></code></pre></td></tr></table></figure><p>Greater就是Less反过来并加上!zero。</p></li></ol><p>完整的switch代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* execute the instruction*/</span><br><span class="hljs-keyword">switch</span> (icode)<br>&#123;<br>    <span class="hljs-keyword">case</span> I_HALT: <span class="hljs-comment">/* 0:0 */</span><br>        <span class="hljs-keyword">return</span> STAT_HLT;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_NOP: <span class="hljs-comment">/* 1:0 */</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_RRMOVQ: <span class="hljs-comment">/* 2:x regA:regB */</span><br>        <span class="hljs-keyword">if</span> (cond_doit(sim-&gt;cc, ifun))<br>        &#123;<br>            set_reg_val(sim-&gt;r, rB.id, get_reg_val(sim-&gt;r, rA.id));<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_IRMOVQ: <span class="hljs-comment">/* 3:0 F:regB imm */</span><br>        set_reg_val(sim-&gt;r, rB.id, valC);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_RMMOVQ: <span class="hljs-comment">/* 4:0 regA:regB imm */</span><br>        <span class="hljs-keyword">if</span> (!set_long_val(sim-&gt;m, get_reg_val(sim-&gt;r, rB.id) + valC, get_reg_val(sim-&gt;r, rA.id)))<br>        &#123;<br>            err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid data address 0x%lx&quot;</span>, sim-&gt;pc, get_reg_val(sim-&gt;r, rB.id) + valC);<br>            <span class="hljs-keyword">return</span> STAT_ADR;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_MRMOVQ: <span class="hljs-comment">/* 5:0 regB:regA imm */</span><br>        <span class="hljs-type">long_t</span> valM;<br>        <span class="hljs-keyword">if</span> (!get_long_val(sim-&gt;m, get_reg_val(sim-&gt;r, rB.id) + valC, &amp;valM))<br>        &#123;<br>            err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid data address 0x%lx&quot;</span>, sim-&gt;pc, get_reg_val(sim-&gt;r, rB.id) + valC);<br>            <span class="hljs-keyword">return</span> STAT_ADR;<br>        &#125;<br>        set_reg_val(sim-&gt;r, rA.id, valM);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_ALU: <span class="hljs-comment">/* 6:x regA:regB */</span><br>        <span class="hljs-type">long_t</span> alu_val;<br>        <span class="hljs-comment">/* do the ALU operation and set condition codes */</span><br>        alu_val = compute_alu(ifun, get_reg_val(sim-&gt;r, rA.id), get_reg_val(sim-&gt;r, rB.id));<br>        sim-&gt;cc = compute_cc(ifun, get_reg_val(sim-&gt;r, rA.id), get_reg_val(sim-&gt;r, rB.id), alu_val);<br>        <span class="hljs-comment">/* save the result to the destination register */</span><br>        set_reg_val(sim-&gt;r, rB.id, alu_val);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_JMP: <span class="hljs-comment">/* 7:x imm */</span><br>        <span class="hljs-keyword">if</span> (cond_doit(sim-&gt;cc, ifun)) &#123;<br>            next_pc = valC;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_CALL:  <span class="hljs-comment">/* 8:x imm */</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Push address of next instruction onto stack;</span><br><span class="hljs-comment">         * Start executing instructions at Dest;</span><br><span class="hljs-comment">         */</span><br>        set_reg_val(sim-&gt;r, REG_RSP, get_reg_val(sim-&gt;r, REG_RSP) - <span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">if</span> (!set_long_val(sim-&gt;m, get_reg_val(sim-&gt;r, REG_RSP), next_pc))<br>        &#123;<br>            err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid stack address 0x%lx&quot;</span>, sim-&gt;pc, get_reg_val(sim-&gt;r, REG_RSP));<br>            set_reg_val(sim-&gt;r, REG_RSP, get_reg_val(sim-&gt;r, REG_RSP) + <span class="hljs-number">8</span>);<br>            <span class="hljs-keyword">return</span> STAT_ADR;<br>        &#125;<br>        next_pc = valC;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_RET:   <span class="hljs-comment">/* 9:0 */</span><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">         * Pop value from stack;</span><br><span class="hljs-comment">         * Use as address for next instruction; </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (!get_long_val(sim-&gt;m, get_reg_val(sim-&gt;r, REG_RSP), &amp;next_pc)) &#123;<br>            err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid stack address 0x%lx&quot;</span>, sim-&gt;pc, get_reg_val(sim-&gt;r, REG_RSP));<br>            <span class="hljs-keyword">return</span> STAT_ADR;<br>        &#125;<br>        set_reg_val(sim-&gt;r, REG_RSP, get_reg_val(sim-&gt;r, REG_RSP) + <span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_PUSHQ: <span class="hljs-comment">/* A:0 regA:F */</span><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">         * Decrement %rsp by 8;</span><br><span class="hljs-comment">         * Store word from rA to memory at %rsp;</span><br><span class="hljs-comment">         * Like x86-64 (pushq %rsp -&gt; save old %rsp);</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long_t</span> rA_val = get_reg_val(sim-&gt;r, rA.id);<br>        set_reg_val(sim-&gt;r, REG_RSP, get_reg_val(sim-&gt;r, REG_RSP) - <span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">if</span> (!set_long_val(sim-&gt;m, get_reg_val(sim-&gt;r, REG_RSP), rA_val))<br>        &#123;<br>            err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid stack address 0x%lx&quot;</span>, sim-&gt;pc, get_reg_val(sim-&gt;r, REG_RSP));<br>            set_reg_val(sim-&gt;r, REG_RSP, get_reg_val(sim-&gt;r, REG_RSP) + <span class="hljs-number">8</span>);<br>            <span class="hljs-keyword">return</span> STAT_ADR;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> I_POPQ: <span class="hljs-comment">/* B:0 regA:F */</span><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">         * Read word from memory at %rsp;</span><br><span class="hljs-comment">         * Save in rA;</span><br><span class="hljs-comment">         * Increment %rsp by 8;</span><br><span class="hljs-comment">         * Like x86-64 (popq %rsp -&gt; movq (%rsp) %rsp);</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long_t</span> val_stack;<br>        <span class="hljs-keyword">if</span> (!get_long_val(sim-&gt;m, get_reg_val(sim-&gt;r, REG_RSP), &amp;val_stack)) &#123;<br>            err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid stack address 0x%lx&quot;</span>, sim-&gt;pc, get_reg_val(sim-&gt;r, REG_RSP));<br>            <span class="hljs-keyword">return</span> STAT_ADR;<br>        &#125;<br>        set_reg_val(sim-&gt;r, rA.id, val_stack);<br>        <span class="hljs-keyword">if</span> (rA.id != REG_RSP)<br>        &#123;<br>            set_reg_val(sim-&gt;r, REG_RSP, get_reg_val(sim-&gt;r, REG_RSP) + <span class="hljs-number">8</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        err_print(<span class="hljs-string">&quot;PC = 0x%lx, Invalid instruction %.2x&quot;</span>, sim-&gt;pc, codefun);<br>        <span class="hljs-keyword">return</span> STAT_INS;<br>&#125;<br><br>sim-&gt;pc = next_pc;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>这个lab的error handling容易出错！：</p><ol><li><p>status code的返回，只要是invalid address的错误，无论是invalid instruction address, invalid data address, invalid stack address，都是返回<code>STAT_ADR</code></p></li><li><p><code>pushq</code>和<code>call</code>都是先decrement <code>rsp</code>，然后尝试写入栈中。如果写入失败应该重新increment <code>rsp</code>到原来的值，如果忘记这一步的话test会fail:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">[ Testing instruction</span><span class="hljs-punctuation">:</span> <span class="hljs-string">call ]</span><br><span class="hljs-attribute">3a4</span><br><span class="hljs-attribute">&gt; %rsp</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x0000000000000000      0xfffffffffffffff8</span><br><span class="hljs-attribute">[ Result</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Fail ]</span><br><br><span class="hljs-attribute">[ Testing instruction</span><span class="hljs-punctuation">:</span> <span class="hljs-string">pushq ]</span><br><span class="hljs-attribute">3a4</span><br><span class="hljs-attribute">&gt; %rsp</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x0000000000000000      0xfffffffffffffff8</span><br><span class="hljs-attribute">[ Result</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Fail ]</span><br><br><span class="hljs-attribute">[ Testing application</span><span class="hljs-punctuation">:</span> <span class="hljs-string">prog10 ]</span><br><span class="hljs-attribute">4a5</span><br><span class="hljs-attribute">&gt; %rsp</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x0000000000000000      0xfffffffffffffff8</span><br><span class="hljs-attribute">[ Result</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Fail ]</span><br></code></pre></td></tr></table></figure></li></ol>          </div><h2 id="test"><a class="markdownIt-Anchor" href="#test"></a> Test</h2><p>To test and evaluate your Simulator:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">./yat -c &lt;name&gt; [max_steps] # get the correct status of registers and memory<br>e.g., ./yat -c prog9 4<br><br><br>./yat -s &lt;ins_name&gt; [max_steps] # test .bin file of single instruction in y64-ins-bin directory<br>e.g., ./yat –s rrmovl<br><br><br>./yat -S # test all instructions 1<br><br><br>./yat -a &lt;app_name&gt; [max_steps] # test single application in y64-app-bin directory.<br>e.g., ./yat –a asum 1<br><br><br>./yat -A # test all applications 1<br><br><br>./yat -F # test all instructions and applications, and print out the final score.<br><br><br>./yat -h # print this message<br></code></pre></td></tr></table></figure><p>All tests pass!🤗</p><p><img src="../imgs/image-20250224193608135.png" alt="" /></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>这个Simulator Lab就是在编写底层硬件执行上层y86指令的行为，很机械很有意思！</p><p>完成这个Lab后，你就能理解为什么程序就是一台状态机！这个状态机每次读取一条指令，然后调动底层硬件更新处理器的状态，然后根据status code决定接下来是继续执行，halt，还是出错。</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
      <category>Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>Y86</tag>
      
      <tag>Simulator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL Tutorial Note</title>
    <link href="/2025/02/21/STL/"/>
    <url>/2025/02/21/STL/</url>
    
    <content type="html"><![CDATA[<p>CJC From NJU wrote a <a href="https://cui-jiacai.gitbook.io/c++-stl-tutorial">C++ STL Tutorial</a>. This is a perfect learning material for STL beginners to get familiar with C++ STL. Hope this note can help you learn the material!</p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><blockquote><p>STL包含什么？</p></blockquote><p>STL是一个基于模版实现的标准模板库，包含容器类模版、算法模版和迭代器模版。</p><p>其中迭代器是指向容器的元素，是容器和算法之间的桥梁。</p><img src="../imgs/202501172358157.png" alt="" style="zoom:80%;" /><h2 id="容器container"><a class="markdownIt-Anchor" href="#容器container"></a> 容器(Container)</h2><h3 id="vector元素类型"><a class="markdownIt-Anchor" href="#vector元素类型"></a> vector&lt;元素类型&gt;</h3><p>快速访问任意位置的元素，主要在元素序列的尾部增加/删除元素</p><p>用动态数组实现</p><h3 id="list元素类型"><a class="markdownIt-Anchor" href="#list元素类型"></a> list&lt;元素类型&gt;</h3><p>在元素序列中任意位置上插入/删除元素</p><p>用双向链表实现</p><div class="note note-info">            <p>C++11中增加了<code>forward_list</code>容器，本质上是一个<strong>单向链表</strong>，定义在头文件<code>forward_list</code>中。</p>          </div><h3 id="deque元素类型"><a class="markdownIt-Anchor" href="#deque元素类型"></a> deque&lt;元素类型&gt;</h3><p>在元素序列的两端增加/删除元素，快速访问任意位置的元素</p><p>用<strong>分段的连续空间结构</strong>实现</p><h3 id="stack元素类型"><a class="markdownIt-Anchor" href="#stack元素类型"></a> stack&lt;元素类型&gt;</h3><p>仅在元素序列的尾部增加/删除元素</p><p>可基于<code>deque</code>、<code>list</code>或<code>vector</code>来实现</p><h3 id="queue元素类型"><a class="markdownIt-Anchor" href="#queue元素类型"></a> queue&lt;元素类型&gt;</h3><p>仅在元素序列的尾部增加、头部删除元素</p><p>可基于<code>deque</code>和<code>list</code>来实现。</p><h3 id="priority_queue元素类型"><a class="markdownIt-Anchor" href="#priority_queue元素类型"></a> priority_queue&lt;元素类型&gt;</h3><p>每次增加/删除元素之后，对元素位置进行调整，使得头部元素总是最大的。也就是说，每次删除操作总是从头部把最大（优先级最高）的元素去掉。</p><p>可基于<code>deque</code>和<code>vector</code>来实现</p><h3 id="mapkeyvalue-和-multimapkeyvalue"><a class="markdownIt-Anchor" href="#mapkeyvalue-和-multimapkeyvalue"></a> map&lt;key，value&gt; 和 multimap&lt;key，value&gt;</h3><p>根据key来访问元素，容器中每个元素是一个<code>pair&lt;key, value&gt;</code>结构</p><p>对于<code>map</code>，不同元素的关键字不能相同；对于<code>multimap</code>，不同元素的关键字可以相同。</p><p>常用某种<strong>二叉树</strong>来实现</p><div class="note note-info">            <p>有时候我们不需要排序，所以C++11中新增加了<code>unordered_map</code></p><p>和<code>unordered_multimap</code>容器。</p>          </div><h3 id="set元素类型-和-multiset元素类型"><a class="markdownIt-Anchor" href="#set元素类型-和-multiset元素类型"></a> set&lt;元素类型&gt; 和 multiset&lt;元素类型&gt;</h3><p>它们分别是<code>map</code>和<code>multimap</code>的特例，每个元素只有key而没有value</p><div class="note note-info">            <p>C++11中增加了<code>unordered_set</code>和<code>unordered_multiset</code>容器。</p>          </div><h3 id="basic_string字符类型"><a class="markdownIt-Anchor" href="#basic_string字符类型"></a> basic_string&lt;字符类型&gt;</h3><p>与<code>vector</code>类似，不同之处在于其元素为字符类型</p><p><code>string</code>和<code>wstring</code>分别是它的两个实例：</p><ul><li><code>basic_string&lt;char&gt;</code></li><li><code>basic_string&lt;wchar_t&gt;</code></li></ul><h2 id="迭代器iterator"><a class="markdownIt-Anchor" href="#迭代器iterator"></a> 迭代器(Iterator)</h2><h3 id="迭代器的分类五种基本迭代器"><a class="markdownIt-Anchor" href="#迭代器的分类五种基本迭代器"></a> 迭代器的分类（五种基本迭代器）</h3><p>根据访问修改权限分类：</p><ul><li>输出迭代器（output iterator，记为：<strong>OutIt</strong>）：修改它所指向的容器元素</li><li>输入迭代器（input iterator，记为：<strong>InIt</strong>）：读取它所指向的容器元素</li></ul><p>根据迭代方式分类：</p><ul><li>前向迭代器（forward iterator，记为：<strong>FwdIt</strong>）</li><li>双向迭代器（bidirectional iterator，记为：<strong>BidIt</strong>）</li><li>随机访问迭代器（random-access iterator，记为：<strong>RanIt</strong>）</li></ul><p>对于<code>vector</code>、<code>deque</code>以及<code>basic_string</code>容器类，与它们关联的迭代器类型为<strong>随机访问迭代器（RanIt）</strong></p><p>对于<code>list</code>、<code>map/multimap</code>以及<code>set/multiset</code>容器类，与它们关联的迭代器类型为<strong>双向迭代器（BidIt）</strong></p><div class="note note-danger">            <p><code>queue</code>、<code>stack</code>和<code>priority_queue</code>容器类，不支持迭代器！</p>          </div><img src="../imgs/202501200142932.png" alt="" style="zoom: 67%;" /><div class="note note-info">            <p>在需要箭头左边迭代器的地方可以用箭头右边的迭代器去替代。</p>          </div><h3 id="反向迭代器reverse-iterator"><a class="markdownIt-Anchor" href="#反向迭代器reverse-iterator"></a> 反向迭代器（reverse iterator）</h3><p>用于对容器元素从尾到头进行反向遍历，可以通过容器类的成员函数<code>rbegin</code>和<code>rend</code>可以获得容器的尾和首元素的<strong>反向迭代器</strong>。</p><h3 id="插入迭代器insert-iterator"><a class="markdownIt-Anchor" href="#插入迭代器insert-iterator"></a> 插入迭代器（insert iterator）</h3><ul><li><code>back_insert_iterator</code>（用于在尾部插入元素）</li><li><code>front_insert_iterator</code>（用于在首部插入元素）</li><li><code>insert_iterator</code>（用于在任意指定位置插入元素）</li></ul><p>可以分别通过函数<code>back_inserter</code>、<code>front_inserter</code>和<code>inserter</code>来获得，函数的参数为容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 准备用于演示的容器</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec;              <span class="hljs-comment">// 用于back_inserter</span><br>std::list&lt;<span class="hljs-type">int</span>&gt; lst;                <span class="hljs-comment">// 用于front_inserter</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; middle_vec&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;  <span class="hljs-comment">// 用于inserter</span><br><br><span class="hljs-comment">// 1. back_insert_iterator示例</span><br><span class="hljs-comment">// 将source中的元素复制到vec的末尾</span><br>std::<span class="hljs-built_in">copy</span>(source.<span class="hljs-built_in">begin</span>(), source.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">back_inserter</span>(vec));<br><br><span class="hljs-comment">// 2. front_insert_iterator示例</span><br><span class="hljs-comment">// 将source中的元素复制到lst的开头</span><br><span class="hljs-comment">// 注意：front_inserter只能用于支持push_front的容器（如list）</span><br>std::<span class="hljs-built_in">copy</span>(source.<span class="hljs-built_in">begin</span>(), source.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">front_inserter</span>(lst));<br><br><span class="hljs-comment">// 3. insert_iterator示例</span><br><span class="hljs-comment">// 将source中的元素插入到middle_vec的中间位置</span><br><span class="hljs-keyword">auto</span> insert_pos = middle_vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>;  <span class="hljs-comment">// 在30前面插入</span><br>std::<span class="hljs-built_in">copy</span>(source.<span class="hljs-built_in">begin</span>(), source.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">inserter</span>(middle_vec, insert_pos));<br></code></pre></td></tr></table></figure><h3 id="使用迭代器求解约瑟夫问题"><a class="markdownIt-Anchor" href="#使用迭代器求解约瑟夫问题"></a> 使用迭代器求解约瑟夫问题</h3><p>N 个人围成一圈，从第 1 个人开始报数，每报到第 M 个人就让他出列并从下一个人重新开始报数，直到所有人都出列为止。问最后一个出列的人是原来的第几号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> m,n; <span class="hljs-comment">// m用于存储要报的数，n用于存储小孩个数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入小孩的个数和要报的数：&quot;</span>;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-comment">// 构建圈子</span><br>list&lt;<span class="hljs-type">int</span>&gt; children; <span class="hljs-comment">// children是用于存储小孩编号的容器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) <span class="hljs-comment">// 循环创建容器元素</span><br>    children.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 把i（小孩的编号）从容器尾部放入容器</span><br><span class="hljs-comment">// 开始报数</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator current; <span class="hljs-comment">// current为指向容器元素的迭代器</span><br>current = children.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// current初始化成指向容器的第一个元素</span><br><span class="hljs-keyword">while</span> (children.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// 只要容器元素个数大于1，就执行循环</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; count &lt; m; count++)  <span class="hljs-comment">//报数，循环m-1次</span><br>    &#123;<br>        current++; <span class="hljs-comment">//current指向下一个元素</span><br>        <span class="hljs-comment">// 如果current指向的是容器末尾，current指向第一个元素</span><br>        <span class="hljs-keyword">if</span> (current == children.<span class="hljs-built_in">end</span>()) current = children.<span class="hljs-built_in">begin</span>();<br>    &#125;<br>    <span class="hljs-comment">// 循环结束时，current指向将要离开圈子的小孩</span><br>    current = children.<span class="hljs-built_in">erase</span>(current);  <span class="hljs-comment">// 小孩离开圈子，current指向下一个元素</span><br>    <span class="hljs-comment">// 如果current指向的是容器末尾，current指向第一个元素</span><br>    <span class="hljs-keyword">if</span> (current == children.<span class="hljs-built_in">end</span>()) current = children.<span class="hljs-built_in">begin</span>();<br>&#125; <span class="hljs-comment">// 循环结束时，current指向容器中剩下的唯一的一个元素，即胜利者</span><br><span class="hljs-comment">// 输出胜利者的编号</span><br>cout &lt;&lt; <span class="hljs-string">&quot;The winner is No.&quot;</span> &lt;&lt; *current &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="算法algorithm"><a class="markdownIt-Anchor" href="#算法algorithm"></a> 算法(Algorithm)</h2><p>在STL中，我们把某些迭代器传递给算法，算法通过迭代器来访问和遍历相应容器中的元素。</p><p>用算法对容器中的元素进行操作时，大都需要用<strong>两个迭代器来指出要操作的元素的范围</strong>。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(RanIt first, RanIt last)</span></span>;<br></code></pre></td></tr></table></figure><p>有些算法可以有多个操作范围，这时，除第一个范围外，其它范围可以不指定最后一个元素位置，它由第一个范围中元素的个数决定。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">OutIt <span class="hljs-title">copy</span><span class="hljs-params">(InIt src_first, InIt src_last, OutIt dst_first)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="算法的自定义操作"><a class="markdownIt-Anchor" href="#算法的自定义操作"></a> 算法的自定义操作</h3><p>自定义操作可分为：</p><ul><li><strong>Op</strong>或<strong>Fun</strong>：一元操作，需要一个参数</li></ul><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Fun <span class="hljs-title">for_each</span><span class="hljs-params">(InIt first, InIt last, Fun f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; x; &#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>...... <span class="hljs-comment">// 往容器中放了元素</span><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), f); <span class="hljs-comment">// 对v中的每个元素去调用函数f进行操作</span><br></code></pre></td></tr></table></figure><ul><li><strong>BinOp</strong>或<strong>BinFun</strong>：二元操作，需要两个参数</li></ul><p>例如，对于下面的元素“<strong>变换/映射</strong>”算法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">OutIt <span class="hljs-title">transform</span><span class="hljs-params">(InIt src_first, InIt src_last, OutIt dst_first, Op f)</span></span>;<br><span class="hljs-function">OutIt <span class="hljs-title">transform</span><span class="hljs-params">(InIt1 src_first1, InIt1 src_last1, InIt2 src_first2, OutIt dst_first, BinOp f)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2)</span> </span>&#123; <span class="hljs-keyword">return</span> x1 + x2; &#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v1,v2,v3,v4;<br>...... <span class="hljs-comment">// 往v1和v2容器中放了元素</span><br><br><span class="hljs-built_in">transform</span>(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),v3.<span class="hljs-built_in">begin</span>(),f1); <br><span class="hljs-comment">// v3中的元素是v1相应元素的平方</span><br><br><span class="hljs-built_in">transform</span>(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),v2.<span class="hljs-built_in">begin</span>(),v4.<span class="hljs-built_in">begin</span>(),f2); <br><span class="hljs-comment">// v4中的元素是v1和v2相应元素的和</span><br></code></pre></td></tr></table></figure><h2 id="仿函数functor"><a class="markdownIt-Anchor" href="#仿函数functor"></a> 仿函数(Functor)</h2><blockquote><p>这里稍微拓展一下**仿函数(Functor)**的使用，在后续会有详细的介绍。</p></blockquote><div class="note note-info">            <p>仿函数，也可以叫作函数对象</p>          </div><p>利用仿函数实现算法的自定义操作：</p><p>定义函数对象类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MatchMajor</span><br>&#123;<br>    Major major;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MatchMajor</span> (Major m) &#123; major = m; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(Student&amp; st)</span> </span>&#123; <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">get_major</span>() == major; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>统计某某专业的人数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">count_if</span>(students.<span class="hljs-built_in">begin</span>(), students.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MatchMajor</span>(COMPUTER))；<br><span class="hljs-built_in">count_if</span>(students.<span class="hljs-built_in">begin</span>(), students.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MatchMajor</span>(PHYSICS))；<br><br><span class="hljs-comment">// 统计XXX专业的人数</span><br><span class="hljs-built_in">count_if</span>(students.<span class="hljs-built_in">begin</span>(), students.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MatchMajor</span>(XXX))；<br></code></pre></td></tr></table></figure><h2 id="匿名函数lambda表达式"><a class="markdownIt-Anchor" href="#匿名函数lambda表达式"></a> 匿名函数(lambda表达式)</h2><blockquote><p><a href="https://www.runoob.com/cplusplus/cpp-functions.html">https://www.runoob.com/cplusplus/cpp-functions.html</a></p></blockquote><div class="note note-info">            <p>Lambda表达式可以看作一个函数对象</p>          </div><p>Lambda 表达式具体形式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture](parameters)-&gt;<span class="hljs-keyword">return</span>-type&#123;body&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123; <span class="hljs-keyword">return</span> x &lt; y ; &#125;<br></code></pre></td></tr></table></figure><p>如果没有返回值可以表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture](parameters)&#123;body&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[]&#123; ++global_x; &#125; <br></code></pre></td></tr></table></figure><p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-type">int</span> z = x + y; <span class="hljs-keyword">return</span> z + x; &#125;<br></code></pre></td></tr></table></figure><p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[]</span>      <span class="hljs-comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span><br><span class="hljs-string">[x, &amp;y]</span> <span class="hljs-comment">// x以传值方式传入（默认），y以引用方式传入。</span><br><span class="hljs-string">[&amp;]</span>     <span class="hljs-comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span><br><span class="hljs-string">[=]</span>     <span class="hljs-comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span><br><span class="hljs-string">[&amp;, x]</span>  <span class="hljs-comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span><br><span class="hljs-string">[=, &amp;z]</span> <span class="hljs-comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>需要注意的是，[]是空捕获列表的lambda表达式是<strong>不能访问外部非静态的局部变量</strong>的，但是可以访问全局变量和静态的局部变量，因为他们的生命周期覆盖整个程序运行期间</p>          </div><p>利用lambda表达式实现算法的自定义操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//统计“计算机专业女生”的人数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;计算机专业女生的人数是：&quot;</span> <br>      &lt;&lt; <span class="hljs-built_in">count_if</span>(students.<span class="hljs-built_in">begin</span>(),students.<span class="hljs-built_in">end</span>(),<br>        [](Student &amp;st) &#123; <span class="hljs-built_in">return</span> (st.<span class="hljs-built_in">get_major</span>() == COMPUTER)<br>     &amp;&amp; (st.<span class="hljs-built_in">get_sex</span>() == FEMALE); &#125;);<br><br><span class="hljs-comment">//按“学号由小到大”对students的元素进行排序</span><br><span class="hljs-built_in">sort</span>(students.<span class="hljs-built_in">begin</span>(),students.<span class="hljs-built_in">end</span>(),<br>[](Student &amp;st1,Student &amp;st2) &#123;  <br>                                 <span class="hljs-keyword">return</span>  st1.<span class="hljs-built_in">get_no</span>()&lt;st2.<span class="hljs-built_in">get_no</span>();&#125;);<br></code></pre></td></tr></table></figure><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><blockquote><p>这里附上微软的C++文档pdf链接：</p><p><a href="https://box.nju.edu.cn/f/c19cd234d4a94fd2b458/">https://box.nju.edu.cn/f/c19cd234d4a94fd2b458/</a></p></blockquote><p>后续将会介绍各种常用STL的用法。熟悉这些常见的STL用法+查文档是C++开发的基本要求。</p><h1 id="容器container-2"><a class="markdownIt-Anchor" href="#容器container-2"></a> 容器(Container)</h1><h2 id="选择容器"><a class="markdownIt-Anchor" href="#选择容器"></a> 选择容器</h2><p>容器分为序列容器和容器适配器。</p><p>选择序列容器：</p><img src="../imgs/202501210038620.png" alt="" style="zoom:80%;" /><p>选择容器适配器：</p><img src="../imgs/202501210038617.png" alt="" style="zoom:80%;" /><h2 id="字符串string"><a class="markdownIt-Anchor" href="#字符串string"></a> 字符串(string)</h2><p>string本质上是一个动态char数组</p><h3 id="常用api"><a class="markdownIt-Anchor" href="#常用api"></a> 常用API</h3><ul><li>string构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span>();<br><span class="hljs-comment">// 默认构造函数，创建一个空的字符串</span><br><span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string&amp; str);<br><span class="hljs-comment">// 拷贝构造函数，使用一个string对象初始化另一个string对象</span><br><span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s);<br><span class="hljs-comment">// 含参构造函数，使用C风格字符串初始化</span><br><span class="hljs-built_in">string</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c);<br><span class="hljs-comment">// p含参构造函数，使用n个字符c初始化</span><br></code></pre></td></tr></table></figure><ul><li>赋值操作</li></ul><p><code>=</code>赋值操作符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">string&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s);<br><span class="hljs-comment">// C风格字符串赋值给当前的字符串</span><br>string&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> string&amp; s);<br><span class="hljs-comment">// 把字符串s赋给当前的字符串</span><br>string&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c);<br><span class="hljs-comment">//字符赋值给当前的字符串</span><br></code></pre></td></tr></table></figure><p><code>assign</code>成员函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <br><span class="hljs-comment">// C风格字符串赋值给当前的字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">int</span> n)</span></span>; <br><span class="hljs-comment">// 把C风格字符串s的前n个字符赋给当前的字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span></span>; <br><span class="hljs-comment">// 把字符串s赋给当前字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span></span>; <br><span class="hljs-comment">// 把n个字符c赋给当前的字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n)</span></span>; <br><span class="hljs-comment">// 将字符串s中从start开始的n个字符赋值给当前字符串</span><br></code></pre></td></tr></table></figure><ul><li>string存取字符操作</li></ul><p>下标获取操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n); <br><span class="hljs-comment">// 通过[]下标方式获取字符</span><br></code></pre></td></tr></table></figure><p>使用下标操作符获取字符时，如果下标越界，程序将会强制终止。</p><p><code>at</code>成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <br><span class="hljs-comment">// 通过at方法获取字符</span><br></code></pre></td></tr></table></figure><p>使用at方法获取字符时，如果下标越界，at方法内部会抛出异常（<code>exception</code>），可以使用<code>try-catch</code>捕获并处理该异常。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-comment">//s[100]不会抛出异常，程序会直接挂掉</span><br>s.<span class="hljs-built_in">at</span>(<span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-built_in">catch</span> (out_of_range&amp; e) <br><span class="hljs-comment">//如果不熟悉异常类型，可以使用多态特性， catch(exception&amp; e)。</span><br>&#123;<br>cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl; <br><span class="hljs-comment">//打印异常信息</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>string拼接操作</li></ul><p><code>+=</code>复合操作符号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> string&amp; str); <br><span class="hljs-comment">// 将字符串str追加到当前字符串末尾</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str); <br><span class="hljs-comment">// 将C风格字符数组追加到当前字符串末尾</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c); <br><span class="hljs-comment">// 将字符c追加到当前字符串末尾</span><br><span class="hljs-comment">/* 上述操作重载了复合操作符+= */</span><br></code></pre></td></tr></table></figure><p><code>append</code>成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <br><span class="hljs-comment">// 把C风格字符数组s连接到当前字符串结尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">int</span> n)</span></span>; <br><span class="hljs-comment">// 把C风格字符数组s的前n个字符连接到当前字符串结尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span>; <br><span class="hljs-comment">// 将字符串s追加到当前字符串末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;s, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n)</span></span>; <br><span class="hljs-comment">// 把字符串s中从pos开始的n个字符连接到当前字符串结尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span></span>; <br><span class="hljs-comment">// 在当前字符串结尾添加n个字符c</span><br></code></pre></td></tr></table></figure><ul><li>string 查找和替换</li></ul><p><code>find</code>成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <br><span class="hljs-comment">// 查找str在当前字符串中第一次出现的位置，从pos开始查找，pos默认为0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <br><span class="hljs-comment">// 查找C风格字符串s在当前字符串中第一次出现的位置，从pos开始查找，pos默认为0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span></span>; <br><span class="hljs-comment">// 从pos位置查找s的前n个字符在当前字符串中第一次出现的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c, <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <br><span class="hljs-comment">// 查找字符c第一次出现的位置，从pos开始查找，pos默认为0</span><br></code></pre></td></tr></table></figure><blockquote><p>当查找失败时，<code>find</code>方法会返回<code>-1</code>，<code>-1</code>已经被封装为string的静态成员常量<code>string::npos</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> nops = <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure></blockquote><p><code>rfind</code>成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">int</span> pos = npos)</span> <span class="hljs-type">const</span></span>; <br><span class="hljs-comment">// 从pos开始向左查找最后一次出现的位置，pos默认为npos</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">int</span> pos = npos)</span> <span class="hljs-type">const</span></span>; <br><span class="hljs-comment">// 查找s最后一次出现的位置，从pos开始向左查找，pos默认为npos</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span></span>; <br><span class="hljs-comment">// 从pos开始向左查找s的前n个字符最后一次出现的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c, <span class="hljs-type">int</span> pos = npos)</span> <span class="hljs-type">const</span></span>; <br><span class="hljs-comment">// 查找字符c最后一次出现的位置</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p><code>find</code>方法通常查找字串第一次出现的位置，而<code>rfind</code>方法通常查找字串最后一次出现的位置。</p><p><code>rfind(str, pos)</code>的实际的开始位置是<code>pos + str.size()</code>，即从该位置开始（不包括该位置字符）向前寻找匹配项，如果有则返回字符串位置，如果没有返回<code>string::npos</code>。</p><p><code>-1</code>其实是<code>size_t</code>类的最大值，所以<code>string::npos</code>还可以表示“直到字符串结束”，rfind中pos的默认参数是字符串最后一个字符的后面一个位置。</p>          </div><p><code>replace</code>成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n, <span class="hljs-type">const</span> string&amp; str)</span></span>; <br><span class="hljs-comment">// 替换从pos开始n个字符为字符串s</span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>;<br><span class="hljs-comment">// 替换从pos开始的n个字符为字符串s</span><br></code></pre></td></tr></table></figure><ul><li>string比较操作</li></ul><p><code>compare</code>成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 与字符串s比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 与C风格字符数组比较</span><br></code></pre></td></tr></table></figure><p><code>compare</code>函数依据字典序比较，在当前字符串比给定字符串小时返回<code>-1</code>，在当前字符串比给定字符串大时返回<code>1</code>，相等时返回<code>0</code>。</p><p>比较操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> string&amp; str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> string&amp; str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> string&amp; str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> string&amp; str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> string&amp; str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> string&amp; str) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) <span class="hljs-type">const</span>;<br></code></pre></td></tr></table></figure><p><code>string</code>类重载了所有的比较操作符，其含义与比较操作符本身的含义相同。</p><ul><li>string子串</li></ul><p><code>substr</code>成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> n = npos)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// 返回由pos开始的n个字符组成的字符串</span><br></code></pre></td></tr></table></figure><ul><li>string 插入和删除操作</li></ul><p><code>insert</code>成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <span class="hljs-comment">// 在pos位置插入C风格字符数组</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> string&amp; str)</span></span>; <span class="hljs-comment">// 在pos位置插入字符串str</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 在pos位置插入n个字符c</span><br></code></pre></td></tr></table></figure><blockquote><p>返回值是插入后的字符串结果，<code>erase</code>同理。其实就是指向自身的一个引用。</p></blockquote><p><code>erase</code>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> n = npos)</span></span>; <span class="hljs-comment">// 删除从pos位置开始的n个字符</span><br></code></pre></td></tr></table></figure><blockquote><p>默认一直删除到末尾。</p></blockquote><ul><li><code>string</code> 和 <code>C-Style</code> 字符串的转换</li></ul><p><code>string</code>转<code>const char</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;demo&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = str.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure><p><code>const char</code>转<code>string</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-string">&quot;demo&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(cstr)</span></span>; <span class="hljs-comment">// 本质上其实是一个有参构造</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>C++可以隐式地将<code>const char *</code>转换为string，但反过来不行。</p>          </div><h3 id="string相关的全局函数"><a class="markdownIt-Anchor" href="#string相关的全局函数"></a> string相关的全局函数</h3><ul><li>大小写转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tolower</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>; <span class="hljs-comment">// 如果字符c是大写字母，则返回其小写形式，否则返回本身</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">toupper</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>; <span class="hljs-comment">// 如果字符c是小写字母，则返回其大写形式，否则返回本身</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * C语言中字符就是整数，这两个函数是从C库沿袭过来的，保留了C的风格</span><br><span class="hljs-comment">*/</span><br><br>string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">transform</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), str.<span class="hljs-built_in">begin</span>(), toupper); <span class="hljs-comment">//字符串转大写</span><br><span class="hljs-built_in">transform</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), str.<span class="hljs-built_in">begin</span>(), tolower); <span class="hljs-comment">//字符串转小写</span><br></code></pre></td></tr></table></figure><ul><li>字符串和数字的转换</li></ul><p><code>int</code>/<code>double</code>转<code>string</code></p><blockquote><p>c++11标准新增了全局函数<code>std::to_string</code>，十分强大，可以将很多类型变成<code>string</code>类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** 带符号整数转换成字符串 */</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">long</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>;<br><br><span class="hljs-comment">/** 无符号整数转换成字符串 */</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>;<br><br><span class="hljs-comment">/** 实数转换成字符串 */</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">float</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">double</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> val)</span></span>;<br></code></pre></td></tr></table></figure><p><code>string</code>转<code>int</code>/<code>double</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** 字符串转带符号整数 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stoi</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* idx = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">stol</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* idx = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">stoll</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* idx = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 1. idx返回字符串中第一个非数字的位置，即数值部分的结束位置</span><br><span class="hljs-comment">  * 2. base为进制</span><br><span class="hljs-comment">  * 3. 该组函数会自动保留负号和自动去掉前导0</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/** 字符串转无符号整数 */</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">stoul</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* idx = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">stoull</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* idx = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-comment">/** 字符串转实数 */</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">stof</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* idx = <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">stod</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* idx = <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">stold</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* idx = <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>与之类似的在同一个库里的还有一组基于字符数组（C风格字符串）的函数如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// &#x27;a&#x27; means array, since it is array-based. </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>; <span class="hljs-comment">// &#x27;i&#x27; means  int</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">atol</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>; <span class="hljs-comment">// &#x27;l&#x27; means long</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">atoll</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>; <span class="hljs-comment">// &#x27;ll&#x27; means long long</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">atof</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span></span>; <span class="hljs-comment">// &#x27;f&#x27; means double</span><br></code></pre></td></tr></table></figure><h2 id="向量vector"><a class="markdownIt-Anchor" href="#向量vector"></a> 向量(vector)</h2><p><code>array</code>是静态空间，而<code>vector</code>是动态空间</p><p>vector提供的是随机访问迭代器（<em>Random Access Iterator</em>），其内部用普通指针实现。</p><h3 id="vector数据结构"><a class="markdownIt-Anchor" href="#vector数据结构"></a> vector数据结构</h3><p>就是简单的线性连续空间，两个迭代器<code>_Myfirst</code>和<code>_Mylast</code>分别指向配置得来的连续空间中已被使用的范围，迭代器<code>Myend</code>指向整块连续内存空间的尾端</p><h3 id="常用api-2"><a class="markdownIt-Anchor" href="#常用api-2"></a> 常用API</h3><ul><li>构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;T&gt; v; <span class="hljs-comment">// 采用模版类实现，默认构造函数</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v</span><span class="hljs-params">(T* v1.begin(), T* v1.end())</span></span>; <span class="hljs-comment">// 将v1[begin(), end())区间中的元素拷贝给本身</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-type">int</span> n, T elem)</span></span>; <span class="hljs-comment">// 将n个elem拷贝给本身</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;T&gt; v1)</span></span>; <span class="hljs-comment">// 拷贝构造函数</span><br></code></pre></td></tr></table></figure><ul><li>赋值操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">assign</span>(beg, end); <span class="hljs-comment">// 将[beg, end)区间中的数据拷贝复制给本身</span><br><span class="hljs-built_in">assign</span>(n, elem); <span class="hljs-comment">// 将n个elem拷贝给本身</span><br>vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&amp; vec); <span class="hljs-comment">// 重载赋值操作符</span><br></code></pre></td></tr></table></figure><p>互换操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">swap</span>(vec); <span class="hljs-comment">//将vec与本身的元素互换</span><br></code></pre></td></tr></table></figure><ul><li>大小操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回容器中的元素个数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 判断容器是否为空</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>; <br><span class="hljs-comment">// 重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</span><br><span class="hljs-comment">// 若容器变短，则末尾超出容器长度的元素被删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> num, T elem)</span></span>; <br><span class="hljs-comment">// 重新指定容器的长度为num，若容器变长，则以elem填充新位置。</span><br><span class="hljs-comment">// 若容器变短，则末尾超出容器长度的元素被删除</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回容器的容量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span>; <br><span class="hljs-comment">// 容器预留len个元素长度，预留位置不初始化，元素不可访问</span><br></code></pre></td></tr></table></figure><ul><li>数据存取</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">T&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span>; <span class="hljs-comment">// 返回索引idx所指的数据，如果idx越界，抛出out_of_range异常</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> idx); <span class="hljs-comment">// 返回索引idx所指的数据，如果idx越界，运行直接报错</span><br><br><span class="hljs-function">T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回首元素的引用</span><br><span class="hljs-function">T&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回尾元素的引用</span><br></code></pre></td></tr></table></figure><ul><li>插入和删除</li></ul><p>vector是单向开口的，只有在尾部插入和删除元素效率较高，向其它位置插入和删除元素需要大量移位操作，效率很低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insert</span>(const_iterator pos, T elem); <span class="hljs-comment">// 在pos位置处插入元素elem</span><br><span class="hljs-built_in">insert</span>(const_iterator pos, <span class="hljs-type">int</span> n, T elem); <span class="hljs-comment">// 在pos位置插入n个元素elem</span><br><span class="hljs-built_in">insert</span>(pos, beg, end); <span class="hljs-comment">// 将[beg, end)区间内的元素插到位置pos</span><br><span class="hljs-built_in">push_back</span>(T elem); <span class="hljs-comment">// 尾部插入元素elem</span><br><span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 删除最后一个元素</span><br><br><span class="hljs-built_in">erase</span>(const_iterator start, const_iterator end); <span class="hljs-comment">// 删除区间[start, end)内的元素</span><br><span class="hljs-built_in">erase</span>(const_iterator pos); <span class="hljs-comment">// 删除位置pos的元素</span><br><br><span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 删除容器中的所有元素</span><br></code></pre></td></tr></table></figure><h2 id="双向队列deque"><a class="markdownIt-Anchor" href="#双向队列deque"></a> 双向队列(deque)</h2><p>vector是单向开口的连续内存空间，而deque是双向开口的连续线性空间：</p><ol><li><p>deque在头部尾部插入删除元素都都是使用常数项时间</p></li><li><p>deque是动态的分段连续空间组合而成，随时可以增加新空间链接起来</p></li></ol><p>deque虽然也支持随机访问，但实现较复杂，需要随机访问最好用vector。</p><img src="../imgs/202502191823124.png" alt="" style="zoom: 50%;" /><h3 id="常用api-3"><a class="markdownIt-Anchor" href="#常用api-3"></a> 常用API</h3><ul><li>构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;T&gt; deqT; <span class="hljs-comment">// 默认构造函数</span><br><span class="hljs-built_in">deque</span>(beg, end); <span class="hljs-comment">// 构造函数将[beg, end)区间中的元素拷贝给本身</span><br><span class="hljs-built_in">deque</span>(<span class="hljs-type">int</span> n, T elem); <span class="hljs-comment">// 构造函数将n个elem拷贝给本身</span><br><span class="hljs-built_in">deque</span>(<span class="hljs-type">const</span> deque&amp; deq); <span class="hljs-comment">// 拷贝构造函数</span><br></code></pre></td></tr></table></figure><ul><li>赋值操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">assign</span>(beg, end); <span class="hljs-comment">// 将[beg, end)区间中的元素拷贝赋值给本身</span><br><span class="hljs-built_in">assign</span>(<span class="hljs-type">int</span> n, T elem); <span class="hljs-comment">// 将n个元素elem拷贝赋值给本身</span><br><br>deque&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> deque&amp; deq); <span class="hljs-comment">// 重载赋值操作符</span><br><br><span class="hljs-built_in">swap</span>(deq); <span class="hljs-comment">// 将deq与本身的元素互换</span><br></code></pre></td></tr></table></figure><ul><li>大小操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回容器中元素的个数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 判断容器是否为空</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>; <br><span class="hljs-comment">// 重新指定容器的长度为num，若容器变长，则以默认值填充新位置，</span><br><span class="hljs-comment">// 如果容器变短，则末尾超出容器长度的元素被删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> num, T elem)</span></span>;<br><span class="hljs-comment">// 重新指定容器的长度为num，若容器变长，则以elem填充新位置，</span><br><span class="hljs-comment">// 如果容器变短，则末尾超出容器长度的元素被删除</span><br></code></pre></td></tr></table></figure><ul><li>双端插入和删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">push_back</span>(T elem); <span class="hljs-comment">// 在容器尾部添加一个元素</span><br><span class="hljs-built_in">push_front</span>(T elem); <span class="hljs-comment">// 在容器头部插入一个元素</span><br><br><span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 删除容器最后一个数据</span><br><span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">// 删除容器第一个数据</span><br></code></pre></td></tr></table></figure><ul><li>数据存取</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">T&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span>; <span class="hljs-comment">// 返回索引idx所指的数据，如果idx越界，抛出out_of_range异常</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> idx); <span class="hljs-comment">// 返回索引idx所指的数据，如果idx越界，运行直接报错</span><br><br><span class="hljs-function">T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回首元素的引用</span><br><span class="hljs-function">T&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回尾元素的引用</span><br></code></pre></td></tr></table></figure><ul><li>插入操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">const_iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, T elem)</span></span>; <br><span class="hljs-comment">// 在pos位置处插入元素elem的拷贝，返回新数据的位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, <span class="hljs-type">int</span> n, T elem)</span></span>; <br><span class="hljs-comment">// 在pos位置插入n个元素elem，无返回值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(pos, beg, end)</span></span>;<br><span class="hljs-comment">// 将[beg, end)区间内的元素插到位置pos，无返回值</span><br></code></pre></td></tr></table></figure><ul><li>删除操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 移除容器的所有数据</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator beg, iterator end)</span></span>;<br><span class="hljs-comment">// 删除区间[beg, end)的数据，返回下一个数据的位置</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator pos)</span>；</span><br><span class="hljs-function"><span class="hljs-comment">// 删除pos位置的数据，返回下一个数据的位置</span></span><br></code></pre></td></tr></table></figure><h2 id="栈stack"><a class="markdownIt-Anchor" href="#栈stack"></a> 栈(stack)</h2><p>不允许遍历行为，不提供迭代器！</p><h3 id="常用api-4"><a class="markdownIt-Anchor" href="#常用api-4"></a> 常用API</h3><ul><li>构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;T&gt; stkT; <span class="hljs-comment">// 默认构造函数，stack采用模版类实现</span><br><span class="hljs-built_in">stack</span>(<span class="hljs-type">const</span> stack&amp; stk); <span class="hljs-comment">// 拷贝构造函数</span><br></code></pre></td></tr></table></figure><ul><li>赋值操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> stack&amp; stk); <span class="hljs-comment">// 重载赋值操作符</span><br></code></pre></td></tr></table></figure><ul><li>数据存取操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T elem)</span></span>; <span class="hljs-comment">// 向栈顶添加元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 从栈顶移除第一个元素</span><br><span class="hljs-function">T&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回栈顶元素</span><br></code></pre></td></tr></table></figure><ul><li>大小操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 判断堆栈是否为空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回栈的大小</span><br></code></pre></td></tr></table></figure><h2 id="队列queue"><a class="markdownIt-Anchor" href="#队列queue"></a> 队列(queue)</h2><p>先进先出，从队头pop，从队尾push<img src="../imgs/202501191633690.png" alt="" style="zoom: 67%;" /></p><div class="note note-danger">            <p>外界只会访问queue的顶端元素，queue不提供遍历功能，因此没有迭代器</p><p>queue中的元素在内存中不一定连续</p>          </div><h3 id="常用api-5"><a class="markdownIt-Anchor" href="#常用api-5"></a> 常用API</h3><ul><li>queue 构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;T&gt; queT; <span class="hljs-comment">// queue对象的默认构造函数形式，采用模版类实现</span><br><span class="hljs-built_in">queue</span>(<span class="hljs-type">const</span> queue&amp; que); <span class="hljs-comment">// 拷贝构造函数</span><br></code></pre></td></tr></table></figure><ul><li>queue 存取、插入和删除操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T elem)</span></span>; <span class="hljs-comment">// 往队尾添加元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 从队头移除第一个元素</span><br><span class="hljs-function">T&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回最后一个元素</span><br><span class="hljs-function">T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回第一个元素</span><br></code></pre></td></tr></table></figure><ul><li>queue 赋值操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> queue&amp; que); <span class="hljs-comment">// 重载赋值操作符</span><br></code></pre></td></tr></table></figure><ul><li>queue 大小操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回队列的大小</span><br></code></pre></td></tr></table></figure><h2 id="链表list"><a class="markdownIt-Anchor" href="#链表list"></a> 链表(list)</h2><p>list容器是一个<strong>循环的双向链表</strong>。</p><p>链表对于任意位置插入或删除都是常数项时间。</p><h3 id="常用api-6"><a class="markdownIt-Anchor" href="#常用api-6"></a> 常用API</h3><ul><li>构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;T&gt; lstT; <span class="hljs-comment">// 默认构造形式，list采用模版类实现</span><br><span class="hljs-built_in">list</span>(beg, end); <span class="hljs-comment">// 构造函数将[beg, end)区间内的元素拷贝给本身</span><br><span class="hljs-built_in">list</span>(<span class="hljs-type">int</span> n, T elem); <span class="hljs-comment">// 构造函数将n个elem拷贝给本身</span><br><span class="hljs-built_in">list</span>(<span class="hljs-type">const</span> list&amp; lst); <span class="hljs-comment">// 拷贝构造函数</span><br></code></pre></td></tr></table></figure><ul><li>数据元素插入和删除操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T elem)</span></span>; <span class="hljs-comment">// 在容器尾部加入一个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 删除容器中最后一个元素</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(T elem)</span></span>; <span class="hljs-comment">// 在容器开头插入一个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 从容器开头移除第一个元素</span><br><br><span class="hljs-built_in">insert</span>(iterator pos, elem); <span class="hljs-comment">// 在pos位置插入elem元素的拷贝，返回新数据的位置</span><br><span class="hljs-built_in">insert</span>(iterator pos, n, elem); <span class="hljs-comment">// 在pos位置插入n个elem元素的拷贝，无返回值</span><br><span class="hljs-built_in">insert</span>(iterator pos, beg, end); <span class="hljs-comment">// 在pos位置插入[beg, end)区间内的数据，无返回值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 移除容器的所有数据</span><br><br><span class="hljs-built_in">erase</span>(beg, end); <span class="hljs-comment">// 删除[beg, end)区间内的所有数据，返回下一个数据的位置</span><br><span class="hljs-built_in">erase</span>(pos); <span class="hljs-comment">// 删除pos位置的数据，返回下一个数据的位置</span><br><br><span class="hljs-built_in">remove</span>(elem); <span class="hljs-comment">// 删除容器中所有与elem匹配的元素</span><br></code></pre></td></tr></table></figure><ul><li>大小操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回容器中元素的个数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 判断容器是否为空</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>;<br><span class="hljs-comment">// 重新制定容器的长度为num，若容器变长，则以默认值填充新位置；</span><br><span class="hljs-comment">// 若容器变短，则末尾超出容器长度的元素被删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> num, T elem)</span></span>;<br><span class="hljs-comment">// 重新制定容器的长度为num，若容器变长，则以elem填充新位置；</span><br><span class="hljs-comment">// 若容器变短，则末尾超出容器长度的元素被删除</span><br></code></pre></td></tr></table></figure><ul><li>赋值操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">assign</span>(beg, end); <span class="hljs-comment">// 将[beg, end)区间中的数据拷贝赋值给本身</span><br><span class="hljs-built_in">assign</span>(n, elem); <span class="hljs-comment">// 将n个elem拷贝赋值给本身</span><br><br>list&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> list&amp; lst); <span class="hljs-comment">// 重载等号操作符</span><br><br><span class="hljs-built_in">swap</span>(lst); <span class="hljs-comment">// 将lst与本身的元素互换</span><br></code></pre></td></tr></table></figure><ul><li>数据的存取</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回第一个元素</span><br><span class="hljs-function">T&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回最后一个元素</span><br></code></pre></td></tr></table></figure><ul><li>反转排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 反转链表</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 默认list排序，规则为从小到大</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">bool</span> (*cmp)(T item1, T item2))</span></span>; <span class="hljs-comment">// 指定排序规则的list排序</span><br><br><span class="hljs-comment">// 不能用sort(lst.begin(), lst.end())</span><br><span class="hljs-comment">// 因为所有系统提供的某些算法（比如排序），其迭代器必须支持随机访问</span><br><span class="hljs-comment">// 不支持随机访问的迭代器的容器，容器本身会对应提供相应的算法的接口</span><br></code></pre></td></tr></table></figure><h2 id="集合setmultiset"><a class="markdownIt-Anchor" href="#集合setmultiset"></a> 集合(set/multiset)</h2><p>set和multiset的底层实现是红黑树</p><p>不可以通过set的迭代器改变set元素的值，因为其元素值就是key值，随意改变会破坏set组织，因此set的iterator是<code>const_iterator</code>。</p><h3 id="常用api-7"><a class="markdownIt-Anchor" href="#常用api-7"></a> 常用API</h3><ul><li>构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;T&gt; st; <span class="hljs-comment">// set 默认构造函数</span><br>multiset&lt;T&gt; mst; <span class="hljs-comment">// multiset 默认构造函数</span><br><span class="hljs-built_in">set</span>(<span class="hljs-type">const</span> set&amp; st); <span class="hljs-comment">// 拷贝构造函数</span><br></code></pre></td></tr></table></figure><ul><li>赋值操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> set&amp; st); <span class="hljs-comment">// 重载等号操作符</span><br><br><span class="hljs-built_in">swap</span>(st); <span class="hljs-comment">// 交换两个集合容器</span><br></code></pre></td></tr></table></figure><ul><li>大小操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回容器中元素的数目</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 判断容器是否为空</span><br></code></pre></td></tr></table></figure><ul><li>插入和删除操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert</span><span class="hljs-params">(T elem)</span></span>; <br><span class="hljs-comment">// 在容器中插入元素，返回插入位置的迭代器（不成功则返回end()）和是否插入成功</span><br><span class="hljs-comment">// 如果是multiset，则返回值只有iterator</span><br><span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清除所有元素</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(pos)</span></span>; <span class="hljs-comment">// 删除pos迭代器所指的元素，返回下一个元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(beg, end)</span></span>; <span class="hljs-comment">// 删除区间[beg, end)内的所有元素，返回下一个元素的迭代器</span><br><span class="hljs-built_in">erase</span>(T elem); <span class="hljs-comment">// 删除容器中值为elem的元素</span><br></code></pre></td></tr></table></figure><p>插入之前可以指定排序规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//利用仿函数 指定set容器的排序规则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> v1 &gt; v2;<br>    &#125;<br>&#125;;<br><br>set&lt;<span class="hljs-type">int</span>, MyCompare&gt; s;<br><br><span class="hljs-comment">//模版类也是可以有默认值的，第二个模版参数的默认值为less</span><br></code></pre></td></tr></table></figure><blockquote><p>自定义的数据类型需要指出排序规则。</p><p>当然，也可以通过重载小于操作符的方式指出。</p></blockquote><ul><li>查找操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(T key)</span></span>; <br><span class="hljs-comment">// 查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(T key)</span></span>;<br><span class="hljs-comment">// 查找键key的元素个数</span><br><span class="hljs-function">iterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(T keyElem)</span></span>;<br><span class="hljs-comment">// 返回第一个key&gt;=keyElem元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">upper_bound</span><span class="hljs-params">(T keyElem)</span></span>;<br><span class="hljs-comment">// 返回第一个key&gt;keyElem元素的迭代器</span><br><span class="hljs-function">pair&lt;iterator, iterator&gt; <span class="hljs-title">equal_range</span><span class="hljs-params">(T keyElem)</span></span>;<br><span class="hljs-comment">// 返回容器中key与keyElem上相等的两个上下限迭代器</span><br></code></pre></td></tr></table></figure><blockquote><p>上述几个方法若不存在，返回值都是尾迭代器。</p></blockquote><p>对组的构造和使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造</span><br><span class="hljs-function">pair&lt;T1, T2&gt; <span class="hljs-title">p</span><span class="hljs-params">(k, v)</span></span>;<br><span class="hljs-comment">//另一种构造方式</span><br>pair&lt;T1, T2&gt; p = <span class="hljs-built_in">make_pair</span>(k, v);<br><span class="hljs-comment">//使用</span><br>cout &lt;&lt; p.first &lt;&lt; p.second &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="映射mapmultimap"><a class="markdownIt-Anchor" href="#映射mapmultimap"></a> 映射(map/multimap)</h2><p>map和multimap的底层实现是红黑树</p><h3 id="常用api-8"><a class="markdownIt-Anchor" href="#常用api-8"></a> 常用API</h3><ul><li>map 构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;T1, T2&gt; mapTT; <span class="hljs-comment">// map默认构造函数</span><br><span class="hljs-built_in">map</span>(<span class="hljs-type">const</span> map&amp; mp); <span class="hljs-comment">// 拷贝构造函数</span><br></code></pre></td></tr></table></figure><ul><li>map 赋值操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> map&amp; mp); <span class="hljs-comment">// 重载等号操作符</span><br><span class="hljs-built_in">swap</span>(mp); <span class="hljs-comment">// 交换两个集合容器</span><br></code></pre></td></tr></table></figure><ul><li>map 大小操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回容器中元素的数目</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 判断容器是否为空</span><br></code></pre></td></tr></table></figure><ul><li>map 插入元素操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert</span><span class="hljs-params">(pair&lt;T1, T2&gt; p)</span></span>; <span class="hljs-comment">// 通过pair的方式插入对象</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 参数部分可以用pair的构造函数创建匿名对象</span><br><span class="hljs-comment">2. 也可以使用make_pair创建pair对象</span><br><span class="hljs-comment">3. 还可以用map&lt;T1, T2&gt;::value_type(key, value)来实现</span><br><span class="hljs-comment">*/</span><br><br>T2&amp; <span class="hljs-keyword">operator</span>[](T1 key); <span class="hljs-comment">// 通过下标的方式插入值</span><br><span class="hljs-comment">// 如果通过下标访问新的键却没有赋值，会自动用默认值填充</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;string, <span class="hljs-type">int</span>&gt; myMap;<br><span class="hljs-comment">// 直接使用pair构造函数</span><br>myMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>));<br><span class="hljs-comment">// 使用make_pair函数</span><br>myMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">3</span>));<br><span class="hljs-comment">// 使用value_type</span><br>myMap.<span class="hljs-built_in">insert</span>(map&lt;string, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>map指定排序规则的方式和set类似，都是利用functor在模版类型表的最后一个参数处指定。</p>          </div><ul><li>map 删除操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 删除所有元素</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator pos)</span></span>; <span class="hljs-comment">// 删除pos迭代器所指的元素，返回下一个元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(beg, end)</span></span>; <span class="hljs-comment">// 删除区间[beg, end)内的所有元素，返回下一个元素的迭代器</span><br><span class="hljs-built_in">erase</span>(keyElem); <span class="hljs-comment">// 删除容器中key为keyElem的对组</span><br></code></pre></td></tr></table></figure><ul><li>map 查找操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(T1 key)</span></span>; <br><span class="hljs-comment">// 查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end()</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(T1 keyElem)</span></span>;<br><span class="hljs-comment">// 返回容器中key为keyElem的对组个数，对map来说只可能是0或1，对于multimap可能大于1</span><br><br><span class="hljs-function">iterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(T keyElem)</span></span>;<br><span class="hljs-comment">// 返回第一个key&gt;=keyElem元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">upper_bound</span><span class="hljs-params">(T keyElem)</span></span>;<br><span class="hljs-comment">// 返回第一个key&gt;keyElem元素的迭代器</span><br><span class="hljs-function">pair&lt;iterator, iterator&gt; <span class="hljs-title">equal_range</span><span class="hljs-params">(T keyElem)</span></span>;<br><span class="hljs-comment">// 返回容器中key与keyElem上相等的两个上下限迭代器</span><br></code></pre></td></tr></table></figure><h2 id="优先级队列priority_queue"><a class="markdownIt-Anchor" href="#优先级队列priority_queue"></a> 优先级队列(priority_queue)</h2><p>优先级队列的底层实现是最小/最大二叉堆</p><h3 id="常用api-9"><a class="markdownIt-Anchor" href="#常用api-9"></a> 常用API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++中的优先队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-comment">// 创建最大堆(默认)</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; maxHeap;<br><span class="hljs-comment">// 创建最小堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br><span class="hljs-comment">// greater表示大的元素会放在小的元素下方，堆顶是最小的元素</span><br><br><span class="hljs-comment">// 主要操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span></span>;  <span class="hljs-comment">// 插入元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;                         <span class="hljs-comment">// 删除堆顶元素</span><br><span class="hljs-function">value_type <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 访问堆顶元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                 <span class="hljs-comment">// 检查队列是否为空</span><br><span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 返回队列中的元素数量</span><br></code></pre></td></tr></table></figure><h3 id="自定义优先级"><a class="markdownIt-Anchor" href="#自定义优先级"></a> 自定义优先级</h3><ol><li>自定义比较函数对象（仿函数）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 自定义比较类</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomCompare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br>        <span class="hljs-comment">// 自定义比较逻辑</span><br>        <span class="hljs-keyword">return</span> a % <span class="hljs-number">10</span> &gt; b % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 按个位数字从小到大排序</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用自定义比较器</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, CustomCompare&gt; customPQ;<br></code></pre></td></tr></table></figure><ol start="2"><li>对于自定义类型，重载比较运算符</li></ol><p>注意构建最大堆需要重载的是小于运算符，较小的放较大的下面，堆顶是最大的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> priority;<br>    <br>    <span class="hljs-comment">// 重载小于运算符（用于最大堆）</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Task&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> priority &lt; other.priority;  <span class="hljs-comment">// 优先级高的先出队</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 默认是最大堆，会使用operator</span><br>priority_queue&lt;Task&gt; taskQueue;<br><br><span class="hljs-comment">// 如果要创建最小堆，需要反转比较逻辑</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ReverseCompare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Task&amp; a, <span class="hljs-type">const</span> Task&amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.priority &gt; b.priority;<br>    &#125;<br>&#125;;<br>priority_queue&lt;Task, vector&lt;Task&gt;, ReverseCompare&gt; minTaskQueue;<br></code></pre></td></tr></table></figure><h2 id="无序容器unordered_"><a class="markdownIt-Anchor" href="#无序容器unordered_"></a> 无序容器(<code>unordered_*</code>)</h2><p>无序容器包括：<code>unordered_map</code>、<code>unordered_multimap</code>、<code>unordered_set</code>、<code>unordered_multiset</code></p><h3 id="无序容器-vs-有序容器"><a class="markdownIt-Anchor" href="#无序容器-vs-有序容器"></a> 无序容器 vs 有序容器</h3><ol><li><p>无序容器的底层实现是哈希表，有序容器的实现是红黑树</p></li><li><p>哈希表的插入/查找/删除的平均时间复杂度都是O(1)，但最坏时间复杂度是O(n)（哈希冲突严重时）</p><p>红黑树插入/查找/删除的平均和最坏时间复杂度都是O(log n)</p></li><li><p>无序容器通常消耗更多的内存，但在平均情况下查找/插入/删除更快速</p><p>有序容器用在需要对元素排序时，能保证稳定的最坏情况性能，相对节省内存空间</p></li></ol><h1 id="函数对象仿函数functor"><a class="markdownIt-Anchor" href="#函数对象仿函数functor"></a> 函数对象/仿函数(Functor)</h1><h2 id="适配器"><a class="markdownIt-Anchor" href="#适配器"></a> 适配器</h2><h3 id="函数对象适配器"><a class="markdownIt-Anchor" href="#函数对象适配器"></a> 函数对象适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>: <span class="hljs-keyword">public</span> binary_function&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">void</span>&gt; <br><span class="hljs-comment">// 2.做继承 参数1类型 + 参数2类型 + 返回值类型 binary_function</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> base)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 3. 加const, 和父类保持一致</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; val + base &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) v.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">myPrint</span>(), n)); <br>    <span class="hljs-comment">// 1. 将参数进行绑定 bind2nd</span><br>    <span class="hljs-comment">// bind1st 功能类似，不过n会被绑定到第一个参数中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="取反适配器"><a class="markdownIt-Anchor" href="#取反适配器"></a> 取反适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterThanFive</span>: <span class="hljs-keyword">public</span> unary_function&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; <br><span class="hljs-comment">// 2. 做继承 参数类型 + 返回值类型 unary_function</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 3.加 const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) v.<span class="hljs-built_in">push_back</span>(i);<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">not1</span>(<span class="hljs-built_in">GreaterThanFive</span>()));  <span class="hljs-comment">//1. 一元取反 not1</span><br>    <br>    <span class="hljs-keyword">if</span> (pos != v.<span class="hljs-built_in">end</span>()) cout &lt;&lt; *pos &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者用更简便的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">not1</span>(<span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">5</span>)));<br></code></pre></td></tr></table></figure><h3 id="函数指针适配器"><a class="markdownIt-Anchor" href="#函数指针适配器"></a> 函数指针适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">ptr_fun</span>(myPrint), n));<br><span class="hljs-comment">// 函数指针适配器 ptr_fun 将函数指针适配成仿函数</span><br></code></pre></td></tr></table></figure><h3 id="成员函数适配器"><a class="markdownIt-Anchor" href="#成员函数适配器"></a> 成员函数适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun_ref</span>(&amp;Dog::bark));<br><span class="hljs-comment">// 成员函数适配器 mem_fun_ref</span><br><span class="hljs-comment">// 如果容器中存放的不是对象实体，而是对象指针时，则需使用 ptr_fun</span><br></code></pre></td></tr></table></figure><h2 id="偏函数"><a class="markdownIt-Anchor" href="#偏函数"></a> 偏函数</h2><p>对于一个多参数的函数，在某些应用场景下，它的一些参数往往取固定值，可以针对这样的函数，生成一个新函数，该新函数不包含原函数中已指定固定值的参数。</p><p>例如，对于下面的print函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> base)</span></span>; <span class="hljs-comment">// 按base进制来输出n</span><br></code></pre></td></tr></table></figure><p>由于它常常用来按十进制输出，因此，可以基于print生成一个新函数print10，只接受一个参数n，base固定为10：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br><br>function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; print10 = <span class="hljs-built_in">bind</span>(print, _1, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">print10</span>(<span class="hljs-number">23</span>); <span class="hljs-comment">//相当于 print(23, 10)</span><br></code></pre></td></tr></table></figure><h1 id="算法algorithm-2"><a class="markdownIt-Anchor" href="#算法algorithm-2"></a> 算法(Algorithm)</h1><p>自定义的类如果想直接使用算法库，则需补全默认构造函数、拷贝构造函数、析构函数、赋值操作符、小于操作符、等于操作符。</p><h2 id="遍历算法"><a class="markdownIt-Anchor" href="#遍历算法"></a> 遍历算法</h2><h3 id="for_each"><a class="markdownIt-Anchor" href="#for_each"></a> <code>for_each</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 遍历算法 遍历容器元素</span><br><span class="hljs-comment">  * @param beg 开始迭代器</span><br><span class="hljs-comment">  * @param end 结束迭代器</span><br><span class="hljs-comment">  * @param _callback 函数回调或者函数对象</span><br><span class="hljs-comment">  * @return 函数对象</span><br><span class="hljs-comment">*/</span><br>for_each(iterator beg, iterator end, _callback);<br></code></pre></td></tr></table></figure><h3 id="transform"><a class="markdownIt-Anchor" href="#transform"></a> <code>transform</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * transform算法 将指定容器内的元素搬运到另一个容器中</span><br><span class="hljs-comment">  * 注意：transform不会给目标容器分配内存，所以需要我们提前分配好内存</span><br><span class="hljs-comment">  * @param beg1 源容器开始迭代器</span><br><span class="hljs-comment">  * @param end1 源容器结束迭代器</span><br><span class="hljs-comment">  * @param beg2 目标容器开始迭代器</span><br><span class="hljs-comment">  * @param _callback 回调函数或者函数对象</span><br><span class="hljs-comment">  * @return 返回目标容器迭代器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">iterator <span class="hljs-title">transform</span><span class="hljs-params">(iterator beg1, iterator end1, iterator beg2, _callback)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="查找算法"><a class="markdownIt-Anchor" href="#查找算法"></a> 查找算法</h2><h3 id="find"><a class="markdownIt-Anchor" href="#find"></a> <code>find</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * find 算法 查找元素</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param value 查找的元素</span><br><span class="hljs-comment">  * @return 返回查找元素的位置</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(iterator beg, iterator end, value)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="find_if"><a class="markdownIt-Anchor" href="#find_if"></a> <code>find_if</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * find_if 算法 条件查找</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param _callback 回调函数或者谓词(返回 bool 类型的函数对象)</span><br><span class="hljs-comment">  * @return 返回查找元素的位置</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">iterator <span class="hljs-title">find_if</span><span class="hljs-params">(iterator beg, iterator end, _callback)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>利用find_if实现自定义类的find操作的时候，之前的函数适配器可能会派上用场。</p></blockquote><h3 id="adjacent_find"><a class="markdownIt-Anchor" href="#adjacent_find"></a> <code>adjacent_find</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * adjacent_find 算法 查找相邻重复元素</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param _callback 回调函数或者谓词(返回 bool 类型的函数对象)</span><br><span class="hljs-comment">  * @return 返回相邻元素的第一个位置的迭代器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">iterator <span class="hljs-title">adjacent_find</span><span class="hljs-params">(iterator beg, iterator end, _callback)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="binary_search"><a class="markdownIt-Anchor" href="#binary_search"></a> <code>binary_search</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * binary_search 算法 二分法查找</span><br><span class="hljs-comment">  * 注意：在无序序列中不可用</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param value 查找的元素</span><br><span class="hljs-comment">  * @return bool 查找返回true，否则false</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(iterator beg, iterator end, value)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="count"><a class="markdownIt-Anchor" href="#count"></a> <code>count</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * count 算法 统计元素出现次数</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param value 待计数的元素</span><br><span class="hljs-comment">  * @return int 返回元素个数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(iterator beg, iterator end, value)</span></span>; <br></code></pre></td></tr></table></figure><h3 id="count_if"><a class="markdownIt-Anchor" href="#count_if"></a> <code>count_if</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * count_if 算法 统计元素出现次数</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param _callback 回调函数或者谓词</span><br><span class="hljs-comment">  * @return int 返回元素个数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_if</span><span class="hljs-params">(iterator beg, iterator end, _callback)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="排序算法"><a class="markdownIt-Anchor" href="#排序算法"></a> 排序算法</h2><h3 id="merge"><a class="markdownIt-Anchor" href="#merge"></a> <code>merge</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * merge 算法 容器元素合并，并储存到另一个容器中</span><br><span class="hljs-comment">  * 注意：两个容器必须是有序的</span><br><span class="hljs-comment">  * @param beg1 容器1开始迭代器</span><br><span class="hljs-comment">  * @param end1 容器1结束迭代器</span><br><span class="hljs-comment">  * @param beg2 容器2开始迭代器</span><br><span class="hljs-comment">  * @param end2 容器2结束迭代器</span><br><span class="hljs-comment">  * @param dest 目标容器开始迭代器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">merge</span>(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);<br></code></pre></td></tr></table></figure><h3 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> <code>sort</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * sort 算法 容器元素排序</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param _callback 回调函数或者谓词</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">sort</span>(iterator beg, iterator end, _callback);<br></code></pre></td></tr></table></figure><h3 id="random_shuffle"><a class="markdownIt-Anchor" href="#random_shuffle"></a> <code>random_shuffle</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * random_shuffle 算法 对指定范围内的元素随机调整次序</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">random_shuffle</span>(iterator beg, iterator end);<br></code></pre></td></tr></table></figure><p>如果想要每次打乱不同，需要自己设置随机数种子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    ......<span class="hljs-comment">//random_shuffle</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> <code>reverse</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * reverse 算法 反转指定范围的元素</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">reverse</span>(iterator beg, iterator end);<br></code></pre></td></tr></table></figure><h2 id="拷贝和替换算法"><a class="markdownIt-Anchor" href="#拷贝和替换算法"></a> 拷贝和替换算法</h2><h3 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> <code>copy</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * copy算法 将容器内指定范围的元素拷贝到另一容器当中</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param dest 目标容器开始迭代器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">copy</span>(iterator beg, iterator end, iterator dest);<br></code></pre></td></tr></table></figure><p>使用copy算法快速打印容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> val)&#123;cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;);<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ostream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(cout, <span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-comment">// 需要#include &lt;iterator&gt;</span><br></code></pre></td></tr></table></figure><h3 id="replace"><a class="markdownIt-Anchor" href="#replace"></a> <code>replace</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * replace算法 将容器内指定范围的旧元素修改为新元素</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param oldvalue 旧元素</span><br><span class="hljs-comment">  * @param newvalue 新元素</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">replace</span>(inerator beg, iterator end, oldvalue, newvalue);<br></code></pre></td></tr></table></figure><h3 id="replace_if"><a class="markdownIt-Anchor" href="#replace_if"></a> <code>replace_if</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * replace_if 算法 将容器内指定范围满足条件的元素替换为新元素</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param _callback 回调函数或者谓词（返回bool类型的函数对象）</span><br><span class="hljs-comment">  * @param newvalue 新元素</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">replace_if</span>(inerator beg, inerator end, _callback, newvalue);<br></code></pre></td></tr></table></figure><h3 id="swap"><a class="markdownIt-Anchor" href="#swap"></a> <code>swap</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * swap 算法 互换两个容器元素</span><br><span class="hljs-comment">  * @param c1 容器1</span><br><span class="hljs-comment">  * @param c2 容器2</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">swap</span>(container c1, container c2);<br></code></pre></td></tr></table></figure><h2 id="算数生成算法"><a class="markdownIt-Anchor" href="#算数生成算法"></a> 算数生成算法</h2><h3 id="accumulate"><a class="markdownIt-Anchor" href="#accumulate"></a> <code>accumulate</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// 注意头文件不是algorithm了</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * accumulate 算法 计算容器元素累计总和</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param value 起始累加值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">accumulate</span>(iterator beg, iterator end, value);<br></code></pre></td></tr></table></figure><h3 id="fill"><a class="markdownIt-Anchor" href="#fill"></a> <code>fill</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * fill 算法</span><br><span class="hljs-comment">  * @param beg 容器开始迭代器</span><br><span class="hljs-comment">  * @param end 容器结束迭代器</span><br><span class="hljs-comment">  * @param value 填充元素</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">fill</span>(iterator beg, iterator end, value);<br></code></pre></td></tr></table></figure><h2 id="集合算法"><a class="markdownIt-Anchor" href="#集合算法"></a> 集合算法</h2><h3 id="set_intersection"><a class="markdownIt-Anchor" href="#set_intersection"></a> <code>set_intersection</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * set_intersection 算法 求两个set集合的交集</span><br><span class="hljs-comment">  * 注意：两个集合必须是有序序列</span><br><span class="hljs-comment">  * @param beg1 容器1开始迭代器</span><br><span class="hljs-comment">  * @param end1 容器1结束迭代器</span><br><span class="hljs-comment">  * @param beg2 容器2开始迭代器</span><br><span class="hljs-comment">  * @param end2 容器2结束迭代器</span><br><span class="hljs-comment">  * @param dest 目标容器开始迭代器</span><br><span class="hljs-comment">  * @return 目标容器最后一个元素的迭代器地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">set_intersection</span>(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);<br></code></pre></td></tr></table></figure><h3 id="set_union"><a class="markdownIt-Anchor" href="#set_union"></a> <code>set_union</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * set_union 算法 求两个set集合的并集</span><br><span class="hljs-comment">  * 注意：两个集合必须是有序序列</span><br><span class="hljs-comment">  * @param beg1 容器1开始迭代器</span><br><span class="hljs-comment">  * @param end1 容器1结束迭代器</span><br><span class="hljs-comment">  * @param beg2 容器2开始迭代器</span><br><span class="hljs-comment">  * @param end2 容器2结束迭代器</span><br><span class="hljs-comment">  * @param dest 目标容器开始迭代器</span><br><span class="hljs-comment">  * @return 目标容器最后一个元素的迭代器地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">set_union</span>(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);<br></code></pre></td></tr></table></figure><h3 id="set_difference"><a class="markdownIt-Anchor" href="#set_difference"></a> <code>set_difference</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * set_difference 算法 求两个set集合的差集</span><br><span class="hljs-comment">  * 注意：两个集合必须是有序序列</span><br><span class="hljs-comment">  * @param beg1 容器1开始迭代器</span><br><span class="hljs-comment">  * @param end1 容器1结束迭代器</span><br><span class="hljs-comment">  * @param beg2 容器2开始迭代器</span><br><span class="hljs-comment">  * @param end2 容器2结束迭代器</span><br><span class="hljs-comment">  * @param dest 目标容器开始迭代器</span><br><span class="hljs-comment">  * @return 目标容器最后一个元素的迭代器地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">set_difference</span>(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将Typora警告框转化成fluid便签</title>
    <link href="/2025/02/21/hexo-convert-note/"/>
    <url>/2025/02/21/hexo-convert-note/</url>
    
    <content type="html"><![CDATA[<h1 id="将typora警告框转化成fluid便签"><a class="markdownIt-Anchor" href="#将typora警告框转化成fluid便签"></a> 将Typora警告框转化成fluid便签</h1><p>我在使用fluid主题时遇到了一个hexo渲染与typora编辑器不兼容的问题：Typora的警告框不能够在hexo网页上实现渲染，需要先转换成fluid主题的便签格式。</p><p><img src="../imgs/image-20250221153222955.png" alt="Typora警告框" /></p><p><img src="../imgs/image-20250221153119015.png" alt="fluid便签" /></p><p>Typora中支持的警告框只能够在typora内部实现渲染，fluid不能将其自动转化为其便签的语法实现渲染，于是我让claude给我写了一个脚本将typora文章中的警告框语法转化成fluid主题的便签语法。</p><p><code>draft-to-post.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">#!/usr/bin/env node</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Hexo草稿转发布脚本</span><br><span class="hljs-comment"> * 将_drafts目录中的Typora格式Markdown文件转换为Hexo兼容格式并发布到_posts目录</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用方法: </span><br><span class="hljs-comment"> * node draft-to-post.js [文件名]</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 示例:</span><br><span class="hljs-comment"> * node draft-to-post.js            # 转换所有草稿</span><br><span class="hljs-comment"> * node draft-to-post.js article.md # 只转换特定文件</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">// 定义Hexo目录路径</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DRAFTS_DIR</span> = path.<span class="hljs-title function_">join</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;source&#x27;</span>, <span class="hljs-string">&#x27;_drafts&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">POSTS_DIR</span> = path.<span class="hljs-title function_">join</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;source&#x27;</span>, <span class="hljs-string">&#x27;_posts&#x27;</span>);<br><br><span class="hljs-comment">// 颜色映射关系</span><br><span class="hljs-keyword">const</span> alertTypeMap = &#123;<br>  <span class="hljs-string">&#x27;提醒内容&#x27;</span>: <span class="hljs-string">&#x27;info&#x27;</span>,      <span class="hljs-comment">// 蓝色</span><br>  <span class="hljs-string">&#x27;建议内容&#x27;</span>: <span class="hljs-string">&#x27;success&#x27;</span>,   <span class="hljs-comment">// 绿色</span><br>  <span class="hljs-string">&#x27;重要内容&#x27;</span>: <span class="hljs-string">&#x27;primary&#x27;</span>,   <span class="hljs-comment">// 紫色</span><br>  <span class="hljs-string">&#x27;警告内容&#x27;</span>: <span class="hljs-string">&#x27;warning&#x27;</span>,   <span class="hljs-comment">// 黄色</span><br>  <span class="hljs-string">&#x27;注意内容&#x27;</span>: <span class="hljs-string">&#x27;danger&#x27;</span>,    <span class="hljs-comment">// 红色</span><br>  <br>  <span class="hljs-string">&#x27;NOTE&#x27;</span>: <span class="hljs-string">&#x27;info&#x27;</span>,<br>  <span class="hljs-string">&#x27;TIP&#x27;</span>: <span class="hljs-string">&#x27;success&#x27;</span>,<br>  <span class="hljs-string">&#x27;IMPORTANT&#x27;</span>: <span class="hljs-string">&#x27;primary&#x27;</span>,<br>  <span class="hljs-string">&#x27;WARNING&#x27;</span>: <span class="hljs-string">&#x27;warning&#x27;</span>,<br>  <span class="hljs-string">&#x27;CAUTION&#x27;</span>: <span class="hljs-string">&#x27;danger&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将Typora警告框转换为Hexo Fluid便签</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">convertTyporaToHexoFluid</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-comment">// 1. 转换英文格式的警告框</span><br>  <span class="hljs-keyword">let</span> convertedContent = <span class="hljs-title function_">convertTyporaAlerts</span>(content);<br>  <br>  <span class="hljs-comment">// 2. 转换中文格式的提示框</span><br>  convertedContent = <span class="hljs-title function_">convertTyporaTips</span>(convertedContent);<br>  <br>  <span class="hljs-keyword">return</span> convertedContent;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换英文警告框</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">convertTyporaAlerts</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-keyword">const</span> typoraAlertRegex = <span class="hljs-regexp">/&gt;\s*\[!(NOTE|TIP|WARNING|IMPORTANT|CAUTION)\]([\s\S]*?)(?=&gt;\s*\[!|\n\s*\n|$)/g</span>;<br>  <br>  <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">replace</span>(typoraAlertRegex, <span class="hljs-function">(<span class="hljs-params">match, alertType, alertContent</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> noteType = alertTypeMap[alertType] || <span class="hljs-string">&#x27;info&#x27;</span>;<br>    <br>    <span class="hljs-keyword">const</span> cleanedContent = alertContent<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> line.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s*&gt;\s?/</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br>      .<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>      .<span class="hljs-title function_">trim</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;% note <span class="hljs-subst">$&#123;noteType&#125;</span> %&#125;\n<span class="hljs-subst">$&#123;cleanedContent&#125;</span>\n&#123;% endnote %&#125;`</span>;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换中文提示框</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">convertTyporaTips</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-keyword">const</span> typoCnTipRegex = <span class="hljs-regexp">/&gt;\s*(提醒内容|建议内容|重要内容|警告内容|注意内容)[：:]([\s\S]*?)(?=&gt;\s*(?:提醒内容|建议内容|重要内容|警告内容|注意内容)[：:]|\n\s*\n|$)/g</span>;<br>  <br>  <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">replace</span>(typoCnTipRegex, <span class="hljs-function">(<span class="hljs-params">match, tipType, tipContent</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> noteType = alertTypeMap[tipType] || <span class="hljs-string">&#x27;info&#x27;</span>;<br>    <br>    <span class="hljs-keyword">const</span> cleanedContent = tipContent<br>      .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> line.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s*&gt;\s?/</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br>      .<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>      .<span class="hljs-title function_">trim</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;% note <span class="hljs-subst">$&#123;noteType&#125;</span> %&#125;\n<span class="hljs-subst">$&#123;cleanedContent&#125;</span>\n&#123;% endnote %&#125;`</span>;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 确保文件包含有效的Front Matter</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureFrontMatter</span>(<span class="hljs-params">content, fileName</span>) &#123;<br>  <span class="hljs-comment">// 检查文件是否已有Front Matter</span><br>  <span class="hljs-keyword">if</span> (content.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;---\n&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">return</span> content;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 从文件名生成标题</span><br>  <span class="hljs-keyword">const</span> title = path.<span class="hljs-title function_">basename</span>(fileName, path.<span class="hljs-title function_">extname</span>(fileName))<br>                    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/-/g</span>, <span class="hljs-string">&#x27; &#x27;</span>)<br>                    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\b\w/g</span>, <span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> l.<span class="hljs-title function_">toUpperCase</span>());<br>  <br>  <span class="hljs-comment">// 获取当前日期</span><br>  <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  <span class="hljs-keyword">const</span> dateStr = now.<span class="hljs-title function_">toISOString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;T&#x27;</span>)[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">const</span> timeStr = now.<span class="hljs-title function_">toTimeString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>];<br>  <br>  <span class="hljs-comment">// 创建基本Front Matter</span><br>  <span class="hljs-keyword">const</span> frontMatter = <span class="hljs-string">`---</span><br><span class="hljs-string">title: <span class="hljs-subst">$&#123;title&#125;</span></span><br><span class="hljs-string">date: <span class="hljs-subst">$&#123;dateStr&#125;</span> <span class="hljs-subst">$&#123;timeStr&#125;</span></span><br><span class="hljs-string">tags:</span><br><span class="hljs-string">categories:</span><br><span class="hljs-string">---</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span>;<br><br>  <span class="hljs-keyword">return</span> frontMatter + content;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理单个文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processDraft</span>(<span class="hljs-params">fileName</span>) &#123;<br>  <span class="hljs-keyword">const</span> draftPath = path.<span class="hljs-title function_">join</span>(<span class="hljs-variable constant_">DRAFTS_DIR</span>, fileName);<br>  <span class="hljs-keyword">const</span> postPath = path.<span class="hljs-title function_">join</span>(<span class="hljs-variable constant_">POSTS_DIR</span>, fileName);<br>  <br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理草稿: <span class="hljs-subst">$&#123;fileName&#125;</span>`</span>);<br>    <br>    <span class="hljs-comment">// 读取草稿内容</span><br>    <span class="hljs-keyword">let</span> content = fs.<span class="hljs-title function_">readFileSync</span>(draftPath, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br>    <br>    <span class="hljs-comment">// 确保Front Matter存在</span><br>    content = <span class="hljs-title function_">ensureFrontMatter</span>(content, fileName);<br>    <br>    <span class="hljs-comment">// 转换便签</span><br>    <span class="hljs-keyword">const</span> convertedContent = <span class="hljs-title function_">convertTyporaToHexoFluid</span>(content);<br>    <br>    <span class="hljs-comment">// 检查_posts目录是否存在</span><br>    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(<span class="hljs-variable constant_">POSTS_DIR</span>)) &#123;<br>      fs.<span class="hljs-title function_">mkdirSync</span>(<span class="hljs-variable constant_">POSTS_DIR</span>, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 写入转换后的内容到_posts目录</span><br>    fs.<span class="hljs-title function_">writeFileSync</span>(postPath, convertedContent, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✓ 已发布: <span class="hljs-subst">$&#123;fileName&#125;</span> (draft → post)`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`❌ 处理文件时出错: <span class="hljs-subst">$&#123;fileName&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">` - <span class="hljs-subst">$&#123;error.message&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查目录是否存在并创建</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureDirectoryExists</span>(<span class="hljs-params">dir</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(dir)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`创建目录: <span class="hljs-subst">$&#123;dir&#125;</span>`</span>);<br>    fs.<span class="hljs-title function_">mkdirSync</span>(dir, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 确保目录存在</span><br>  <span class="hljs-title function_">ensureDirectoryExists</span>(<span class="hljs-variable constant_">DRAFTS_DIR</span>);<br>  <span class="hljs-title function_">ensureDirectoryExists</span>(<span class="hljs-variable constant_">POSTS_DIR</span>);<br>  <br>  <span class="hljs-keyword">const</span> args = process.<span class="hljs-property">argv</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">let</span> targetFiles = [];<br>  <br>  <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 处理指定的文件</span><br>    targetFiles = args.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 如果用户没有提供.md后缀，添加上</span><br>      <span class="hljs-keyword">return</span> file.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.md&#x27;</span>) ? file : <span class="hljs-string">`<span class="hljs-subst">$&#123;file&#125;</span>.md`</span>;<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 处理所有草稿</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      targetFiles = fs.<span class="hljs-title function_">readdirSync</span>(<span class="hljs-variable constant_">DRAFTS_DIR</span>)<br>        .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.md&#x27;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`❌ 无法读取草稿目录: <span class="hljs-subst">$&#123;DRAFTS_DIR&#125;</span>`</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>      process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (targetFiles.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`⚠️ 没有找到要处理的Markdown文件（在 <span class="hljs-subst">$&#123;DRAFTS_DIR&#125;</span>）`</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;🚀 开始将草稿转换为发布文章&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📂 草稿目录: <span class="hljs-subst">$&#123;DRAFTS_DIR&#125;</span>`</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📂 发布目录: <span class="hljs-subst">$&#123;POSTS_DIR&#125;</span>`</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📄 要处理的文件: <span class="hljs-subst">$&#123;targetFiles.length&#125;</span>个`</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">let</span> successCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> failCount = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 处理每个文件</span><br>  targetFiles.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fileName</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">processDraft</span>(fileName)) &#123;<br>      successCount++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      failCount++;<br>    &#125;<br>  &#125;);<br>  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;✅ 转换完成!&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">` - 成功: <span class="hljs-subst">$&#123;successCount&#125;</span>个文件`</span>);<br>  <span class="hljs-keyword">if</span> (failCount &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">` - 失败: <span class="hljs-subst">$&#123;failCount&#125;</span>个文件`</span>);<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;💡 提示: 现在可以运行 &quot;hexo g&quot; 来生成站点&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 运行主函数</span><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p>注意这个脚本会修改原始的typora文章中的警告框语法，破坏原先的文本内容，并且修改后的语法将无法在typora中渲染出效果。我的方案是在<code>source/</code>目录下与<code>_posts/</code>文件夹平行创建一个<code>_drafts/</code>文件夹，将原始的typora文章放在<code>_drafts/</code>目录下，上面的脚本运行后会在<code>_posts/</code>目录下生成新的包含fluid主题的便签语法，即hexo兼容格式的文章（发布文件），原始的typora文章还会在<code>_drafts/</code>目录下保持原样。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hexo_code/<br>├── source/<br>│   ├── _drafts/    &lt;- 存放原始Typora文件<br>│   │   ├── article1<span class="hljs-selector-class">.md</span><br>│   │   └── article2<span class="hljs-selector-class">.md</span><br>│   │<br>│   └── _posts/     &lt;- 存放转换后的发布文件<br>│       ├── article1<span class="hljs-selector-class">.md</span><br>│       └── article2<span class="hljs-selector-class">.md</span><br>├── themes/<br>├── _config<span class="hljs-selector-class">.yml</span><br>└── ...<br></code></pre></td></tr></table></figure><p>在<code>hexo g</code>之前运行脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node draft-to-post.js            # 转换所有草稿<br>node draft-to-post.js article.md # 只转换特定文件<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo解析图片路径</title>
    <link href="/2025/02/20/hexo-blog/"/>
    <url>/2025/02/20/hexo-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo解析图片路径"><a class="markdownIt-Anchor" href="#hexo解析图片路径"></a> hexo解析图片路径</h1><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">hexo-code/<br>├── source/<br>│   ├── _posts/<br>│   │   ├── example.md<br>│   │   ├── imgs/  <span class="hljs-comment">(软链接)</span><br>│   ├── imgs/  <span class="hljs-comment">(实际存放图片的目录)</span><br></code></pre></td></tr></table></figure><p>以上是我的hexo源文件结构，文章放在source/_posts/目录下，文章的图片放在source/imgs/目录下，因此文章中的图片通过相对路径../imgs访问图片。</p><p>hexo需要用绝对路径解析图片，因此我需要在<code>hexo g</code>的时候将文章中图片的相对路径<code>../imgs</code>解析为绝对路径<code>/imgs</code>：</p><p>在主题的<code>post.ejs</code>文件中，替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%- page.content %&gt;<br></code></pre></td></tr></table></figure><p>为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%- page.content.replace(/\.\.\/imgs\//g, &#x27;/imgs/&#x27;) %&gt;<br></code></pre></td></tr></table></figure><p>也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ejs">...<br>&lt;% if (page.encrypt === true) &#123; %&gt;<br>&lt;%- inject_point(&#x27;postMarkdownBegin&#x27;) %&gt;<br>&lt;%- page.content.replace(/\.\.\/imgs\//g, &#x27;/imgs/&#x27;) %&gt;<br>&lt;%- partial(&#x27;_partials/plugins/encrypt&#x27;) %&gt;<br>&lt;%- inject_point(&#x27;postMarkdownEnd&#x27;) %&gt;<br>&lt;% &#125; else &#123; %&gt;<br>&lt;div class=&quot;markdown-body&quot;&gt;<br>    &lt;%- inject_point(&#x27;postMarkdownBegin&#x27;) %&gt;<br>    &lt;%- page.content.replace(/\.\.\/imgs\//g, &#x27;/imgs/&#x27;) %&gt;<br>    &lt;%- inject_point(&#x27;postMarkdownEnd&#x27;) %&gt;<br>&lt;/div&gt;<br>&lt;% &#125; %&gt;<br>...<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab 5</title>
    <link href="/2025/02/19/cs144-lab5/"/>
    <url>/2025/02/19/cs144-lab5/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-checkpoint-5-down-the-stack-the-network-interface"><a class="markdownIt-Anchor" href="#lab-checkpoint-5-down-the-stack-the-network-interface"></a> Lab Checkpoint 5: down the stack (the network interface)</h1><blockquote><p><a href="https://cs144.github.io/assignments/check5.pdf">Checkpoint5 spec</a></p></blockquote><div class="note note-warning">            <p>注意，这篇笔记My implementation的后半部分全程代码剧透！</p>          </div><h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p>In this lab, you'll go down the stack and implement the network interface:  the bridge between <strong>Internet datagrams</strong> that travel the world, and <strong>link-layer Ethernet frames</strong> that travel one hop.</p><p>The figure below shows that the network interface we are going to implement is part of a host's TCP/IP protocol stack and also a part of an IP router.</p><p><img src="../imgs/202502171212064-1739988824415-108.png" alt="Our protocol stack" /></p><blockquote><p>What's the responsibility of the network interface?</p></blockquote><p>When an IP datagram is handed to the kernel, the kernel needs to construct an appropriate link-layer (Ethernet) frame with the IP datagram as its payload. This means the kernel needs to know its (IP address, Ethernet address) mapping. These functions are performed by the network interface.</p><p>Most of the work you will do is to implement the <strong>Address Resolution Protocol(ARP)</strong>, which looks up (and cache) the Ethernet address for each next-hop IP address.</p><p>In lab6, you will use this network interface as part of an IP router.</p><h2 id="my-implementation"><a class="markdownIt-Anchor" href="#my-implementation"></a> My implementation</h2><div class="note note-success">            <p>前言：coding前一定要认真读spec，将逻辑细节清楚后再写code。这个lab的代码量会相对较大，一定要多写helper functions！否则函数内部实现就会很臃肿。spec将函数逻辑讲解得很清晰，而且不像lab2和lab3那样有那么多corner case，所以难度适中。如果test没有通过，那一定是你在函数的逻辑细节问题上疏漏了。</p>          </div><p>这个lab需要我们实现网络层(IP)和链路层(Ethernet)之间的网络接口(Network Interface)，负责：</p><ol><li>将从host/router上层(IP)收到的network datagram包装成Ethernet frame发送给上层IP协议指定的下一个host(next hop)。可能需要发送ARP request并将datagram暂放在waiting area中等待发送（详见ARP协议）</li><li>接收外来的Ethernet frame，解析出payload，并根据其类型决定下一步操作：<ul><li>如果是IPv4 datagram, 则将其存入buffer中供上层协议读取</li><li>如果是ARP message，则记录下sender's IP-to-Ethernet mapping，如果是ARP request for自己的Ethernet地址，那就回复相应的ARP reply</li></ul></li></ol><p>如spec所说，这个Network Interface的关键在于实现<strong>ARP协议</strong>：</p><p>这个Network Interface需要一个结构来缓存所有next hop的IP-to-Ethernet mapping。当需要发送一个network datagram的时候，如果next hop的Ethernet地址未知，就需要broadcast一个ARP request，并将这个datagram放入一个waiting area等待接收到ARP reply后再发送出去</p><p>当Network Interface接收到一个ARP message的时候，需要将sender's IP-to-Ethernet mapping缓存下来。这时候需要检查waiting area中是否有正在等待这个mapping的datagram，如果有的话现在就可以发送这个datagram了。如果是一个ARP request，并且请求的还是自己的Ethernet地址，那么还需要将相应的ARP reply发送给sender</p><div class="note note-danger">            <p>需要注意的点：</p><p>next hop的IP-to-Ethernet mapping是会随着设备的接入和离开随时变化的，因此每个缓存的IP-to-Ethernet mapping每隔一段时间（lab规定为30秒）会过期，需要清除。</p><p>在发送一个ARP request之后，5秒内（lab规定的）不应再发送针对相同IP地址的ARP request，但是仍需要将datagram放入waiting area中。</p><p>datagram不会永远等待在waiting area中，如果被放入waiting area后的5秒内（lab规定的）还没接收到等待的Ethernet地址，那么我们的Network Interface就会drop掉这个datagram。</p>          </div><p>接下来进入我的实现细节（后面将是全程代码剧透！）：</p><p>首先要确定用什么数据结构来表示：</p><ol><li>所有缓存的IP-to-Ethernet mappings</li><li>所有在waiting area中的datagrams</li></ol><p>考虑到清除IP-to-Ethernet mappings操作是清除那些早于当前时间30秒的所有mappings，因此我决定使用可以根据mapping插入的时间顺序（时间戳）来排序所有mappings的数据结构，以提高清除操作的速度。我选择使用一个multimap，将mapping插入的时间（时间戳）作为key，IP-to-Ethernet mapping pair作为value。用multimap而不是map是因为不同mapping pair的时间戳可能相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Define the value type as a pair of EthernetAddress and IP address.</span><br>using MappingPair = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;EthernetAddress, <span class="hljs-type">uint32_t</span>&gt;;<br><br><span class="hljs-comment">// Define the map type with timestamp as key and (Ethernet, IP) pair as value.</span><br><span class="hljs-comment">// This is the data structure that will be used to store all the IP-to-Ethernet mappings.</span><br>using NetworkMappings = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">multimap</span>&lt;<span class="hljs-type">uint64_t</span>, MappingPair&gt;;<br><br>NetworkMappings mappings &#123;&#125;;<br></code></pre></td></tr></table></figure><p>同样的道理，在waiting area中等待过期的datagrams也需要定期清除（每次调用<code>tick</code>时），因此我也用一个multimap存储queued datagram。注意queued datagram需要包含datagram本身，以及其需要去往的next hop的ip地址。</p><div class="note note-info">            <p>注意不要将<code>datagram_queued_</code>与<code>datagram_received_</code>搞混淆了，前者是需要等待ARP request收到回应后才能发送出去的pending(queued) datagrams，而datagram_received_是Network Interface从外部接收并解析出的IPv4 datagrams，暂存在Network Interface中供上层协议读取的。</p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueuedDatagram</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> next_hop_ip &#123;&#125;;<br>    InternetDatagram dgram &#123;&#125;;<br>&#125;;<br><br><span class="hljs-comment">// Datagrams that queued to learn the Ethernet address of the next hop</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">multimap</span>&lt;<span class="hljs-type">uint64_t</span>, QueuedDatagram&gt; datagrams_queued_ &#123;&#125;;<br></code></pre></td></tr></table></figure><p><code>send_datagram</code> method还需要一个结构来存储针对每一个ip地址发送的ARF request的上一次发送时间，以此来检查是否可以发送当前的ARP request，这里我选择使用<code>unordered_map</code>，ip地址作为key，时间戳作为value。因为访问该结构的时候是通过ip地址寻找的，无法进行顺序查找，因此不需要排序，用hash table存储访问效率较高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint64_t</span>&gt; last_arp_request_time_ &#123;&#125;;<br></code></pre></td></tr></table></figure><p>确定好所有的数据结构后，就可以开始尝试实现Network Interface提供的3个methods，<strong>实现的过程中尽量将具体的逻辑细节封装在helper functions中</strong>：</p><ul><li><code>tick</code></li></ul><p><code>tick</code>是最容易实现的，首先更新当前时间，然后就是根据更新后的时间将过期的IP-to-Ethernet mappings和queued datagram清除。这里可以分别写两个helper function来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Remove expired mappings (older than 30 seconds)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">remove_expired_mappings</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( time_elapsed_ &lt; MAPPING_TIMEOUT ) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Calculate the expiration threshold</span><br>    <span class="hljs-type">uint64_t</span> expiration_threshold = time_elapsed_ - MAPPING_TIMEOUT;<br><br>    <span class="hljs-comment">// Find the first element that is not expired</span><br>    <span class="hljs-comment">// Since map is ordered by timestamp, we can remove all elements</span><br>    <span class="hljs-comment">// from beginning until we find a non-expired entry</span><br>    <span class="hljs-keyword">auto</span> it = mappings.lower_bound( expiration_threshold );<br>    mappings.erase( mappings.begin(), it );<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Drop any expired datagrams</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">drop_expired_datagrams</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// Calculate the expiration threshold</span><br>    <span class="hljs-type">uint64_t</span> expiration_threshold = time_elapsed_ - ARP_REQUEST_TIMEOUT;<br>    <span class="hljs-keyword">if</span> ( time_elapsed_ &lt; ARP_REQUEST_TIMEOUT ) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Drop all expired datagrams</span><br>    <span class="hljs-keyword">auto</span> it = datagrams_queued_.begin();<br>    <span class="hljs-keyword">while</span> ( it != datagrams_queued_.end() &amp;&amp; it-&gt;first &lt;= expiration_threshold ) &#123;<br>        it = datagrams_queued_.erase( it );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个helper function虽然是处理不同的数据结构，但是逻辑很相似，都是从multimap的开头开始顺序清除，直到遇到第一个没有过期的元素后停止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">NetworkInterface::tick</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick )</span><br>&#123;<br>  time_elapsed_ += ms_since_last_tick;<br><br>  <span class="hljs-comment">// Remove any expired IP-to-Ethernet mappings</span><br>  remove_expired_mappings();<br><br>  <span class="hljs-comment">// Drop any expired datagrams</span><br>  drop_expired_datagrams();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>send_datagram</code></li></ul><p>分两种情况：</p><ol><li>已知next hop的Ethernet address（缓存在Network Interface中了）</li></ol><p>从IP-to-Ethernet中获取需要的mapping，创建并设置Ethernet frame，frame header中的dst field设为获取的mapping中的Ethernet address。将frame的payload设为serialized后的datagram。设置完成后传输该Ethernet frame</p><p>根据next hop的ip地址获取mapping缓存，并将获知的Ethernet地址写入frame header的过程可以写一个helper function：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Get mapping by IP address</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">getMapping</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> target_ip, EthernetAddress&amp; eth )</span> <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [ts, mapping] : mappings ) &#123;<br>        <span class="hljs-keyword">if</span> ( mapping.second == target_ip ) &#123;<br>            eth = mapping.first;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>send_datagram</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">EthernetFrame eframe;<br><br><span class="hljs-comment">// If the destination Ethernet address is already known, create a Ethernet frame and send it right away</span><br><span class="hljs-keyword">if</span> ( getMapping( next_hop.ipv4_numeric(), eframe.header.dst ) ) &#123;<br>    <span class="hljs-comment">// Set up the Ethernet frame header</span><br>    eframe.header.type = EthernetHeader::TYPE_IPv4;<br>    eframe.header.src = ethernet_address_;<br><br>    <span class="hljs-comment">// Set up the Ethernet frame payload to be the serialized datagram</span><br>    Serializer serializer;<br>    dgram.serialize( serializer );<br>    eframe.payload = serializer.finish();<br><br>    <span class="hljs-comment">// Send the Ethernet frame</span><br>    transmit( eframe );<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>未知next hop的Ethernet address（不在缓存中）</li></ol><p>需要发送一个请求next hop的ip地址的ARP request（如果5秒内没发送过请求该ip地址的ARP request），并将datagram放入waiting area中。</p><p>我用一个helper function来创建ARP message：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">EthernetFrame <span class="hljs-title function_">create_arp_message</span><span class="hljs-params">( <span class="hljs-type">uint16_t</span> opcode,</span><br><span class="hljs-params">                                 <span class="hljs-type">const</span> EthernetAddress&amp; sender_eth,</span><br><span class="hljs-params">                                 <span class="hljs-type">uint32_t</span> sender_ip,</span><br><span class="hljs-params">                                 <span class="hljs-type">const</span> EthernetAddress&amp; target_eth,</span><br><span class="hljs-params">                                 <span class="hljs-type">uint32_t</span> target_ip )</span><br>&#123;<br>    EthernetFrame frame;<br>    <span class="hljs-keyword">if</span> ( opcode == ARPMessage::OPCODE_REQUEST ) &#123;<br>        frame.header.dst = ETHERNET_BROADCAST;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        frame.header.dst = target_eth;<br>    &#125;<br>    frame.header.src = sender_eth;<br>    frame.header.type = EthernetHeader::TYPE_ARP;<br><br>    ARPMessage arp;<br>    arp.opcode = opcode;<br>    arp.sender_ethernet_address = sender_eth;<br>    arp.sender_ip_address = sender_ip;<br>    arp.target_ethernet_address = target_eth;<br>    arp.target_ip_address = target_ip;<br><br>    Serializer serializer;<br>    arp.serialize( serializer );<br>    frame.payload = serializer.finish();<br><br>    <span class="hljs-keyword">return</span> frame;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注意，<code>send_datagram</code>（可能）需要的ARP request message和<code>recv_frame</code>（可能）需要的ARP reply message都是用上面这个函数创建。创建request和reply message使用的参数模板都是一样的，不同的是：</p><ol><li><p><code>opcode</code>不同</p></li><li><p>request message的<code>target_ethernet_address</code>是<code>{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }</code>，而reply message的是要回复对象的Ethernet地址</p></li><li><p>request message的<code>target_ip_address</code>是请求的ip地址，reply message的是要回复对象的ip地址</p></li><li><p>request message的frame header中的<code>dst</code>是Ethernet Broadcast地址，而reply message的就是要回复对象的Ethernet地址</p></li></ol>          </div><p>接下来，我用一个helper function来检查是否可以发送ARP request，再用一个来更新ARP request发送时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">can_send_arp_request</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> target_ip )</span> <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">auto</span> it = last_arp_request_time_.find( target_ip );<br>    <span class="hljs-keyword">if</span> ( it == last_arp_request_time_.end() ) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> time_elapsed_ - it-&gt;second &gt;= ARP_REQUEST_TIMEOUT;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">update_arp_request_time</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> target_ip )</span> &#123; last_arp_request_time_[target_ip] = time_elapsed_; &#125;<br></code></pre></td></tr></table></figure><p>在<code>send_datagram</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// The destination Ethernet address is unknown,</span><br><span class="hljs-comment">// broadcast an ARP request and queue the datagram</span><br>EthernetFrame arp_request = create_arp_message( ARPMessage::OPCODE_REQUEST,<br>                                               ethernet_address_,<br>                                               ip_address_.ipv4_numeric(),<br>                                               &#123; <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span> &#125;,<br>                                               next_hop.ipv4_numeric() );<br><br><span class="hljs-keyword">if</span> ( can_send_arp_request( next_hop.ipv4_numeric() ) ) &#123;<br>    transmit( arp_request );<br>    update_arp_request_time( next_hop.ipv4_numeric() );<br>&#125;<br><br>QueuedDatagram qdgram;<br>qdgram.next_hop_ip = next_hop.ipv4_numeric();<br>qdgram.dgram = dgram;<br>datagrams_queued_.insert( <span class="hljs-built_in">make_pair</span>( time_elapsed_, qdgram ) );<br></code></pre></td></tr></table></figure><ul><li><code>recv_datagram</code></li></ul><p>首先判断接收到的Ethernet frame是不是发送给自己的，如果不是的话直接ignore：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Ignore any frames not destined for the network interface</span><br><span class="hljs-keyword">if</span> ( frame.header.dst != ethernet_address_ &amp;&amp; frame.header.dst != ETHERNET_BROADCAST ) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>后续处理该frame也分两种情况：</p><ol><li>如果接收到的是IPv4类型的frame，将payload解析为network datagram，如果解析成功就将其放入<code>datagram_received_</code> buffer中供上层协议读取</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// If inbound frame is IPv4, parse the payload as an InternetDatagram</span><br><span class="hljs-comment">// and if successful, push the resulting datagram to the datagrams_received_ queue</span><br><span class="hljs-keyword">if</span> ( frame.header.type == EthernetHeader::TYPE_IPv4 ) &#123;<br>    Parser <span class="hljs-title function_">parser</span><span class="hljs-params">( frame.payload )</span>;<br><br>    InternetDatagram dgram;<br>    dgram.parse( parser );<br>    <span class="hljs-keyword">if</span> ( parser.has_error() )<br>        <span class="hljs-keyword">return</span>;<br>    datagrams_received_.push( dgram );<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>如果接收到的是ARP类型的frame，将payload解析为ARP message，如果解析成功就将sender的IP-to-Ethernet mapping写入缓存中。并且，如果是ARP request，那么还需要回复相应的ARP reply。</p><p>最后，我们需要遍历<code>datagram_queued_</code>检查刚接收到的IP-to-Ethernet mapping是否可以让我们发送等待在waiting area中的pending(queued) datagrams。</p></li></ol><p>写入IP-to-Ethernet mapping缓存的过程可以用一个helper function：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Add a new IP-to-Ethernet mapping</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">addMapping</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> timestamp, <span class="hljs-type">const</span> EthernetAddress&amp; eth, <span class="hljs-type">uint32_t</span> ip )</span><br>&#123;<br>    mappings.insert( <span class="hljs-built_in">make_pair</span>( timestamp, MappingPair( eth, ip ) ) );<br>&#125;<br></code></pre></td></tr></table></figure><p>创建并设置ARP reply使用之前写的<code>create_arp_message</code> function。</p><p>在<code>recv_datagram</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// If the inbound frame is ARP, parse the payload as an ARPMessage</span><br><span class="hljs-comment">// an if successful, add the IP-to-Ethernet mapping to the mappings.</span><br><span class="hljs-comment">// In addition, if it&#x27;s an ARP request asking for our IP address,</span><br><span class="hljs-comment">// send an appropriate ARP reply.</span><br><span class="hljs-keyword">if</span> ( frame.header.type == EthernetHeader::TYPE_ARP ) &#123;<br>    Parser <span class="hljs-title function_">parser</span><span class="hljs-params">( frame.payload )</span>;<br><br>    ARPMessage arp_message;<br>    arp_message.parse( parser );<br>    <span class="hljs-keyword">if</span> ( parser.has_error() )<br>        <span class="hljs-keyword">return</span>;<br>    addMapping( time_elapsed_, arp_message.sender_ethernet_address, arp_message.sender_ip_address );<br>    <span class="hljs-keyword">if</span> ( arp_message.opcode == ARPMessage::OPCODE_REQUEST<br>        &amp;&amp; arp_message.target_ip_address == ip_address_.ipv4_numeric() ) &#123;<br>        EthernetFrame arp_reply = create_arp_message( ARPMessage::OPCODE_REPLY,<br>                                                     ethernet_address_,<br>                                                     ip_address_.ipv4_numeric(),<br>                                                     arp_message.sender_ethernet_address,<br>                                                     arp_message.sender_ip_address );<br>        transmit( arp_reply );<br>    &#125;<br><br>    <span class="hljs-comment">// Since we have received an ARP message, we can probably send any queued datagrams</span><br>    <span class="hljs-keyword">auto</span> it = datagrams_queued_.begin();<br>    <span class="hljs-keyword">while</span> ( it != datagrams_queued_.end() ) &#123;<br>        <span class="hljs-keyword">if</span> ( it-&gt;second.next_hop_ip == arp_message.sender_ip_address ) &#123;<br>            send_datagram( it-&gt;second.dgram, Address::from_ipv4_numeric( it-&gt;second.next_hop_ip ) );<br>            it = datagrams_queued_.erase( it );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++it;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish!</h2><p>All tests in check5 pass!</p><p><img src="../imgs/202502190143600-1739984763181-30-1739988835302-110.png" alt="Test check5" /></p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Protocol Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab 3</title>
    <link href="/2025/02/14/cs144-lab3/"/>
    <url>/2025/02/14/cs144-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-checkpoint-3-the-tcp-sender"><a class="markdownIt-Anchor" href="#lab-checkpoint-3-the-tcp-sender"></a> Lab Checkpoint 3: the TCP sender</h1><blockquote><p><a href="https://cs144.github.io/assignments/check3.pdf">Checkpoint3 spec</a></p></blockquote><blockquote><p>In Checkpoint0, we implemented a flow-controlled byte stream(<code>ByteStream</code>).</p><p>In Checkpoint1 and 2, we implement a <code>Reassembler</code> and <code>TCPReceiver</code> to translate from segments carried in unreliable datagrams to an incoming byte stream.</p><p>In Checkpoint3, we'll implement the <strong>sender side</strong> of the TCP connection. The TCPSender translates from an outbound byte stream to segments that will become the payloads of unreliable datagrams.</p></blockquote><h2 id="the-tcp-sender"><a class="markdownIt-Anchor" href="#the-tcp-sender"></a> The TCP Sender</h2><blockquote><p>In this lab, you will implement the &quot;<strong>sender</strong>&quot; part of TCP, responsible for reading from a <code>ByteStream</code>(created and written to by some sender-side application), and turning the stream into a sequence of outgoing TCP segments.</p></blockquote><p><strong><code>TCPSender</code></strong> is responsible for:</p><ol><li>Keep track of the receiver's window.</li><li>Keep sending segments until either the window is full or the outbound <code>ByteStream</code> has nothing more to send.</li><li>Keep track of which segments have been sent but not yet acknowledged(&quot;outstanding&quot; segments) by the receiver.</li><li>Re-send outstanding segments if enough time passes since they were sent, and they haven't been acknowledged yet.</li></ol><blockquote><p>How does the <code>TCPSender</code> know if a segment was lost?</p></blockquote><p>Periodically, the owner of the TCPSender will call the <code>tick</code> method. The <code>TCPSender</code> is responsible for looking through its collection of outstanding <code>TCPSenderMessages</code> and deciding if the oldest-sent segment has been outstanding for too long without acknowledgement.</p><p>To be specific:</p><ol><li><p>The <code>TCPSender</code> stores the initial value of RTO(retransmission timeout).</p></li><li><p>You will implement the <strong>retransmission timer</strong>: an alarm that can be started at a certain time, and the alarm expires once the RTO has elapsed. Every time a segment containing data is sent, if the timer is not running, start it running. <strong>When all outstanding data has been acknowledged, stop the retransmission timer.</strong></p></li><li><p>When <code>tick</code> is called and the retransmission timer has expired:</p><ul><li><p>Retransmit the earliest(lowest sequence number) segment that hasn't been fully acknowledged by the TCP receiver. You should store the outstanding segments in some internal data structure.</p></li><li><p>If the window size is nonzero:</p><p>(a). Keep track of and update the number of consecutive retransmissions.</p><p>(b). Double the value of RTO.</p></li><li><p>Reset the retransmission timer and start it.</p></li></ul></li><li><p>When the receiver gives the sender a new <code>ack</code> message:</p><ul><li>Set the RTO back to its initial value.</li><li>If the sender has any outstanding data, restart the retransmission timer.</li><li>Reset the consecutive retransmissions back to zero.</li></ul></li></ol><p>以上就是<code>TCPSender</code>的retransmission logic，详细见cs144官方spec。</p><p>简单总结一下就是<code>TCPSender</code>会在内部存储outstanding segments。<code>TCPSender</code>的owner会周期性地调用<code>tick</code>函数查看retransmission timer是否expired，如果是则retransmit最早的outstanding segment，double RTO防止网络堵塞加剧retranmission的负担(exponential backoff)，并重启retransmission timer。当<code>TCPSender</code>接收到新的acknowledgement的时候，重设RTO为最初值并重启retransmission timer(如果还有outstanding segments)。</p><h2 id="implement-the-tcp-sender"><a class="markdownIt-Anchor" href="#implement-the-tcp-sender"></a> Implement the TCP sender</h2><p>You should implement the interface that your <code>TCPSender</code> provides:</p><ul><li><strong><code>void push( const TransmitFunction&amp; transmit );</code></strong></li></ul><p>Read from the outbound byte stream and <strong>send as many <code>TCPSenderMessages</code> as possible, as long as there are new bytes to be read and space available in the window</strong>.</p><p>Make sure that every <code>TCPSenderMessage</code> you send fits fully inside the receiver’s window. Make each individual message as big as possible, but no bigger than the value given by <code>TCPConfig::MAX PAYLOAD SIZE</code>.</p><blockquote><p>What should my TCPSender assume as the receiver’s window size before the receive method informs it otherwise?</p></blockquote><p>One.</p><blockquote><p>What if the window size is zero?</p></blockquote><p>If the receiver has announced a window size of zero, the push method should pretend like the window size is one. The sender might end up sending a single byte that gets rejected by the receiver, but this can also provoke the receiver into sending a new acknowledgment segment where it reveals that more space has opened up in its window.</p><p>This is the only special-case behavior your implementation should have for the case of a zero-size window. The TCPSender shouldn’t actually remember a false window size of 1. The special case is only within the push method. Also, N.B. that <strong>even if the window size is one (or 20, or 200), the window might still be full. A “full” window is not the same as a “zero-size” window.</strong></p><ul><li><strong><code>void receive( const TCPReceiverMessage&amp; msg );</code></strong></li></ul><p>A message is received from the receiver, conveying the new left (= <code>ackno</code>) and right (= <code>ackno + window size</code>) edges of the window. The TCPSender should look through its collection of outstanding segments and remove any that have now been fully acknowledged (<strong>the <code>ackno</code> is greater than all of the sequence numbers in the segment</strong>).</p><ul><li><strong><code>void tick( uint64 t ms since last tick, const TransmitFunction&amp; transmit );</code></strong></li></ul><p>The sender may need to retransmit an outstanding segment.</p><ul><li><strong><code>TCPSenderMessage make_empty_message() const;</code></strong></li></ul><p>The TCPSender should generate and send a zero-length message with the sequence number set correctly.</p><p>Note: a segment like this one, which occupies no sequence numbers, doesn’t need to be kept track of as “outstanding” and won’t ever be retransmitted.</p><h2 id="我的实现思路"><a class="markdownIt-Anchor" href="#我的实现思路"></a> 我的实现思路</h2><blockquote><p>前言：认真读spec！至少将spec的第二板块读3遍再开始coding：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>Checkpoint <span class="hljs-number">3</span>: The TCP Sender<br></code></pre></td></tr></table></figure><p>这个lab的整体实现难度不难，很大一部分原因是因为spec讲解得非常清晰。就我自己实现起来比lab2还要轻松一些。主要难度在于细节点和corner case非常多，因此需要大量的时间面向test来debug。我自己debug花的时间比coding的时间还要长。</p></blockquote><p>接下来进入正题：</p><p>TCP Sender的实现可以分成3大部分，难度我认为也是逐级递增的：</p><ol><li>Retransmission (retransmission timer + tick)</li><li>Window (sender's window + receiver's window)</li><li>Push + Receive</li></ol><ul><li><strong>Retransmission</strong></li></ul><p>Retransmission的逻辑其实是TCP Sender的一大重难点，但这部分(retransmission timer + tick)在spec中讲解得非常详细。并且，在这个lab中要求我们实现的Retransmission逻辑其实是真实的TCP协议的Retransmission逻辑的简化版本，真实的TCP协议的Retransmission包含更多细节(如3次duplicate ACK的应对, congestion control…)。因此这部分实现起来比较轻松。</p><blockquote><p>这里再放一下我总结的Retransmission logic，如果spec读起来有点费解的话可以参考：</p><p><code>TCPSender</code>会在内部存储outstanding segments。<code>TCPSender</code>的owner会周期性地调用<code>tick</code>函数查看retransmission timer是否expired，如果是则retransmit最早的outstanding segment，double RTO防止网络堵塞加剧retranmission的负担(exponential backoff)，并重启retransmission timer。当<code>TCPSender</code>接收到新的acknowledgement的时候，重设RTO为最初值并重启retransmission timer(如果还有outstanding segments)。</p></blockquote><div class="note note-success">            <p>我建议单独创建一个Retransmission timer类，与TCPSender类区分开来，结构更清晰。</p>          </div><ul><li><strong>Window</strong></li></ul><div class="note note-danger">            <p>这部分在spec中讲解得比较模糊，需要自行理解与实现！</p>          </div><p>在spec中反复提到的window，其实指的是<code>TCPSender</code>接收到的acknowledge message中包含的Receiver's window。回顾Checkpoint1，我们画过一张Receiver's window:</p><p><img src="../imgs/202502132132652-1739988789628-100.jpeg" alt="TCP Receiver's window" /></p><p>但spec中没有提到，需要我们自己理解的是，<code>TCPSender</code>的window与<code>TCPReceiver</code>的window是不同的，为了区分这两端的window，我在<code>TCPSender</code>端维护了一个sender's window，用来与上面的receiver's window进行区分，如下图：</p><p><img src="../imgs/202502132139485-1739988798925-102.jpg" alt="TCP Sender's window" /></p><p>希望这张图能帮助你理解Sender's window和Receiver’s window的区别与联系。其中绿色区域代表的是Receiver已经acknowledge的bytes范围，红色区域代表的是outstanding segments，蓝色区域是<code>push</code>方法允许transmit的bytes范围，也就是Sender's window。</p><p><code>TCPSender</code>需要一种数据结构来存储outstanding segments，以便在传输过程中丢失时可以retransmit。由Retransmission logic可知我们每次retransmit的是earliest outstanding segment，也就是seqno最小的segment，所以思考可以用什么数据结构来存储outstanding segments？</p><p>联系Checkpoint1，最容易想到的就是用map，这样每次retransmit只要移除map的第一个元素就可以了。</p><ul><li><strong>Push + Receive</strong></li></ul><p>这也是这个lab最tricky的部分，尤其是<code>push</code>的实现，细节点很多。主要的实现逻辑在spec中已经说明得比较详细，我在此提示一些注意点：</p><ol><li><blockquote><p><code>void push( const TransmitFunction&amp; transmit );</code></p><p>The TCPSender is asked to fill the window from the outbound byte stream: it reads from the stream and <strong>sends as many TCPSenderMessages as possible, as long as there are new bytes to be read and space available in the window.</strong></p></blockquote><p>好好理解上面加粗的这段话，什么叫做只要outbound stream中还有可读取的new bytes和window(Sender's window)还有空间就不停地send segments?</p></li><li><p>当<code>receive</code>方法接收到一个message告知自己Receiver's window size = 0时，<code>push</code>需要将其作为special case处理，详细见spec。</p></li><li><p>在debug时尤其注意<code>SYN</code>和<code>FIN</code> flag带来的各种corner case。这部分我们在Checkpoint2中已经有一定的应对经验，但在这个lab中处理起来会更麻烦一点。</p></li><li><p>在<code>push</code>和<code>receive</code>中，需要时刻注意Sender's window的变化。</p></li></ol><h2 id="tcp-sender-finish"><a class="markdownIt-Anchor" href="#tcp-sender-finish"></a> TCP Sender Finish!</h2><p>All tests in check3 pass!</p><img src="../imgs/202502131916226-1739984591383-24-1739988806450-104.png" alt="" style="zoom:80%;" /><p>恭喜！到这里你已经实现了一个完整可运行的TCP协议了！</p><h2 id="hands-on-activity"><a class="markdownIt-Anchor" href="#hands-on-activity"></a> Hands-on activity</h2><p>恭喜！到这里你应该已经实现了一个完整可运行的TCP协议了！</p><p>在这一部分，我们要实际验证这个TCP协议栈确实能work，我们要：</p><ol><li>尝试让你的TCP协议与Linux的TCP协议对话</li><li>尝试在你的TCP协议与Linux的TCP协议之间传送文件</li><li>与其他同学的TCP协议通话（要用到CS144内部网络，我们做不了）</li><li>在你的TCP协议栈之上重新实现Web fetcher</li></ol><p>我这里就只展示最后一条：</p><h3 id="webget-revisited"><a class="markdownIt-Anchor" href="#webget-revisited"></a> webget revisited</h3><p>在lab0中，我们在Linux的TCP协议之上，实现了一个使用TCP Socket传输http协议信息，来获取网页的Web fetcher(<code>get_URL</code>)。</p><p>如今，尝试换成在<strong>我们自己实现的完整TCP协议栈</strong>之上，改写这个Web fetcher（只需要将Linux的TCPSocket换成我们自己的CS144TCPSocket）。</p><img src="../imgs/202502132342058-1739988814201-106.png" alt="" style="zoom:80%;" /><p>Our own TCP implementation works! 😊</p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Protocol Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab 2</title>
    <link href="/2025/02/11/cs144-lab2/"/>
    <url>/2025/02/11/cs144-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-checkpoint-2-the-tcp-receiver"><a class="markdownIt-Anchor" href="#lab-checkpoint-2-the-tcp-receiver"></a> Lab Checkpoint 2: the TCP receiver</h1><blockquote><p><a href="https://cs144.github.io/assignments/check2.pdf">Checkpoint2 spec</a></p></blockquote><h2 id="the-tcp-receiver"><a class="markdownIt-Anchor" href="#the-tcp-receiver"></a> The TCP Receiver</h2><p>In this lab, we implement the TCP Receiver. The <code>TCPReceiver</code> receives messages from the peer’s sender (via the <code>receive()</code> method) and turns them into calls to a <code>Reassembler</code>, which eventually writes to the incoming <code>ByteStream</code>. Applications read from this <code>ByteStream</code>.</p><p>Meanwhile, the <code>TCPReceiver</code> also generates messages that go back to the peer’s sender, via the send() method. These “receiver messages” tell the sender:</p><ol><li>the index of the “first unassembled” byte, which is called the “acknowledgment number” or “<strong><code>ackno</code></strong>.” This is the first byte that the receiver needs from the sender.</li><li>the available capacity in the output <code>ByteStream</code>. This is called the “<strong>window size</strong>”.</li></ol><p>Together, the <strong><code>ackno</code></strong> and <strong>window size</strong> describe describes the receiver’s <strong>window</strong>: a <strong>range of indexes</strong> that the TCP sender is allowed to send.</p><h3 id="translating-between-64-bit-indexes-and-32-bit-seqnos"><a class="markdownIt-Anchor" href="#translating-between-64-bit-indexes-and-32-bit-seqnos"></a> Translating between 64-bit indexes and 32-bit <code>seqnos</code></h3><blockquote><p>In the TCP headers, space is precious, so each byte’s index in the stream is represented not with a 64-bit index but with a 32-bit “sequence number,” or “<code>seqno</code>.”</p></blockquote><p>在这一部分，我们需要实现一个Wrap32类中的wrap和unwrap方法来实现64位的absolute sequence number和32位的sequence number之间的转换。</p><p>其中，wrap方法负责将一个64位的absolute sequence number转换为一个32位的sequence number，比较简单，只需要一行代码。</p><p>unwrap方法负责将一个32位的sequence number转换为64位的absolute sequence number。这里稍微麻烦一点的地方在于一个32位的sequence number理论上可以转换为无穷多个以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>为间隔的absolute sequence number，需要通过给定的checkpoint来定位我们需要的absolute sequence number。</p><p>因此，我们的问题是：</p><blockquote><p>如何找到最接近checkpoint的absolute sequence number?</p></blockquote><p>首先我们要获得这个32位的sequence number与ISN的offset，这个offset将会是最小可能的absolute sequence number，然后每增加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>就又会得到一个可能的absolute sequence number。</p><p>我第一个想到的方法是用一个while循环，每次循环增加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，直到找到那个刚好小于checkpoint和刚好大于checkpoint的两个相邻的absolute sequence number，比较并返回那个更接近checkpoint的值。但是这样的话如果checkpoint很大循环次数将会很多很浪费时间，实测这样实现的话test会超时，需要更换思路。</p><p>其实解决方案很简单，思考如何根据checkpoint直接定位到相邻可能的absolute sequence number？</p><p>最后要注意，测试前可能需要将<code>debug</code>行注释掉否则可能会超时（至少我的情况是这样）。</p><h3 id="implementing-the-tcp-receiver"><a class="markdownIt-Anchor" href="#implementing-the-tcp-receiver"></a> Implementing the TCP receiver</h3><p>在这一部分，我们需要实现<code>TCPReceiver</code>类，这个类需要一个receive方法来接收<code>TCPSenderMessages</code>,并将其中的payload交给<code>Reasssembler</code>;还需要一个send方法来acknowledge收到的message，发送<code>TCPReceiverMessages</code>。</p><blockquote><p>为什么在<code>Reassembler</code>前面需要一个<code>TCPReceiver</code>类，不能直接将接收到的segment交给<code>Reassembler</code>？</p></blockquote><p>由<code>TCPSenderMessage</code>类:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TCPSenderMessage</span><br>&#123;<br>  Wrap32 seqno &#123; <span class="hljs-number">0</span> &#125;;<br><br>  <span class="hljs-type">bool</span> SYN &#123;&#125;;<br>  std::string payload &#123;&#125;;<br>  <span class="hljs-type">bool</span> FIN &#123;&#125;;<br><br>  <span class="hljs-type">bool</span> RST &#123;&#125;;<br><br>  <span class="hljs-comment">// How many sequence numbers does this segment use?</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">sequence_length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> SYN + payload.<span class="hljs-built_in">size</span>() + FIN; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看出TCP segment不仅仅包含data(payload)，还有<code>seqno</code>和SYN,FIN,RST flag。</p><p><strong><code>TCPReceiver</code>的receive方法需要负责：</strong></p><p>一句话概括：分析接收到的TCP segment(<code>TCPSenderMessage</code>)后，将payload交由<code>Reassembler</code>处理。</p><p>具体来说：</p><ol><li><p>根据RST flag判断是否有error。</p></li><li><p>根据SYN和FIN flag判断是byte stream的起始segment还是终止segment：如果是起始segment，那么<code>TCPReceiver</code>需要记录下ISN(Initial Sequence Number)，并且通知<code>Reassembler</code>我们已经接收到byte stream的起始segment（这是为了让<code>Reassembler</code>从index 1开始接收substring，因为index 0需要保留给SYN flag）；如果是终止segment，<code>TCPReceiver</code>需要先在自己内部记录下来已经接收到了FIN flag，等到所有存储在<code>Reassembler</code>中的substrings全部push到byte stream之后（也就是当<code>ByteStream</code>的写入端关闭之后），再通知<code>Reassembler</code>我们已经接收到byte stream的终止segment（这是因为当接收到完整的byte stream之后，最后send方法发送的<code>ackno</code>需要包含最后的FIN flag）。</p><div class="note note-primary">            <p>需要注意，虽然SYN和FIN flag本身不属于payload，也不需要push入byte stream，但是他们各需要占据一个sequence number，也就是<code>Reassembler</code>的index 0和最后一个index。需要思考需要怎样修改我们之前在Checkpoint1中实现的<code>Reassembler</code>中的<code>next_byte_index</code>方法。</p>          </div></li><li><p>根据记录下的ISN作为zero point和<code>Reassembler</code>在等待的next byte作为checkpoint，运用我们之前实现的Wrap32类将segment中32位的<code>seqno</code>转化为<code>Reassembler</code>中从0开始的64位的index(absolute sequence number)，并将转化后的index作为first_index，message的payload作为data，交给<code>Reassembler</code>处理。</p></li></ol><p><strong><code>TCPReceiver</code>的send方法需要负责：</strong></p><p>一句话概括：根据接收到的TCP segment，发送<code>TCPReceiverMessage</code>来告知TCP的发送端我们已经已接收到这个segment。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TCPReceiverMessage</span><br>&#123;<br>  std::optional&lt;Wrap32&gt; ackno &#123;&#125;;<br>  <span class="hljs-type">uint16_t</span> window_size &#123;&#125;;<br>  <span class="hljs-type">bool</span> RST &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>具体来说：</p><ol><li>如果byte stream有error，设置RST flag为true。</li><li>设置<code>ackno</code>为<code>Reassembler</code>正在等待的next byte对应的sequence number（用到Wrap32类将64位的next_byte_index(absolute sequence number)转化为32位的sequence number）。</li><li>设置window_size为<code>Reassembler</code>和<code>ByteStream</code>的available capacity，用来通知TCP的发送端进行flow control。</li></ol><p><strong>补充：</strong></p><p>以上的步骤都是笔者自己的实现思路，其中对SYN和FIN的处理有些messy，特别是考虑SYN和FIN的sequence number后我修改了<code>Reassembler</code>获取next_byte_index的方式。并且我用到了<code>Reassembler</code>中的一些private成员变量和函数，因此在<code>Reassembler</code>中将<code>TCPReceiver</code>声明为了友元，破坏了一定的封装性。但无伤大雅，最终能work，读者可梳理思路自行寻求更优的实现。</p><p>根据cs1441官方的spec，<code>TCPReceiver</code>的代码量只在15行左右，但要完全考虑到tests中的所有case实现起来还是有些tricky，笔者实现过程中遇到问题的test包括<code>recv_connect, recv_close, recv_special</code>，供读者参考。</p><h2 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish!</h2><p>All tests in check2 pass!</p><p><img src="../imgs/202502112148729-1739984480641-18-1739988772071-98.png" alt="Test check2" /></p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Protocol Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab 1</title>
    <link href="/2025/01/22/cs144-lab1/"/>
    <url>/2025/01/22/cs144-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-checkpoint-1-stitching-substrings-into-a-byte-stream"><a class="markdownIt-Anchor" href="#lab-checkpoint-1-stitching-substrings-into-a-byte-stream"></a> Lab Checkpoint 1: stitching substrings into a byte stream</h1><blockquote><p><a href="https://cs144.github.io/assignments/check1.pdf">Checkpoint1 spec</a></p></blockquote><blockquote><p>This checkpoint contains a “hands-on” component and an implementation component.</p><p>hands-on部分是今年新加的，需要加入Stanford内部网络才能做，因此跳过</p><p>在Lab1中，我们需要实现一个TCP接收端的重组器(Reassembler)，用来将TCP接收到的乱序的子字符串(substring)重组成原本的字节流，按照正确的顺序推送(push)到我们在Lab0实现的ByteStream中，供TCP的customer读出。</p></blockquote><h2 id="implementation-putting-substrings-in-sequence"><a class="markdownIt-Anchor" href="#implementation-putting-substrings-in-sequence"></a> Implementation: putting substrings in sequence</h2><blockquote><p>Why we need to implement the TCP receiver's reassembler? What does it do?</p></blockquote><p>The TCP receiver needs to handle duplication and reordering of segments, so it needs to have the ability to stitch arbitrary excerpts of the byte stream(unordered substrings) back into the original ordered stream.</p><p>To achieve this, the TCP receiver needs a <strong>reassembler</strong> to reassemble out-of-order byte stream.</p><p>The reassembler buffers unordered substrings that fit within the stream's available capacity until earlier gaps get filled in, discards substrings that lie beyond the stream's available capacity and push ordered substrings to the ByteStream. As the reader pops bytes from the ByteStream, the stream's sliding window slides across the stream and the reassembler can accept further bytes.</p><p><img src="../imgs/202501211617490-1739988671757-94-1739988703810-96.png" alt="TCP Receiver's sliding window" /></p><h3 id="my-solution"><a class="markdownIt-Anchor" href="#my-solution"></a> My Solution</h3><p>这个lab的关键是理解上图的TCP Receiver's sliding window。我建议自己理解后手动画一遍图再开始coding:</p><p><img src="../imgs/202502132129349-1739988664319-92.jpg" alt="My drawing of TCP Receiver's window" /></p><blockquote><p>当<code>Reassembler</code>接收到一个新的substring的时候，他要怎么做？</p></blockquote><p>根据上图，<code>ByteStream</code>的buffer空间（绿色区域）和<code>Reassembler</code>的internal storage空间（红色空间）合并起来是一个大小始终为capacity的sliding window。TCP的customer每从<code>ByteStream</code>中读出一个byte，sliding window就向右slide一个byte，<code>Reassembler</code>就可以接收更远一个byte。</p><p>当<code>Reassembler</code>新收到一个substring，他需要将substring在红色区域(available capacity)的部分先写入<code>Reassembler</code>的internal storage。因此首先，我们需要知道红色区域的上下界。</p><div class="note note-success">            <p>提示：红色区域的起始位置是<code>Reassembler</code>正在等待的next byte，想想这与<code>ByteStream</code>有什么联系？</p>          </div><blockquote><p>应该用什么data structure来表示<code>Reassembler</code>'s internal storage？</p></blockquote><p><code>Reassembler</code>需要存储接收到的substring，以及substring在stream中的位置(index)，因此我选择用一个<strong>map</strong>来存储&lt;key = first_index, value = substring&gt;。每次<code>Reassembler</code>接收到一个substring，截取substring在红色区域的部分插入map中，然后用一个<code>merge_substrings</code>函数来合并相邻或重叠的substrings。每次插入map以及合并后，检查map中的第一个元素的key是否是<code>Reassembler</code>正在等待的next byte，如果是，就将对应的substring push到<code>ByteStream</code>中。</p><h2 id="debugging-advice"><a class="markdownIt-Anchor" href="#debugging-advice"></a> Debugging Advice</h2><ol><li>To test your code:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake --build build --target check1<br></code></pre></td></tr></table></figure><ol start="2"><li>You may sometimes need to use the <code>move()</code> function to pass an object that can’t be copied.</li></ol><p>If you get your builds stuck and aren’t sure how to fix them, you can erase your build directory and build again</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf build<br>cmake -S . -B build<br></code></pre></td></tr></table></figure><h2 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish!</h2><p>All tests in check1 pass!</p><p><img src="../imgs/image-20250131174356176-1739984391752-11-1739986335339-13-1739988590210-90.png" alt="Test check1" /></p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Protocol Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab 0</title>
    <link href="/2025/01/19/cs144-lab0/"/>
    <url>/2025/01/19/cs144-lab0/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-checkpoint-0-networking-warmup"><a class="markdownIt-Anchor" href="#lab-checkpoint-0-networking-warmup"></a> Lab Checkpoint 0: networking warmup</h1><blockquote><p><a href="https://cs144.github.io/assignments/check0.pdf">Checkpoint0 spec</a></p><p>Expected hours to complete: 2-6 hours</p><p>Over the course of this 8-part lab assignment, you’ll be building up your own implementation of a significant portion of the Internet—<strong>a router, a network interface, and the TCP protocol</strong>.</p><p>在Lab0中，我们需要实现一个使用TCP套接字获取网页的简易Web客户端和一个内存中的可靠字节流(ByteStream)。</p></blockquote><h2 id="faqs"><a class="markdownIt-Anchor" href="#faqs"></a> FAQs</h2><blockquote><ol><li>What should the behavior of my program be if the caller tries to pop with a <code>len</code> greater than what is available?</li></ol></blockquote><p>We don't have any preference on the behavior if the caller tries to pop more than is buffered in the stream, as long as you behave reasonably and don't crash in that situation. If you want to pop the maximum available, that is fine with us. If you want to throw an exception, that is also fine with us.</p><blockquote><ol start="2"><li>How fast should my code be?</li></ol></blockquote><p>Here's a reasonable rule: if any of your tests are taking longer than 2 seconds, it's probably good to keep exploring other ways of representing the <code>ByteStream</code>. And if your benchmark results at the end of the test are worse than 0.1 Gbit/s (100 million bits per second), that's another sign the design may need to be rethought. This lab doesn't require any sophisticated data structures, but it might still take some trial-and-error to find a reasonable approach. Sometimes &quot;big-O&quot; analysis can be misleading about the performance of real programs—the constant factors can matter a lot!</p><h2 id="set-up-gnulinux-on-your-computer"><a class="markdownIt-Anchor" href="#set-up-gnulinux-on-your-computer"></a> Set up GNU/Linux on your computer</h2><p>Install the CS144 VirtualBox virtual-machine image (instructions at <a href="https://stanford.edu/class/cs144/vm_howto/vm-howto-image.html">https://stanford.edu/class/cs144/vm_howto/vm-howto-image.html</a>).</p><p>需要注意的是，VirtualBox需要直接在主机操作系统上运行，比如如果你是Windows主机，那么就需要在Windows系统中安装和运行VirtualBox（不能在WSL这样的虚拟环境中运行）</p><h2 id="networking-by-hand"><a class="markdownIt-Anchor" href="#networking-by-hand"></a> Networking by hand</h2><h3 id="fetch-a-web-page"><a class="markdownIt-Anchor" href="#fetch-a-web-page"></a> Fetch a Web Page</h3><ol><li>Fetch a web page <a href="http://cs144.keithw.org/hello">http://cs144.keithw.org/hello</a></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">telnet cs144.keithw<span class="hljs-meta">.org</span> http <br><br>GET /hello HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-symbol">Host:</span> cs144.keithw<span class="hljs-meta">.org</span><br><span class="hljs-symbol">Connection:</span> close<br></code></pre></td></tr></table></figure><img src="../imgs/202501171812928-1739988551547-84.png"><ol start="2"><li>Fetch a web page <a href="http://cs144.keithw.org/lab0/sunetid">http://cs144.keithw.org/lab0/sunetid</a></li></ol><p><img src="../imgs/202501171816688.png" alt="Fetch a web page" /></p><h3 id="send-yourself-an-email"><a class="markdownIt-Anchor" href="#send-yourself-an-email"></a> Send yourself an email</h3><p>这部分只有连接Stanford内部网络才能完成</p><h3 id="listening-and-connecting"><a class="markdownIt-Anchor" href="#listening-and-connecting"></a> Listening and connecting</h3><p>In this part, we play around with server and client.</p><h2 id="writing-a-network-program-using-an-os-stream-socket"><a class="markdownIt-Anchor" href="#writing-a-network-program-using-an-os-stream-socket"></a> Writing a network program using an OS stream socket</h2><blockquote><p>You’ll write a program called “webget” that creates a TCP stream socket, connects to a Web server, and fetches a page.</p></blockquote><h3 id="set-up"><a class="markdownIt-Anchor" href="#set-up"></a> Set up</h3><p>注意在<code>git clone</code>之前可能需要先在虚拟机中配置Git代理(使用主机的VPN)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 10809 端口</span><br>git config --global http.proxy http://10.0.2.2:10809<br>git config --global https.proxy http://10.0.2.2:10809<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前代理设置</span><br>git config --global --get http.proxy<br>git config --global --get https.proxy<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果需要取消 Git 代理</span><br>git config --global --unset http.proxy<br>git config --global --unset https.proxy<br></code></pre></td></tr></table></figure><h3 id="modern-c"><a class="markdownIt-Anchor" href="#modern-c"></a> Modern  C++</h3><ul><li><p>Use the language documentation at <a href="https://en.cppreference.com">https://en.cppreference.com</a> as a resource. (We’d recommend you avoid <a href="http://cplusplus.com">cplusplus.com</a> which is more likely to be out-of-date.)</p></li><li><p>Never use malloc() or free().</p></li><li><p>Never use new or delete.</p></li><li><p>Essentially <strong>never use raw pointers (*)</strong>, and use “smart” pointers (unique ptr or shared ptr) only when necessary. (You will not need to use these in CS144.)</p></li><li><p>Avoid templates, threads, locks, and virtual functions. (You will not need to use these in CS144.)</p></li><li><p>Avoid C-style <code>strings (char *str)</code> or string functions (<code>strlen()</code>, <code>strcpy()</code>). These are pretty error-prone. Use a <code>std::string</code> instead.</p></li><li><p>Never use C-style casts (e.g., <code>(FILE *)x</code>). Use a C++ <code>static_cast</code> if you have to (you generally will not need this in CS144)</p></li><li><p>Prefer passing function arguments by const reference (e.g.: <code>const Address &amp; address</code>)</p></li><li><p>Make every variable const unless it needs to be mutated.</p></li><li><p>Make every method const unless it needs to mutate the object.</p></li><li><p>Avoid global variables, and give every variable the smallest scope possible.</p></li><li><p>For suggestions on how to improve the code related to C++ programming practices:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">cmake</span> <span class="hljs-literal">--</span><span class="hljs-comment">build build</span> <span class="hljs-literal">--</span><span class="hljs-comment">target tidy</span><br></code></pre></td></tr></table></figure><p>To format the code:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">cmake</span> <span class="hljs-literal">--</span><span class="hljs-comment">build build</span> <span class="hljs-literal">--</span><span class="hljs-comment">target format</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="writing-webget"><a class="markdownIt-Anchor" href="#writing-webget"></a> Writing webget</h3><blockquote><p>Before writing <code>webget</code>, read over the public interfaces (the part that comes after “public:” in the files <code>util/socket.hh</code> and <code>util/file descriptor.hh</code>).</p></blockquote><p>In this part, we need to implement a simple Web client that fetches Web pages using a TCP socket provided by the operating system.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">( <span class="hljs-type">const</span> string&amp; host, <span class="hljs-type">const</span> string&amp; path )</span></span><br><span class="hljs-function"></span>&#123;<br>    TCPSocket clientSocket;<br>    <span class="hljs-function">Address <span class="hljs-title">serverAddress</span><span class="hljs-params">( host, <span class="hljs-string">&quot;http&quot;</span> )</span></span>;<br><br>    <span class="hljs-comment">// Connect to the server.</span><br>    clientSocket.<span class="hljs-built_in">connect</span>( serverAddress );<br><br>    <span class="hljs-comment">// Send the HTTP request.</span><br>    string request = <span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="hljs-string">&quot;\r\n&quot;</span> +           <span class="hljs-string">&quot;Connection: close\r\n\r\n&quot;</span>;<br>    clientSocket.<span class="hljs-built_in">write</span>( (string_view)request );<br><br>    <span class="hljs-comment">// Read and print the response</span><br>    <span class="hljs-keyword">while</span> ( !clientSocket.<span class="hljs-built_in">eof</span>() ) &#123;<br>        string response;<br>        clientSocket.<span class="hljs-built_in">read</span>( response );<br>        cout &lt;&lt; response;<br>    &#125;<br><br>    clientSocket.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="../imgs/202501191501409-1739986305650-9-1739988551547-86.png" alt="Test webget" /></p><h2 id="an-in-memory-reliable-byte-stream"><a class="markdownIt-Anchor" href="#an-in-memory-reliable-byte-stream"></a> An in-memory reliable byte stream</h2><p>In this part, we need to implement a <code>ByteStream</code> object that provides reliable byte stream in memory. The Writer writes data into the stream and the Reader reads data from the stream.</p><blockquote><p>What is the design of my <code>ByteStream</code> implementatino? What data structures and approach are taken?</p></blockquote><p>设计这个<code>ByteStream</code>的关键在于选择用什么data structure来表示内存中存储数据的stream。这个data structure需要方便从一端写入，从另一端读出，以及peek其中存储的数据。</p><p>我第一个想到的是用queue，但是queue只能读取队列首尾的元素，不方便peek。</p><p>因此可以用<code>vector&lt;char&gt;</code>或者string，我这里选择用最直观的string。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string buffer_ &#123;&#125;;<br></code></pre></td></tr></table></figure><p>这样的话Writer的push很简单，直接用string的append函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Writer::push</span><span class="hljs-params">( string data )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Push data to the buffer, but only as much as available capacity allows.</span><br>  <span class="hljs-type">uint64_t</span> to_write = <span class="hljs-built_in">min</span>( <span class="hljs-built_in">available_capacity</span>(), data.<span class="hljs-built_in">size</span>() );<br>  buffer_.<span class="hljs-built_in">append</span>( data, <span class="hljs-number">0</span>, to_write );<br>  bytes_pushed_ += to_write;<br>&#125;<br></code></pre></td></tr></table></figure><p>那Reader的pop如何实现呢?</p><p>最容易想到的是每次pop <code>len</code> bytes的时候都将<code>buffer_</code>的前<code>len</code>个字符截掉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">buffer_ = buffer_.<span class="hljs-built_in">substr</span>( len );<br></code></pre></td></tr></table></figure><p>但是这样的话每次pop <code>buffer_</code>的内存都会重新分配，不符合pop 操作是 O(1) 的时间复杂度要求。</p><p>因此我想到用一个<code>read_index_</code>来追踪当前<code>buffer_</code>中读到的位置，这样每次pop只需要<code>read_index_ += len</code>，只在<code>buffer_</code>中已读过的bytes过多（超过<code>buffer_ </code>size的一半）时再重新整理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reader::pop</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> len )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Pop as much data as possible from the buffer if len is greater than the         amount of data available.</span><br>    <span class="hljs-type">uint64_t</span> to_read = <span class="hljs-built_in">min</span>( <span class="hljs-built_in">bytes_buffered</span>(), len );<br>    read_index_ += to_read;<br>    bytes_popped_ += to_read;<br><br>    <span class="hljs-comment">// When more than half of the buffer is read, shrink it to avoid unnecessary       memory usage.</span><br>    <span class="hljs-keyword">if</span> ( read_index_ &gt;= buffer_.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> ) &#123;<br>        buffer_ = buffer_.<span class="hljs-built_in">substr</span>( read_index_ );<br>        read_index_ = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话<code>buffer_</code>中<code>read_index</code>之前的bytes是已经读过out of date的bytes，<code>read_index</code>之后的bytes才是被push进stream中等待被读取的bytes。</p><h2 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish!</h2><p>All tests in check0 pass!</p><p><img src="../imgs/202502192350617-1739986312677-11-1739988551547-85.png" alt="Test check0" /></p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Protocol Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NTU C++ Note</title>
    <link href="/2025/01/18/NTU-C++/"/>
    <url>/2025/01/18/NTU-C++/</url>
    
    <content type="html"><![CDATA[<p>NTU有一个开源的<a href="https://www3.ntu.edu.sg/home/ehchua/programming/">programming notes</a>写的非常好，里面包含了各种语言。其中C++ Note部分非常适合用来快速巩固cpp的各种基础语法和特性（不包含modern cpp的内容），我这里用一篇笔记总结了cpp programming notes中的重点内容，希望对你的学习有帮助！</p><h1 id="something-in-c"><a class="markdownIt-Anchor" href="#something-in-c"></a> Something in C…</h1><blockquote><p>在进入C++之前，首先复习一下C语言中一些容易出问题和忽视的知识点。这一部分不在NTU Note里面，是我自己补充的。</p></blockquote><h4 id="数组初始化"><a class="markdownIt-Anchor" href="#数组初始化"></a> 数组初始化</h4><p>数组在定义时就进行初始化，最常用在把数组元素全部初始化为0的时候。</p><p>比如，以下代码会将数组a的所有元素都初始化为0：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int a[<span class="hljs-number">10</span>] <span class="hljs-operator">=</span> &#123;<span class="hljs-number">0</span>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>拓展一下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int a[<span class="hljs-number">10</span>] <span class="hljs-operator">=</span> &#123;<span class="hljs-number">1</span>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上述代码中，初始化后的数组a是不是所有元素均为1呢？答案是否定的。只有a[0]会被初始化为1，而a[1~9]会被默认初始化为0，这点需要注意。</p><h4 id="volatile关键字"><a class="markdownIt-Anchor" href="#volatile关键字"></a> Volatile关键字</h4><p>在C语言中，volatile关键字用于告诉编译器该变量可能会在任何时候被意想不到地改变（比如多线程情况下），因此，编译器在生成代码时不应对此变量进行优化，使得在用到这个变量时必须每次都重新从内存中读取这个变量的值，而不是使用保存在寄存器里的备份。</p><h4 id="static关键字"><a class="markdownIt-Anchor" href="#static关键字"></a> Static关键字</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum_func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;    <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> b=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 局部静态变量只会被初始化一次</span><br>    <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;    <br>    b+=<span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">return</span>(a+b+c);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <br>    <span class="hljs-type">int</span> i;    <br>    <span class="hljs-type">int</span> a=<span class="hljs-number">2</span>;    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,&quot;</span>, sum_func(a));    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行上述代码输出：5、6、7、8、9</p><h4 id="宏定义和typedef"><a class="markdownIt-Anchor" href="#宏定义和typedef"></a> 宏定义和typedef</h4><p>宏定义参数需要将参数用括号括起来！</p><blockquote><p>宏定义和typedef的区别？</p></blockquote><p>宏定义是将定义的表达式直接替换展开到调用宏的代码处，容易产生错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dS struct s * </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s</span> * <span class="hljs-title">tS</span>;</span> <br><br>dS p1,p2;<br>tS p3,p4;<br></code></pre></td></tr></table></figure><p>第一个例子在宏定义展开替换后为<code>Struct s *p1, p2;</code>，定义p1为一个指向结构体s的指针，而p2为一个实际的结构体类型为s的结构。而第二个例子正确地定义了p3和p4两个指向结构体的指针。</p><p>所以一般在用于<strong>为一个已经存在的类型创建一个新的名字</strong>时，应尽量使用typedef，而不是#define。</p><h1 id="c-basics"><a class="markdownIt-Anchor" href="#c-basics"></a> C++ Basics</h1><h4 id="io-manipulators"><a class="markdownIt-Anchor" href="#io-manipulators"></a> IO Manipulators</h4><p>Formatting Input/Output using IO Manipulators (Header <iomanip>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span>    <span class="hljs-comment">// Needed to do formatted I/O</span></span><br></code></pre></td></tr></table></figure><h4 id="multi-dimensional-array"><a class="markdownIt-Anchor" href="#multi-dimensional-array"></a> Multi-Dimensional Array</h4><p>For 2D array (table), the first index is the row number, second index is the column number.</p><p>The elements are stored in a so-called <em><strong>row-major</strong></em> manner, where the column index runs out first.</p><p><img src="../imgs/202412220901630.png" alt="2D array" /></p><p>Array is passed into function by reference. That is, the invoked function works on the same copy of the array as the caller.</p><h4 id="sorting-algorithm"><a class="markdownIt-Anchor" href="#sorting-algorithm"></a> Sorting Algorithm</h4><ol><li>Bubble sort</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Sort the given array of size</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>   <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>; <span class="hljs-comment">// terminate if no more swap thru a pass</span><br>   <span class="hljs-type">int</span> temp;          <span class="hljs-comment">// use for swapping</span><br> <br>   <span class="hljs-keyword">while</span> (!done) &#123;<br>      done = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// Pass thru the list, compare adjacent items and swap</span><br>      <span class="hljs-comment">// them if they are in wrong order</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; ++i) &#123;<br>         <span class="hljs-keyword">if</span> (a[i] &gt; a[i+<span class="hljs-number">1</span>]) &#123;<br>            temp = a[i];<br>            a[i] = a[i+<span class="hljs-number">1</span>];<br>            a[i+<span class="hljs-number">1</span>] = temp;<br>            done = <span class="hljs-literal">false</span>;   <span class="hljs-comment">// swap detected, one more pass</span><br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>Insertion sort</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Sort the given array of size using insertion sort</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>   <span class="hljs-type">int</span> temp;   <span class="hljs-comment">// for shifting elements</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; ++i) &#123;<br>      <span class="hljs-comment">// For element at i, insert into proper position in [0, i-1]</span><br>      <span class="hljs-comment">// which is already sorted.</span><br>      <span class="hljs-comment">// Shift down the other elements</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> prev = <span class="hljs-number">0</span>; prev &lt; i; ++prev) &#123;<br>         <span class="hljs-keyword">if</span> (a[i] &lt; a[prev]) &#123;<br>            <span class="hljs-comment">// insert a[i] at prev, shift the elements down</span><br>            temp = a[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> shift = i; shift &gt; prev; --shift) &#123;<br>               a[shift] = a[shift<span class="hljs-number">-1</span>];<br>            &#125;<br>            a[prev] = temp;<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>Selection sort</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Sort the given array of size using selection sort</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>   <span class="hljs-type">int</span> temp; <span class="hljs-comment">// for swapping</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-comment">// [0, i-1] already sort</span><br>      <span class="hljs-comment">// Search for the smallest element in [i, size-1]</span><br>      <span class="hljs-comment">// and swap with a[i]</span><br>      <span class="hljs-type">int</span> minIndex = i;  <span class="hljs-comment">// assume fist element is the smallest</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; size; ++j) &#123;<br>         <span class="hljs-keyword">if</span> (a[j] &lt; a[minIndex]) minIndex = j;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (minIndex != i) &#123;  <span class="hljs-comment">// swap</span><br>         temp = a[i];<br>         a[i] = a[minIndex];<br>         a[minIndex] = temp;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="namespace"><a class="markdownIt-Anchor" href="#namespace"></a> Namespace</h4><p>To place an entity under a namespace, use keyword <code>namespace</code> as follow:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// create a namespace called myNamespace for the enclosed entities</span><br><span class="hljs-keyword">namespace</span> myNameSpace &#123;  <br>   <span class="hljs-type">int</span> foo;               <span class="hljs-comment">// variable</span><br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; ...... &#125;;    <span class="hljs-comment">// function</span><br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123; ...... &#125;;  <span class="hljs-comment">// compound type such as class and struct</span><br>&#125;<br> <br><span class="hljs-comment">// To reference the entities, use</span><br><span class="hljs-function">myNameSpace::foo</span><br><span class="hljs-function"><span class="hljs-title">myNameSpace::f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">myNameSpace::Bar</span><br></code></pre></td></tr></table></figure><h4 id="enumeration-enum"><a class="markdownIt-Anchor" href="#enumeration-enum"></a> Enumeration (enum)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>   RED, GREEN, BLUE<br>&#125; myColor;        <span class="hljs-comment">// Define an enum and declare a variable of the enum</span><br>......<br>myColor = RED;    <span class="hljs-comment">// Assign a value to an enum</span><br>Color yourColor;<br>yourColor = GREEN;<br></code></pre></td></tr></table></figure><h4 id="ellipses"><a class="markdownIt-Anchor" href="#ellipses"></a> Ellipses (...)</h4><p>Ellipses (<code>...</code>) can be used as the <em>last</em> parameter of a function to denote zero or more arguments of unknown type.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  TestEllipses.cpp</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdarg&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>, ...)</span></span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   cout &lt;&lt; <span class="hljs-built_in">sum</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;       <span class="hljs-comment">// 6</span><br>   cout &lt;&lt; <span class="hljs-built_in">sum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; endl; <span class="hljs-comment">// 15</span><br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> </span>&#123;<br>   <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br> <br>   <span class="hljs-comment">// Ellipses are accessed thru a va_list</span><br>   va_list lst;  <span class="hljs-comment">// Declare a va_list</span><br>   <span class="hljs-comment">// Use function va_start to initialize the va_list,</span><br>   <span class="hljs-comment">// with the list name and the number of parameters.</span><br>   <span class="hljs-built_in">va_start</span>(lst, count);<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>      <span class="hljs-comment">// Use function va_arg to read each parameter from va_list,</span><br>      <span class="hljs-comment">// with the type.</span><br>      sum += <span class="hljs-built_in">va_arg</span>(lst, <span class="hljs-type">int</span>);<br>   &#125;<br>   <span class="hljs-comment">// Cleanup the va_list.</span><br>   <span class="hljs-built_in">va_end</span>(lst);<br> <br>   <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="function-pointer"><a class="markdownIt-Anchor" href="#function-pointer"></a> Function Pointer</h4><p>The syntax for declaring a function pointer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Function-pointer declaration</span><br><span class="hljs-keyword">return</span>-<span class="hljs-built_in">type</span> (* function-ptr-name) (parameter-list)<br> <br><span class="hljs-comment">// Examples</span><br><span class="hljs-built_in">double</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)  <span class="hljs-comment">// fp points to a function that takes two ints and returns a double (function-pointer)</span><br><span class="hljs-type">double</span> *dp;          <span class="hljs-comment">// dp points to a double (double-pointer)</span><br><span class="hljs-function"><span class="hljs-type">double</span> *<span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>   <span class="hljs-comment">// fun is a function that takes two ints and returns a double-pointer</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;      <span class="hljs-comment">// f is a function that takes two ints and returns a double</span><br>fp = f;            <span class="hljs-comment">// Assign function f to fp function-pointer</span><br></code></pre></td></tr></table></figure><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Test Function Pointers (TestFunctionPointer.cpp) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">arithmetic</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span> (*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>))</span></span>;<br>    <span class="hljs-comment">// Take 3 arguments, 2 int&#x27;s and a function pointer</span><br>    <span class="hljs-comment">//   int (*)(int, int), which takes two int&#x27;s and return an int</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span> </span>&#123; <span class="hljs-keyword">return</span> n1 + n2; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span> </span>&#123; <span class="hljs-keyword">return</span> n1 - n2; &#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">arithmetic</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2, <span class="hljs-type">int</span> (*operation) (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>))</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> (*operation)(n1, n2);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-type">int</span> number1 = <span class="hljs-number">5</span>, number2 = <span class="hljs-number">6</span>;<br> <br>   <span class="hljs-comment">// add</span><br>   cout &lt;&lt; <span class="hljs-built_in">arithmetic</span>(number1, number2, add) &lt;&lt; endl;<br>   <span class="hljs-comment">// subtract</span><br>   cout &lt;&lt; <span class="hljs-built_in">arithmetic</span>(number1, number2, sub) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="object-oriented-programming-oop-in-c"><a class="markdownIt-Anchor" href="#object-oriented-programming-oop-in-c"></a> Object-Oriented Programming (OOP) in C++</h1><h4 id="const-member-functions"><a class="markdownIt-Anchor" href="#const-member-functions"></a> &quot;const&quot; Member Functions</h4><p>A const member function, identified by a const keyword at the end of the member function's header, <strong>cannot modifies any data member</strong> of this object. For example,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <span class="hljs-comment">// const member function</span><br>   radius = <span class="hljs-number">0</span>;  <br>      <span class="hljs-comment">// error: assignment of data-member &#x27;Circle::radius&#x27; in read-only structure</span><br>   <span class="hljs-keyword">return</span> radius;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="constructors-member-initializer-list"><a class="markdownIt-Anchor" href="#constructors-member-initializer-list"></a> Constructor's Member Initializer List</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">1.0</span>, string c = <span class="hljs-string">&quot;red&quot;</span>) : <span class="hljs-built_in">radius</span>(r), <span class="hljs-built_in">color</span>(c) &#123; &#125;<br></code></pre></td></tr></table></figure><p>Object data member shall be constructed via the member initializer list, not in the body.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Book::<span class="hljs-built_in">Book</span>(string name, Author author, <span class="hljs-type">double</span> price, <span class="hljs-type">int</span> qtyInStock) : <span class="hljs-built_in">name</span>(name), <span class="hljs-built_in">author</span>(author) &#123;<br>   <span class="hljs-built_in">setPrice</span>(price);<br>   <span class="hljs-built_in">setQtyInStock</span>(qtyInStock);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="copy-constructor"><a class="markdownIt-Anchor" href="#copy-constructor"></a> Copy Constructor</h4><p>The default copy constructor performs <em>shadow copy</em>. It does <strong>not</strong> copy the dynamically allocated data members created via <code>new</code> or <code>new[]</code> operator.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   T1 member1;<br>   T2 member2;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// The default copy constructor which constructs an object via memberwise copy</span><br>   <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass &amp; rhs) &#123;<br>      member1 = rhs.member1;<br>      member2 = rhs.member2;<br>   &#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Default copy constructor of Author class provided by C++</span><br>Author::<span class="hljs-built_in">Author</span>(<span class="hljs-type">const</span> Author&amp; other)<br>      : <span class="hljs-built_in">name</span>(other.name), <span class="hljs-built_in">email</span>(other.email), <span class="hljs-built_in">gender</span>(other.gender) &#123; &#125;  <span class="hljs-comment">// memberwise copy</span><br></code></pre></td></tr></table></figure><ul><li><strong>Copy Assignment Operator</strong></li></ul><p>The default copy assignment operator performs <em>shadow copy</em>. It does <strong>not</strong> copy the dynamically allocated data members created via <code>new</code> or <code>new[]</code> operator.</p><div class="note note-danger">            <p>The <strong>copy constructor</strong>, instead of copy assignment operator, is used in declaration:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Circle c8 = c6;  <span class="hljs-comment">// Invoke the copy constructor, NOT copy assignment operator</span><br>                 <span class="hljs-comment">// Same as Circle c8(c6)</span><br></code></pre></td></tr></table></figure>          </div><p>The copy assignment operator has the following signature:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   T1 member1;<br>   T2 member2;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// The default copy assignment operator which assigns an object via memberwise copy</span><br>   MyClass &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass &amp; rhs) &#123;<br>      member1 = rhs.member1;<br>      member2 = rhs.member2;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>   &#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>You could <strong>overload</strong> the assignment operator to override the default.</p><blockquote><p>Why do we use <code>const classname &amp;</code>?</p></blockquote><p>The pass-by-reference prevents the large copy cost by pass-by-value, while keeping the values of the members in <code>rhs</code> unchanged.</p><div class="note note-primary">            <p>The default copy constructor and assignment operator are both <strong>shadow copy</strong>.</p><p>If you use <code>new</code> (or <code>new[]</code>) to dynamically allocate memory in the constructor to object data member pointers, you should define a copy constructor and assignment operator that <strong>deep copies</strong> one object into another.</p>          </div><ul><li><strong>Example</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   T * pObj;   <span class="hljs-comment">// object data member pointer</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// Constructors</span><br>   <span class="hljs-built_in">ClassName</span>(...) &#123;<br>      pObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(...); <span class="hljs-comment">// or new[]</span><br>      ....<br>   &#125;<br>   <span class="hljs-comment">// Destructor</span><br>   ~<span class="hljs-built_in">ClassName</span>() &#123;<br>      <span class="hljs-keyword">delete</span> pObj;      <span class="hljs-comment">// OR delete[]</span><br>   &#125;<br>   <span class="hljs-comment">// Copy constructor</span><br>   <span class="hljs-function">ClassName &amp; <span class="hljs-title">ClassName</span><span class="hljs-params">(<span class="hljs-type">const</span> ClassName &amp;)</span></span>;<br> <br>   <span class="hljs-comment">// Overload Assignment Operator</span><br>   ClassName &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ClassName &amp;);   <br>......<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="exception-handling"><a class="markdownIt-Anchor" href="#exception-handling"></a> Exception Handling</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Time::setHour</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span></span><br><span class="hljs-function">   <span class="hljs-title">if</span> <span class="hljs-params">(h &gt;= <span class="hljs-number">0</span> &amp;&amp; h &lt;= <span class="hljs-number">23</span>)</span> </span>&#123;<br>      hour = h;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid hour! Hour shall be 0-23.&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TestTime.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Test Driver for the Time class (TestTime.cpp) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span>  <span class="hljs-comment">// Needed for exception handling</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Time.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">//   Time t2(25, 0, 0); // program terminates abruptly</span><br>   <span class="hljs-comment">//   t2.print();        // The rest of program will not be run</span><br> <br>   <span class="hljs-comment">// Graceful handling of exception</span><br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-function">Time <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">25</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// Skip the remaining statements in try-clause an jump to catch-clause if an exception is thrown</span><br>      t1.<span class="hljs-built_in">print</span>();<br>      <span class="hljs-comment">// Continue to the next statement after try-catch, if there is no exception</span><br>   &#125; <span class="hljs-built_in">catch</span> (invalid_argument&amp; ex) &#123;  <span class="hljs-comment">// need &lt;stdexcept&gt;</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>         <span class="hljs-comment">// Continue to the next statement after try-catch</span><br>   &#125;<br>   cout &lt;&lt; <span class="hljs-string">&quot;Next statement after try-catch&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="static-keyword-in-class"><a class="markdownIt-Anchor" href="#static-keyword-in-class"></a> <code>static</code> keyword in class</h4><p><code>Date.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> year;    <span class="hljs-comment">// 1753-9999</span><br>   <span class="hljs-type">int</span> month;   <span class="hljs-comment">// 1-12</span><br>   <span class="hljs-type">int</span> day;     <span class="hljs-comment">// 1-31</span><br>   <span class="hljs-type">const</span> <span class="hljs-type">static</span> string STR_MONTHS[];<br>   <span class="hljs-type">const</span> <span class="hljs-type">static</span> string STR_DAYS[];<br>   <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> DAYS_IN_MONTHS[];<br>   <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> YEAR_MIN = <span class="hljs-number">1753</span>;<br>   <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> YEAR_MAX = <span class="hljs-number">9999</span>;<br><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isLeapYear</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValidDate</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getDayOfWeek</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Date.c</code>:</p><p>Static variable should be initialized outside the class declaration.</p><p>Static members(data and functions) are owned by the class, not the objects(instances).</p><p>A <code>static</code> function can only access <code>static</code> variables, and cannot access non-<code>static</code> variables.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Initialize static non-integer variable (must be done outside the class declaration)</span><br><span class="hljs-type">const</span> string Date::STR_MONTHS[] = &#123;<span class="hljs-string">&quot;Jan&quot;</span>, <span class="hljs-string">&quot;Feb&quot;</span>, <span class="hljs-string">&quot;Mar&quot;</span>, <span class="hljs-string">&quot;Apr&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>, <span class="hljs-string">&quot;Jun&quot;</span>, <span class="hljs-string">&quot;Jul&quot;</span>, <span class="hljs-string">&quot;Aug&quot;</span>, <span class="hljs-string">&quot;Sep&quot;</span>, <span class="hljs-string">&quot;Oct&quot;</span>, <span class="hljs-string">&quot;Nov&quot;</span>, <span class="hljs-string">&quot;Dec&quot;</span>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Date::DAYS_IN_MONTHS[] = &#123;<span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-type">const</span> string Date::STR_DAYS[] = &#123;<span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>&#125;;<br><br><span class="hljs-comment">// A static function that returns true if the given year is a leap year</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Date::isLeapYear</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> ((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>));<br>&#125;<br> <br><span class="hljs-comment">// A static function that returns true if the given y, m, d constitutes a valid date</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Date::isValidDate</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (y &gt;= YEAR_MIN &amp;&amp; y &lt;= YEAR_MAX &amp;&amp; m &gt;= <span class="hljs-number">1</span> &amp;&amp; m &lt;= <span class="hljs-number">12</span>) &#123;<br>      <span class="hljs-type">int</span> lastDayOfMonth = DAYS_IN_MONTHS[m<span class="hljs-number">-1</span>];<br>      <span class="hljs-keyword">if</span> (m == <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">isLeapYear</span>(y)) &#123;<br>         lastDayOfMonth = <span class="hljs-number">29</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> (d &gt;= <span class="hljs-number">1</span> &amp;&amp; d &lt;= lastDayOfMonth);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>&#125;<br> <br><span class="hljs-comment">// A static function that returns the day of the week (0:Sun, 6:Sat) for the given date</span><br><span class="hljs-comment">// Wiki &quot;Determination of the day of the week&quot; for the algorithm</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::getDayOfWeek</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>   <span class="hljs-type">int</span> centuryTable[] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>&#125;; <span class="hljs-comment">// 17xx, 18xx, ...</span><br>   <span class="hljs-type">int</span> MonthTable[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>   <span class="hljs-type">int</span> MonthLeapYearTable[] = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br> <br>   <span class="hljs-type">int</span> century = y / <span class="hljs-number">100</span>;<br>   <span class="hljs-type">int</span> twoDigitYear = y % <span class="hljs-number">100</span>;<br>   <span class="hljs-type">int</span> centuryTableIndex = (century - <span class="hljs-number">17</span>) % <span class="hljs-number">8</span>;<br>   <span class="hljs-comment">// Date before 17xx are not valid, but needed to prevent negative index</span><br>   <span class="hljs-keyword">if</span> (centuryTableIndex &lt; <span class="hljs-number">0</span>) &#123;<br>      centuryTableIndex += <span class="hljs-number">8</span>;<br>   &#125;<br>   <span class="hljs-type">int</span> sum = centuryTable[centuryTableIndex] + twoDigitYear + twoDigitYear / <span class="hljs-number">4</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isLeapYear</span>(y)) &#123;<br>      sum += MonthLeapYearTable[m<span class="hljs-number">-1</span>];<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      sum += MonthTable[m<span class="hljs-number">-1</span>];<br>   &#125;<br>   sum += d;<br>   <span class="hljs-keyword">return</span> sum % <span class="hljs-number">7</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="inheritance-and-polymophism"><a class="markdownIt-Anchor" href="#inheritance-and-polymophism"></a> Inheritance and Polymophism</h1><h4 id="inheritance"><a class="markdownIt-Anchor" href="#inheritance"></a> Inheritance</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubclassName</span> : inheritance-access-specifier SuperclassName &#123;<br>   ......<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>Access Specifier:</strong></li></ul><p>A <code>private</code> member is accessible within the <strong>class</strong> by member functions and by <strong><em>friends</em> of that class</strong>.</p><p>A <code>public</code> member is accessible by all.</p><p>A <code>protected</code> member can be accessed by <strong>itself and its friend</strong>, as well as its <strong>subclasses and their friends</strong>.</p><ul><li><strong>Inheritance Access Specifier:</strong></li></ul><p><code>public</code>-inheritance(most common): <code>public</code> members in the superclass becomes <code>public</code> members in the derived class; <code>protected</code> members in the base class become <code>protected</code> member in the derived class.</p><p><code>protected</code>-inheritance: <code>public</code> and <code>protected</code> members in the base class become <code>protected</code> members in the derived class.</p><p><code>private</code>-inheritance: <code>public</code> and <code>protected</code> members in the base class become <code>private</code> member in the derived class.</p><div class="note note-info">            <p>When the subclass construct its instance, it must first construct a superclass object, which it inherited.</p>          </div><h4 id="polymorphism"><a class="markdownIt-Anchor" href="#polymorphism"></a> Polymorphism</h4><blockquote><p>One interface, multiple implementations. Use virtual functions.</p></blockquote><div class="note note-info">            <p>Polymorphism works on <strong>object pointers</strong> and <strong>references</strong> using so-called <strong>dynamic binding at run-time</strong>.</p><p>Does not work on regular objects, which uses <strong>static binding</strong> during the compile-time:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Using object with explicit constructor</span><br>   Point p3 = <span class="hljs-built_in">MovablePoint</span>(<span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>);  <span class="hljs-comment">// upcast</span><br>   p3.<span class="hljs-built_in">print</span>();     <span class="hljs-comment">// Point @ (31,32) - Run superclass version!!</span><br>   cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><strong>Virtual Functions:</strong> To implement polymorphism, we need to use the keyword <code>virtual</code> for functions that are meant to be polymorphic.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Point.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>   ......<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>It is recommended that functions to be <strong>overridden</strong> in the subclass be declared <code>virtual</code> in the superclass.</p><p>Constructor can't be <code>virtual</code>, because it is not inherited. Subclass defines its own constructor, which <strong>invokes the superclass constructor</strong> to initialize the inherited data members.</p><p>Destructor should be declared virtual, if a class is to be used as a superclass, so that the appropriate object destructor is invoked to free the dynamically allocated memory in the subclass, if any.</p><p>If you override function in the subclass, the overridden function shall have the <strong>same parameter list</strong> as the superclass' version.</p>          </div><ul><li><strong>Pure Virtual Function</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// Pure virtual function, to be implemented by subclass</span><br></code></pre></td></tr></table></figure><p>The <code>=0</code> simply make the class <em>abstract</em>. As the result, you cannot create instances.</p><div class="note note-danger">            <p>const object cannot invoke non-const member function</p><p>const data member can only be initialized by the constructor using <em>member initializer list</em></p>          </div><h4 id="friend-function-and-friend-class"><a class="markdownIt-Anchor" href="#friend-function-and-friend-class"></a> <code>friend</code> function and <code>friend</code> class</h4><ul><li><strong>friend function</strong></li></ul><p>Friend functions are declared inside the class and are implemented outside the class.</p><p>Friend functions are not the members of the class, but their arguments of the class can access all class members.</p><p>Friend functions will not be inherited by the subclass. Friends can't be virtual, as friends are not class member.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>   <span class="hljs-comment">// A friend function defined outside this class, but its argument of</span><br>   <span class="hljs-comment">// this class can access all class members (including private members).</span><br>   <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Point &amp; point, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;  <span class="hljs-comment">// prototype</span><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> x, y;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123; &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br> <br><span class="hljs-comment">// Friend function is defined outside the class</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Point &amp; point, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>  point.x = x;  <span class="hljs-comment">// can access private data x and y</span><br>  point.y = y;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>friend class</strong></li></ul><p>To declare all member functions of a class (says <code>Class1</code>) friend functions of another class (says <code>Class2</code>), declared &quot;<code>friend class Class1;</code>&quot; in <code>Class2</code>.</p><h1 id="operator-overloading"><a class="markdownIt-Anchor" href="#operator-overloading"></a> Operator Overloading</h1><h4 id="user-defined-operator-overloading"><a class="markdownIt-Anchor" href="#user-defined-operator-overloading"></a> User-defined Operator Overloading</h4><p>operator function:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span>-type <span class="hljs-keyword">operator</span>Δ(parameter-list)<br></code></pre></td></tr></table></figure><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Member function overloading &#x27;+&#x27; operator</span><br><span class="hljs-type">const</span> Point Point::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp; rhs) <span class="hljs-type">const</span> &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x + rhs.x, y + rhs.y);<br>   <span class="hljs-comment">// Return by value as local variable cannot be returned by reference</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Usage:</p><p><code>p1 + p2 = p1.operator+(p2)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Invoke via usual dot syntax, same as p1+p2</span><br>Point p4 = p1.<span class="hljs-keyword">operator</span>+(p2);<br>p4.<span class="hljs-built_in">print</span>();  <span class="hljs-comment">// (5,7)</span><br><br><span class="hljs-comment">// Chaining</span><br>Point p5 = p1 + p2 + p3 + p4;<br>p5.<span class="hljs-built_in">print</span>();  <span class="hljs-comment">// (15,21)</span><br></code></pre></td></tr></table></figure><h4 id="overloading-operator-via-friend-non-member-function"><a class="markdownIt-Anchor" href="#overloading-operator-via-friend-non-member-function"></a> Overloading Operator via &quot;friend&quot; non-member function</h4><blockquote><p>Why can't we always use Member Function for Operator Overloading?</p></blockquote><p>You cannot use member function to overload an operator if the <strong>left operand is not an object</strong> of that particular class.</p><p>Use non-member <code>friend</code> function!</p><p>Example:</p><div class="note note-info">            <p>Return type of the operator &lt;&lt;(&gt;&gt;) function is the reference of the stream object.</p>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Class Declaration</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> x, y;<br> <br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>);<br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// Getters</span><br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>; <span class="hljs-comment">// Setters</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span>;<br> <br>   <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; out, <span class="hljs-type">const</span> Point &amp; point);<br>   <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp; in, Point &amp; point);<br>&#125;;<br><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; out, <span class="hljs-type">const</span> Point &amp; point) &#123;<br>   out &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; point.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; point.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;  <span class="hljs-comment">// access private data</span><br>   <span class="hljs-keyword">return</span> out;<br>&#125;<br> <br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; in, Point &amp; point) &#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;Enter x and y coord: &quot;</span>;<br>   in &gt;&gt; point.x &gt;&gt; point.y;  <span class="hljs-comment">// access private data</span><br>   <span class="hljs-keyword">return</span> in;<br>&#125;<br></code></pre></td></tr></table></figure><p>Usage:</p><p><code>cout &lt;&lt; p1</code> = <code>operator&lt;&lt;(cout, p1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span>, p2</span>;<br> <br>   <span class="hljs-comment">// Using overloaded operator &lt;&lt;</span><br>   cout &lt;&lt; p1 &lt;&lt; endl;    <span class="hljs-comment">// support cascading</span><br>   <span class="hljs-keyword">operator</span>&lt;&lt;(cout, p1);  <span class="hljs-comment">// same as cout &lt;&lt; p1</span><br>   cout &lt;&lt; endl;<br> <br>   <span class="hljs-comment">// Using overloaded operator &gt;&gt;</span><br>   cin &gt;&gt; p1;<br>   cout &lt;&lt; p1 &lt;&lt; endl;<br>   <span class="hljs-keyword">operator</span>&gt;&gt;(cin, p1);  <span class="hljs-comment">// same as cin &gt;&gt; p1</span><br>   cout &lt;&lt; p1 &lt;&lt; endl;<br>   cin &gt;&gt; p1 &gt;&gt; p2;      <span class="hljs-comment">// support cascading</span><br>   cout &lt;&lt; p1 &lt;&lt; endl;<br>   cout &lt;&lt; p2 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>The overloaded &gt;&gt; and &lt;&lt; can also be used for file input/output, as the file IO stream <code>ifstream</code>/<code>ofstream</code> (in <code>fstream</code> header) is a subclass of <code>istream</code>/<code>ostream</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Point.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br> <br>   <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;out.txt&quot;</span>)</span></span>;<br>   fout &lt;&lt; p1 &lt;&lt; endl;<br> <br>   <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;in.txt&quot;</span>)</span></span>; <span class="hljs-comment">// contains &quot;3 4&quot;</span><br>   fin &gt;&gt; p1;<br>   cout &lt;&lt; p1 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>How to overload unary postfix operator?</p></blockquote><p>Introduce a &quot;dummy&quot; argument!</p><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">Counter</span>(<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>);   <span class="hljs-comment">// Constructor</span><br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;     <span class="hljs-comment">// Getters</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span></span>; <span class="hljs-comment">// Setters</span><br>   Counter &amp; <span class="hljs-keyword">operator</span>++();              <span class="hljs-comment">// ++prefix</span><br>   <span class="hljs-type">const</span> Counter <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> dummy); <span class="hljs-comment">// postfix++</span><br> <br>   <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; out, <span class="hljs-type">const</span> Counter &amp; counter);<br>&#125;;<br><br><span class="hljs-comment">// ++prefix, return reference of this</span><br>Counter &amp; Counter::<span class="hljs-keyword">operator</span>++() &#123;<br>   ++count;<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br> <br><span class="hljs-comment">// postfix++, return old value by value</span><br><span class="hljs-type">const</span> Counter Counter::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> dummy) &#123;<br>   <span class="hljs-function">Counter <span class="hljs-title">old</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>   ++count;<br>   <span class="hljs-keyword">return</span> old;<br>&#125;<br> <br><span class="hljs-comment">// Overload stream insertion &lt;&lt; operator</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; out, <span class="hljs-type">const</span> Counter &amp; counter) &#123;<br>   out &lt;&lt; counter.count;<br>   <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>The prefix function returns a reference to this instance, to support chaining (or cascading), e.g., <code>++++c</code> as <code>++(++c)</code>.</p><p>The postfix function returns a <code>const</code> object(a temporary object) by value.</p>          </div><h4 id="implicit-conversion-via-single-argument-constructor-keyword-explicit"><a class="markdownIt-Anchor" href="#implicit-conversion-via-single-argument-constructor-keyword-explicit"></a> Implicit Conversion via Single-argument Constructor &amp; Keyword &quot;explicit&quot;</h4><p>A <strong><em>single-argument</em> constructor</strong> can be used to implicitly convert a value to an object.</p><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">Counter</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>) : <span class="hljs-built_in">count</span>(c) &#123; &#125;<br>         <span class="hljs-comment">// A single-argument Constructor which takes an int</span><br>         <span class="hljs-comment">// It can be used to implicitly convert an int to a Counter object</span><br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> count; &#125;    <span class="hljs-comment">// Getter</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123; count = c; &#125; <span class="hljs-comment">// Setter</span><br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   Counter c1; <span class="hljs-comment">// Declare an instance and invoke default constructor</span><br>   cout &lt;&lt; c1.<span class="hljs-built_in">getCount</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br> <br>   c1 = <span class="hljs-number">9</span>;<br>     <span class="hljs-comment">// Implicit conversion</span><br>     <span class="hljs-comment">// Invoke single-argument constructor Counter(9) to construct a temporary object.</span><br>     <span class="hljs-comment">// Then copy into c1 via memberwise assignment.</span><br>   cout &lt;&lt; c1.<span class="hljs-built_in">getCount</span>() &lt;&lt; endl;  <span class="hljs-comment">// 9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>To disable implicit conversion, use keyword &quot;<code>explicit</code>&quot;. Nonetheless, you can still perform <strong>explicit conversion via type cast operator</strong>.</p><div class="note note-info">            <p>Although implicit conversion is disabled using keyword &quot;explicit&quot;, we can still use explicit conversion via type casting.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">c1 = (Counter)<span class="hljs-number">9</span>;  <span class="hljs-comment">// Explicit conversion via type casting</span><br></code></pre></td></tr></table></figure>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Counter</span><span class="hljs-params">(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>)</span> : count(c) &#123;</span> &#125;<br>      <span class="hljs-comment">// Single-argument Constructor</span><br>      <span class="hljs-comment">// Use keyword &quot;explicit&quot; to disable implicit automatic conversion in assignment</span><br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> count; &#125;    <span class="hljs-comment">// Getter</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123; count = c; &#125; <span class="hljs-comment">// Setter</span><br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   Counter c1; <span class="hljs-comment">// Declare an instance and invoke default constructor</span><br>   cout &lt;&lt; c1.<span class="hljs-built_in">getCount</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br> <br><span class="hljs-comment">// Counter c2 = 9;</span><br>     <span class="hljs-comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;Counter&#x27; requested</span><br> <br>   c1 = (Counter)<span class="hljs-number">9</span>;  <span class="hljs-comment">// Explicit conversion via type casting operator</span><br>   cout &lt;&lt; c1.<span class="hljs-built_in">getCount</span>() &lt;&lt; endl;  <span class="hljs-comment">// 9</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="dynamic-memory-allocation-in-object"><a class="markdownIt-Anchor" href="#dynamic-memory-allocation-in-object"></a> Dynamic Memory Allocation in Object</h4><div class="note note-danger">            <p>If you dynamically allocate memory in the constructor, you need to provide your own <strong>destructor, copy constructor and assignment operator</strong> to manage the dynamically allocated memory. The defaults provided by the C++ compiler do not work for dynamic memory.</p>          </div><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDynamicArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> size_;   <span class="hljs-comment">// size of array</span><br>   <span class="hljs-type">double</span> * ptr;  <span class="hljs-comment">// pointer to the elements</span><br> <br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyDynamicArray</span> <span class="hljs-params">(<span class="hljs-type">int</span> n = <span class="hljs-number">8</span>)</span></span>;         <span class="hljs-comment">// Default constructor</span><br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyDynamicArray</span> <span class="hljs-params">(<span class="hljs-type">const</span> MyDynamicArray &amp; a)</span></span>; <span class="hljs-comment">// Copy constructor</span><br>   <span class="hljs-built_in">MyDynamicArray</span> (<span class="hljs-type">const</span> <span class="hljs-type">double</span> a[], <span class="hljs-type">int</span> n);    <span class="hljs-comment">// Construct from double[]</span><br>   ~<span class="hljs-built_in">MyDynamicArray</span>();                           <span class="hljs-comment">// Destructor</span><br> <br>   <span class="hljs-type">const</span> MyDynamicArray &amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> MyDynamicArray &amp; rhs); <span class="hljs-comment">// Assignment a1 = a2</span><br>   <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> MyDynamicArray &amp; rhs) <span class="hljs-type">const</span>;     <span class="hljs-comment">// a1 == a2</span><br>   <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!= (<span class="hljs-type">const</span> MyDynamicArray &amp; rhs) <span class="hljs-type">const</span>;     <span class="hljs-comment">// a1 != a2</span><br> <br>   <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> index) <span class="hljs-type">const</span>;  <span class="hljs-comment">// a[i]</span><br>   <span class="hljs-type">double</span> &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> index);      <span class="hljs-comment">// a[i] = x</span><br> <br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;    <span class="hljs-comment">// return size of array</span><br> <br>   <span class="hljs-comment">// friends</span><br>   <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (std::ostream &amp; out, <span class="hljs-type">const</span> MyDynamicArray &amp; a); <span class="hljs-comment">// out &lt;&lt; a</span><br>   <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt; (std::istream &amp; in, MyDynamicArray &amp; a);        <span class="hljs-comment">// in &gt;&gt; a</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="template-and-generic-programming"><a class="markdownIt-Anchor" href="#template-and-generic-programming"></a> Template and Generic Programming</h1><h4 id="stls-vector-template-class"><a class="markdownIt-Anchor" href="#stls-vector-template-class"></a> STL's vector Template Class</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// Create a vector with 5 elements;</span><br>v1[i];<span class="hljs-comment">// no index-bound check for []</span><br>v1.<span class="hljs-built_in">at</span>(i);<span class="hljs-comment">// do index-bound check with at()</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; v2;   <span class="hljs-comment">// Create a vector with 0 elements</span><br><span class="hljs-comment">// Assign v1 to v2 memberwise</span><br>v2 = v1;<br><br><span class="hljs-comment">// Compare 2 vectors memberwise</span><br>cout &lt;&lt; boolalpha &lt;&lt; (v1 == v2) &lt;&lt; endl;<br><br><span class="hljs-comment">// Append more elements - dynamically allocate memory</span><br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">80</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">81</span>);<br><br><span class="hljs-comment">// Remove element from the end</span><br>v1.<span class="hljs-built_in">pop_back</span>();<br></code></pre></td></tr></table></figure><h4 id="function-template"><a class="markdownIt-Anchor" href="#function-template"></a> Function Template</h4><p>The syntax of defining function template is:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; OR <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">return</span>-type function-<span class="hljs-built_in">name</span>(function-parameter-list) &#123; ...... &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Explicit Specialization</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span>;  <span class="hljs-comment">// Template</span><br> <br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">mySwap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b);<br>   <span class="hljs-comment">// Explicit Specialization for type int</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span> </span>&#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;Template&quot;</span> &lt;&lt; endl;<br>   T temp;<br>   temp = a;<br>   a = b;<br>   b = temp;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">mySwap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b) &#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;Specialization&quot;</span> &lt;&lt; endl;<br>   <span class="hljs-type">int</span> temp;<br>   temp = a;<br>   a = b;<br>   b = temp;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>If there is any <strong>non-template definition</strong> that matches the function call. The <strong>non-template version</strong> will take precedence over <strong>explicit specialization</strong>, then <strong>template</strong>.</p>          </div><h4 id="class-template"><a class="markdownIt-Anchor" href="#class-template"></a> Class Template</h4><p>The syntax for defining a <em>class template</em>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;    <span class="hljs-comment">// OR template &lt;typename T&gt;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;<br>   ......<br>&#125;<br></code></pre></td></tr></table></figure><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   T value;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">Number</span>(T value) &#123; <span class="hljs-keyword">this</span>-&gt;value = value; &#125;;<br>   <span class="hljs-function">T <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;value = value; &#125;;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">Number&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">55</span>)</span></span>;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <ul><li><strong>Separating Template Function Declaration and Definition</strong></li></ul><p>If you separate the function implementation, you need to use keyword <code>template &lt;typename T&gt;</code> on each of the function implementation. For example,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T Number&lt;T&gt;::<span class="hljs-built_in">getValue</span>() &#123;<br>   <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><ul><li>More than one Type Parameters</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, ....&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123; ...... &#125;<br></code></pre></td></tr></table></figure><ul><li>Default Type</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> ClassName &#123; ...... &#125;<br></code></pre></td></tr></table></figure><p>To instantiate with the default type, use <code>ClassName&lt;&gt;</code>.</p><ul><li>Specialization</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// General Template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123; ...... &#125;<br> <br><span class="hljs-comment">// Specialization for type double</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&lt;<span class="hljs-type">double</span>&gt; &#123; ...... &#125;<br> <br><span class="hljs-comment">// Specialization for type int</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&lt;<span class="hljs-type">int</span>&gt; &#123; ....... &#125;<br></code></pre></td></tr></table></figure><h4 id="example-mycomplex-template-class"><a class="markdownIt-Anchor" href="#example-mycomplex-template-class"></a> Example: <code>MyComplex</code> Template Class</h4><p><code>MyComplex.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The MyComplex template class header (MyComplex.h)</span><br><span class="hljs-comment"> * All template codes are kept in the header, to be included in program</span><br><span class="hljs-comment"> * (Follow, modified and simplified from GNU GCC complex template class.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_COMPLEX_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_COMPLEX_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-comment">// Forward declaration</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComplex</span>;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (std::ostream &amp; out, <span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; c);<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt; (std::istream &amp; in, MyComplex&lt;T&gt; &amp; c);<br> <br><span class="hljs-comment">// MyComplex template class declaration</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComplex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   T real, imag;<br> <br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// Constructor</span><br>   <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">MyComplex</span>&lt;T&gt; (T real = <span class="hljs-number">0</span>, T imag = <span class="hljs-number">0</span>)<br>         : <span class="hljs-built_in">real</span>(real), <span class="hljs-built_in">imag</span>(imag) &#123; &#125;<br> <br>   <span class="hljs-comment">// Overload += operator for c1 += c2</span><br>   MyComplex&lt;T&gt; &amp; <span class="hljs-keyword">operator</span>+= (<span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; rhs) &#123;<br>      real += rhs.real;<br>      imag += rhs.imag;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>   &#125;<br> <br>   <span class="hljs-comment">// Overload += operator for c1 += value</span><br>   MyComplex&lt;T&gt; &amp; <span class="hljs-keyword">operator</span>+= (T value) &#123;<br>      real += value;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>   &#125;<br> <br>   <span class="hljs-comment">// Overload comparison == operator for c1 == c2</span><br>   <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; rhs) <span class="hljs-type">const</span> &#123;<br>      <span class="hljs-built_in">return</span> (real == rhs.real &amp;&amp; imag == rhs.imag);<br>   &#125;<br> <br>   <span class="hljs-comment">// Overload comparison != operator for c1 != c2</span><br>   <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!= (<span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; rhs) <span class="hljs-type">const</span> &#123;<br>      <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == rhs);<br>   &#125;<br> <br>   <span class="hljs-comment">// Overload prefix increment operator ++c</span><br>   <span class="hljs-comment">// (Separate implementation for illustration)</span><br>   MyComplex&lt;T&gt; &amp; <span class="hljs-keyword">operator</span>++ ();<br> <br>   <span class="hljs-comment">// Overload postfix increment operator c++</span><br>   <span class="hljs-type">const</span> MyComplex&lt;T&gt; <span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span> dummy);<br> <br>   <span class="hljs-comment">/* friends */</span><br> <br>   <span class="hljs-comment">// (Separate implementation for illustration)</span><br>   <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; &lt;&gt;(std::ostream &amp; out, <span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; c); <span class="hljs-comment">// out &lt;&lt; c</span><br>   <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt; &lt;&gt;(std::istream &amp; in, MyComplex&lt;T&gt; &amp; c);        <span class="hljs-comment">// in &gt;&gt; c</span><br> <br>   <span class="hljs-comment">// Overloading + operator for c1 + c2</span><br>   <span class="hljs-comment">// (inline implementation for illustration)</span><br>   <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> MyComplex&lt;T&gt; <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; lhs, <span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; rhs) &#123;<br>      <span class="hljs-function">MyComplex&lt;T&gt; <span class="hljs-title">result</span><span class="hljs-params">(lhs)</span></span>;<br>      result += rhs;  <span class="hljs-comment">// uses overload +=</span><br>      <span class="hljs-keyword">return</span> result;<br>   &#125;<br> <br>   <span class="hljs-comment">// Overloading + operator for c + double</span><br>   <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> MyComplex&lt;T&gt; <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; lhs, T value) &#123;<br>      <span class="hljs-function">MyComplex&lt;T&gt; <span class="hljs-title">result</span><span class="hljs-params">(lhs)</span></span>;<br>      result += value;  <span class="hljs-comment">// uses overload +=</span><br>      <span class="hljs-keyword">return</span> result;<br>   &#125;<br> <br>   <span class="hljs-comment">// Overloading + operator for double + c</span><br>   <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> MyComplex&lt;T&gt; <span class="hljs-keyword">operator</span>+ (T value, <span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; rhs) &#123;<br>      <span class="hljs-keyword">return</span> rhs + value;   <span class="hljs-comment">// swap and use above function</span><br>   &#125;<br>&#125;;<br> <br><span class="hljs-comment">// Overload prefix increment operator ++c</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>MyComplex&lt;T&gt; &amp; MyComplex&lt;T&gt;::<span class="hljs-keyword">operator</span>++ () &#123;<br>  ++real;   <span class="hljs-comment">// increment real part only</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br> <br><span class="hljs-comment">// Overload postfix increment operator c++</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">const</span> MyComplex&lt;T&gt; MyComplex&lt;T&gt;::<span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span> dummy) &#123;<br>   <span class="hljs-function">MyComplex&lt;T&gt; <span class="hljs-title">saved</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>   ++real;  <span class="hljs-comment">// increment real part only</span><br>   <span class="hljs-keyword">return</span> saved;<br>&#125;<br> <br><span class="hljs-comment">/* Definition of friend functions */</span><br> <br><span class="hljs-comment">// Overload stream insertion operator out &lt;&lt; c (friend)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (std::ostream &amp; out, <span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; c) &#123;<br>   out &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; c.real &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>   <span class="hljs-keyword">return</span> out;<br>&#125;<br> <br><span class="hljs-comment">// Overload stream extraction operator in &gt;&gt; c (friend)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt; (std::istream &amp; in, MyComplex&lt;T&gt; &amp; c) &#123;<br>   T inReal, inImag;<br>   <span class="hljs-type">char</span> inChar;<br>   <span class="hljs-type">bool</span> validInput = <span class="hljs-literal">false</span>;<br>   <span class="hljs-comment">// Input shall be in the format &quot;(real,imag)&quot;</span><br>   in &gt;&gt; inChar;<br>   <span class="hljs-keyword">if</span> (inChar == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>      in &gt;&gt; inReal &gt;&gt; inChar;<br>      <span class="hljs-keyword">if</span> (inChar == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>         in &gt;&gt; inImag &gt;&gt; inChar;<br>         <span class="hljs-keyword">if</span> (inChar == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            c = <span class="hljs-built_in">MyComplex</span>&lt;T&gt;(inReal, inImag);<br>            validInput = <span class="hljs-literal">true</span>;<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (!validInput) in.<span class="hljs-built_in">setstate</span>(std::ios_base::failbit);<br>   <span class="hljs-keyword">return</span> in;<br>&#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><div class="note note-info">            <blockquote><p>Why do we need a <code>&lt;&gt;</code> when we declare operator function &lt;&lt;/&gt;&gt; inside the class? When do we need a forward declaration of a friend function?</p></blockquote><p>When the compiler sees a declaration with &lt;&gt;, it knows this is a <strong>specialization version of a template function</strong>. The compiler will then <strong>look for the corresponding forward declaration of the template function</strong>. This is why we also need a forward declaration of the operator function &lt;&lt;/&gt;&gt;: this is a template function.</p><p>The declaration without &lt;&gt; simply tells the compiler this is an ordinary non-template function, which does not need a forward declaration.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Forward declaration</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComplex</span>;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (std::ostream &amp; out, <span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; c);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComplex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T real, imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Situation1: using &lt;&gt;</span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; &lt;&gt;(std::ostream&amp; out, <span class="hljs-type">const</span> MyComplex&lt;T&gt;&amp; c);<br><br>    <span class="hljs-comment">// Situation2: not using &lt;&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printComplex</span><span class="hljs-params">(<span class="hljs-type">const</span> MyComplex&lt;T&gt;&amp; c)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">/* Definition of friend functions */</span><br> <br><span class="hljs-comment">// Overload stream insertion operator out &lt;&lt; c (friend)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (std::ostream &amp; out, <span class="hljs-type">const</span> MyComplex&lt;T&gt; &amp; c) &#123;<br>   out &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; c.real &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>   <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>What if a member function of a template class is defined outside the class?</p></blockquote><p>When a member function of a template class is <strong>defined outside the class</strong>, we need to use keyword <code>template &lt;typename T&gt;</code> on the function implementation.</p><p>For example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Declared inside the template class MyComplex</span><br><span class="hljs-comment">// Defined outside the class</span><br><span class="hljs-comment">// Overload prefix increment operator ++c</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>MyComplex&lt;T&gt; &amp; MyComplex&lt;T&gt;::<span class="hljs-keyword">operator</span>++ () &#123;<br>  ++real;   <span class="hljs-comment">// increment real part only</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h1 id="characters-and-strings"><a class="markdownIt-Anchor" href="#characters-and-strings"></a> Characters and Strings</h1><h4 id="strings-the-c-string-and-the-string-class"><a class="markdownIt-Anchor" href="#strings-the-c-string-and-the-string-class"></a> Strings: The C-String and the string class</h4><ul><li><strong>C-String Literals</strong></li></ul><div class="note note-warning">            <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> * str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>          <span class="hljs-comment">// warning: deprecated conversion from string constant to &#x27;char*&#x27;</span><br>   <span class="hljs-type">char</span> * str2 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">// remove the &quot;const&quot;</span><br></code></pre></td></tr></table></figure><p>Those two statements are dangerous. String literal &quot;hello&quot; is stored in <strong>read-only memory</strong>. Now you assign a non-const pointer to point to this area. If you try to modify this string literal, it will crash your program.</p>          </div><div class="note note-success">            <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * str3 = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">// *(str3 + 1) = &#x27;a&#x27;;  // error: assignment of read-only location &#x27;*(str3 + 1u)&#x27;</span><br><br><span class="hljs-comment">// Creates a modifiable copy</span><br><span class="hljs-type">char</span> str4[] = <span class="hljs-string">&quot;hello&quot;</span>;<br>str4[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> str5[] = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">//  str5[1] = &#x27;a&#x27;;   // error: assignment of read-only location &#x27;str5[1]&#x27;</span><br></code></pre></td></tr></table></figure><p>Those are correct!</p>          </div><ul><li><strong>C++'s string class</strong></li></ul><p>See <a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_String.html">NTU Notes</a> for details.</p><h4 id="the-c-string-input-methods"><a class="markdownIt-Anchor" href="#the-c-string-input-methods"></a> The C-String Input Methods</h4><p>C-string has three input methods: stream extraction operator (<code>&gt;&gt;</code>), <code>getline()</code> and <code>get()</code>.</p><div class="note note-info">            <blockquote><p>What's the difference between those three methods?</p></blockquote><ul><li><code>istream's</code> Overloaded Stream Extraction Operator (&gt;&gt;)</li></ul><p>Stream extraction operator does not discard the trailing whitespace(blank, tab, newline), and leave it in the input buffer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">5</span>;<br><span class="hljs-type">char</span> str[SIZE];    <span class="hljs-comment">// max strlen is SIZE - 1</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;Enter a word: &quot;</span>;<br><span class="hljs-comment">// Extract SIZE-1 characters at most</span><br>cin &gt;&gt; <span class="hljs-built_in">setw</span>(SIZE) &gt;&gt; str;   <span class="hljs-comment">// need &lt;iomanip&gt; header</span><br>cout &lt;&lt; str &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>You may need to flush the input buffer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Ignore to the end-of-file</span><br>cin.<span class="hljs-built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="hljs-built_in">max</span>());  <span class="hljs-comment">// need header &lt;limits&gt;</span><br><br><span class="hljs-comment">// Ignore to the end-of-line</span><br>cin.<span class="hljs-built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="hljs-built_in">max</span>(), <span class="hljs-string">&#x27;\n&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li><code>istream::getline()</code></li></ul><p>The delimiter, if found, is extracted and discarded from input stream.</p><p>If <code>n-1</code> character is read and the next character is not delimit, then the <code>failbit</code> (of the <code>istream</code>) is set. You can check the <code>failbit</code> via <code>bool</code> function <code>cin.fail()</code>. You need to <strong>clear the error bits before issuing another <code>getline()</code> call</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">5</span>;<br><span class="hljs-type">char</span> str[SIZE];    <span class="hljs-comment">// max strlen is SIZE - 1</span><br> <br>cout &lt;&lt; <span class="hljs-string">&quot;Enter a line: &quot;</span>;<br>cin.<span class="hljs-built_in">getline</span>(str, SIZE);     <span class="hljs-comment">// Read a line (including whitespaces) until newline, discard newline</span><br>cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot; length=&quot;</span> &lt;&lt; <span class="hljs-built_in">strlen</span>(str) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Number of characters extracted: &quot;</span> &lt;&lt; cin.<span class="hljs-built_in">gcount</span>() &lt;&lt; endl;<br> <br><span class="hljs-keyword">if</span> (cin.<span class="hljs-built_in">fail</span>()) &#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;failbit is set!&quot;</span> &lt;&lt; endl;<br>   cin.<span class="hljs-built_in">clear</span>();   <span class="hljs-comment">// Clear all error bits. Otherwise, subsequent getline() fails</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>istream::get()</code></li></ul><p><code>get(str, n, delim)</code> is similar to <code>getline(str, n, delim)</code>, except that the <code>delim</code> character is not extracted and remains in the input stream.</p>          </div><h1 id="c-standard-libraries-and-standard-template-library-stl"><a class="markdownIt-Anchor" href="#c-standard-libraries-and-standard-template-library-stl"></a> C++ Standard Libraries and Standard Template Library (STL)</h1><blockquote><p>The <a href="http://cplusplus.com">cplusplus.com</a> at <a href="http://www.cplusplus.com/reference">http://www.cplusplus.com/reference</a> provides a comprehensive online references for the C++ libraries.</p></blockquote><h2 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h2><h3 id="containers"><a class="markdownIt-Anchor" href="#containers"></a> Containers</h3><ul><li>Sequence Containers, Associative Containers and Adapters</li></ul><p>STL provides the following types of containers:</p><ol><li>Sequence Containers: linear data structures of elements<ul><li><code>vector</code>: dynamically resizable array.</li><li><code>deque</code>: double-ended queue.</li><li><code>list</code>: double-linked list.</li></ul></li><li>Associative Containers: nonlinear data structures storing key-value pairs<ul><li><code>set</code>: No duplicate element. Support fast lookup.</li><li><code>multiset</code>: Duplicate element allowed. Support fast lookup.</li><li><code>map</code>: One-to-one mapping (associative array) with no duplicate. Support fast key lookup.</li><li><code>multimap</code>: One-to-many mapping, with duplicates allowed. Support fast key lookup.</li></ul></li><li>Container Adapter Classes:<ul><li><code>Stack</code>: Last-in-first-out (LIFO) queue, adapted from <code>deque</code> (default), or <code>vector</code>, or <code>list</code>. Support operations <code>back</code>, <code>push_back</code>, <code>pop_back</code>.</li><li><code>queue</code>: First-in-first-out (FIFO) queue, adapted from <code>deque</code> (default), or <code>list</code>. Support operations <code>front</code>, <code>back</code>, <code>push_back</code>, <code>pop_front</code>.</li><li><code>priority_queue</code>: highest priority element at front of the queue. adapted from <code>vector</code> (default) or <code>deque</code>. Support operations <code>front</code>, <code>push_back</code>, <code>pop_front</code>.</li></ul></li></ol><div class="note note-info">            <ul><li>First-class Containers, Adapters and Near Containers</li></ul><p>The containers can also be classified as:</p><ol><li>First-class Containers: all sequence containers and associative containers are collectively known as first-class container.</li><li>Adapters: constrained first-class containers such as <code>stack</code> and <code>queue</code>.</li><li>Near Containers: Do not support all the first-class container operations. For example, the built-in array (pointer-like), <code>bitsets</code> (for maintaining a set of flags), <code>valarray</code> (support array computation), <code>string</code> (stores only character type).</li></ol>          </div><h3 id="stl-pre-defined-iterators-in-header-iterator"><a class="markdownIt-Anchor" href="#stl-pre-defined-iterators-in-header-iterator"></a> STL Pre-defined Iterators (in Header <iterator>)</h3><ul><li>Example: <code>istream_iterator</code> and <code>ostream_iterator</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">// Construct ostream_iterators to write int and string to cout</span><br>   <span class="hljs-function">ostream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">iterOut</span><span class="hljs-params">(cout)</span></span>;<br>   <span class="hljs-function">ostream_iterator&lt;string&gt; <span class="hljs-title">iterOutStr</span><span class="hljs-params">(cout)</span></span>;<br> <br>   *iterOutStr = <span class="hljs-string">&quot;Enter two integers: &quot;</span>;<br> <br>   <span class="hljs-comment">// Construct an istream_iterator&lt;int&gt; to read int from cin</span><br>   <span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">iterIn</span><span class="hljs-params">(cin)</span></span>;<br>   <span class="hljs-type">int</span> number1 = *iterIn;  <span class="hljs-comment">// dereference to get the value</span><br>   ++iterIn;               <span class="hljs-comment">// next int in cin</span><br>   <span class="hljs-type">int</span> number2 = *iterIn;<br> <br>   *iterOutStr = <span class="hljs-string">&quot;You have entered &quot;</span>;<br>   *iterOut = number1;<br>   *iterOutStr = <span class="hljs-string">&quot; and &quot;</span>;<br>   *iterOut = number2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Example: <code>copy()</code> to <code>ostream_iterator</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">10</span>;<br>   <span class="hljs-type">int</span> array[SIZE] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">55</span>, <span class="hljs-number">44</span>, <span class="hljs-number">33</span>, <span class="hljs-number">88</span>, <span class="hljs-number">99</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>&#125;;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(array, array + SIZE)</span></span>;<br> <br>   <span class="hljs-comment">// Construct an ostream_iterator called out</span><br>   <span class="hljs-function">ostream_iterator&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">out</span> <span class="hljs-params">(cout, <span class="hljs-string">&quot; &quot;</span>)</span></span>;<br>   <span class="hljs-comment">// Copy to ostream, via ostream_iterator - replacing the print()</span><br>   <span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), out);<br>   cout &lt;&lt; endl;<br> <br>   <span class="hljs-comment">// Copy to ostream in reverse order</span><br>   <span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">rbegin</span>(), v.<span class="hljs-built_in">rend</span>(), out);<br>   cout &lt;&lt; endl;<br> <br>   <span class="hljs-comment">// Use an anonymous ostream_iterator</span><br>   <span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ostream_iterator</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;(cout, <span class="hljs-string">&quot; &quot;</span>));<br>   cout &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Example: insert_iterator</li></ul><p>A <code>front_insert_iterator</code> inserts from the front; a <code>back_insert_iterator</code> inserts at the end; an <code>insert_iterator</code> inserts before a given location.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-type">int</span> a1[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">55</span>, <span class="hljs-number">44</span>, <span class="hljs-number">33</span>, <span class="hljs-number">88</span>&#125;;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a1, a1+<span class="hljs-number">5</span>)</span></span>;<br>   <span class="hljs-function">ostream_iterator&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">out</span> <span class="hljs-params">(cout, <span class="hljs-string">&quot; &quot;</span>)</span></span>;  <span class="hljs-comment">// for printing</span><br>   <span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), out);<br>   cout &lt;&lt; endl;<br>    <br>   <span class="hljs-comment">// Construct a back_insert_iterator to insert at the end</span><br>   back_insert_iterator&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">back</span> (v);<br>   <span class="hljs-type">int</span> a2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">91</span>, <span class="hljs-number">92</span>, <span class="hljs-number">93</span>&#125;;<br>   <span class="hljs-built_in">copy</span>(a2, a2+<span class="hljs-number">3</span>, back);<br>   <span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), out);<br>   cout &lt;&lt; endl;<br> <br>   <span class="hljs-comment">// Use an anonymous insert_iterator to insert at the front</span><br>   <span class="hljs-type">int</span> a3[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">81</span>, <span class="hljs-number">82</span>, <span class="hljs-number">83</span>&#125;;<br>   <span class="hljs-built_in">copy</span>(a3, a3+<span class="hljs-number">3</span>, insert_iterator&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;(v, v.<span class="hljs-built_in">begin</span>()));<br>   <span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), out);<br>   cout &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="algorithm"><a class="markdownIt-Anchor" href="#algorithm"></a> Algorithm</h3><ul><li>Example 1: sort(), reverse(), random_shuffle() and find() on Iterators [first,last)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">10</span>;<br>   <span class="hljs-type">int</span> array[SIZE] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">55</span>, <span class="hljs-number">44</span>, <span class="hljs-number">33</span>, <span class="hljs-number">88</span>, <span class="hljs-number">99</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>&#125;;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(array, array + SIZE)</span></span>;<br>   <span class="hljs-built_in">print</span>(v);<br> <br>   <span class="hljs-comment">// Sort</span><br>   <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// entire container [begin(),end())</span><br>   <span class="hljs-built_in">print</span>(v);<br> <br>   <span class="hljs-comment">// Reverse</span><br>   <span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">begin</span>() + v.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>);  <span class="hljs-comment">// First half</span><br>   <span class="hljs-built_in">print</span>(v);<br> <br>   <span class="hljs-comment">// Random Shuffle</span><br>   <span class="hljs-built_in">random_shuffle</span>(v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, v.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);  <span class="hljs-comment">// exclude first and last elements</span><br>   <span class="hljs-built_in">print</span>(v);<br> <br>   <span class="hljs-comment">// Search</span><br>   <span class="hljs-type">int</span> searchFor = <span class="hljs-number">55</span>;<br>   vector&lt;<span class="hljs-type">int</span>&gt;::iterator found = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), searchFor);<br>   <span class="hljs-keyword">if</span> (found != v.<span class="hljs-built_in">end</span>()) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;Found&quot;</span> &lt;&lt; endl;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>Most of the algorithm functions takes at least two iterators: <code>first</code> and <code>last</code>, to specify the range <code>[first,last)</code> of operation.</p><p>All STL containers provides members functions <code>begin()</code> and <code>end()</code>, which return the begin and pass-the-end elements of the container, respectively.</p><p>To apply sort, the elements shall have overloaded the <code>'&lt;'</code> operator, which is used for comparing the order of the elements.</p>          </div><ul><li>Example 2: for_each()</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   vector&lt;<span class="hljs-type">int</span>&gt; v;<br>   v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">11</span>);<br>   v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>   v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>   v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">22</span>);<br> <br>   <span class="hljs-comment">// Invoke the given function (print, square)</span><br>   <span class="hljs-comment">// for each element in the range</span><br>   for_each(v.<span class="hljs-built_in">begin</span>(), v.end, print);<br>   for_each(v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, square);<br>   for_each(v.<span class="hljs-built_in">begin</span>(), v.end, print);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; n)</span> </span>&#123; n *= n; &#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; n)</span> </span>&#123; cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="function-object-functors"><a class="markdownIt-Anchor" href="#function-object-functors"></a> Function Object (Functors)</h3><ul><li>transform() algorithm</li></ul><p><code>transform()</code> algorithm has two versions, supporting unary and binary operations, respectively.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Unary Operation</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIterator</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputIterator</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryOperation</span>&gt;<br><span class="hljs-function">OutputIterator <span class="hljs-title">transform</span> <span class="hljs-params">(InputIterator first, InputIterator last,</span></span><br><span class="hljs-params"><span class="hljs-function">                         OutputIterator result, UnaryOperation op)</span></span><br><span class="hljs-function">   <span class="hljs-comment">// Perform unary operation on each element in [first,last) and</span></span><br><span class="hljs-function">   <span class="hljs-comment">// store the output in range beginning at result</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   vector&lt;<span class="hljs-type">int</span>&gt; v;<br>   v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>   v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-3</span>);<br>   v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>   v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>   <span class="hljs-function">ostream_iterator&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">out</span><span class="hljs-params">(cout, <span class="hljs-string">&quot; &quot;</span>)</span></span>;<br>   <span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), out);<br>   cout &lt;&lt; endl;<br> <br>   <span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v.<span class="hljs-built_in">begin</span>(), square);<br>   <span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), out);<br>   cout &lt;&lt; endl;<br> <br>   <span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), out, ::sqrt);  <span class="hljs-comment">// in &lt;cmath&gt;</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Binary Operation</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIterator1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIterator2</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputIterator</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryOperation</span>&gt;<br><span class="hljs-function">OutputIterator <span class="hljs-title">transform</span> <span class="hljs-params">(InputIterator1 first1, InputIterator1 last1,</span></span><br><span class="hljs-params"><span class="hljs-function">                         InputIterator2 first2,</span></span><br><span class="hljs-params"><span class="hljs-function">                         OutputIterator result, BinaryOperation op)</span></span><br><span class="hljs-function">   <span class="hljs-comment">// Perform binary operation on each element in [first1,last1) as first argument,</span></span><br><span class="hljs-function">   <span class="hljs-comment">// and the respective [frist2,...) as second argument.</span></span><br><span class="hljs-function">   <span class="hljs-comment">// Store the output in range beginning at result</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-type">int</span> a1[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>   <span class="hljs-type">int</span> a2[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;;<br> <br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(a1, a1+<span class="hljs-number">5</span>)</span></span>;<br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(a2, a2+<span class="hljs-number">5</span>)</span></span>;<br>   <span class="hljs-function">ostream_iterator&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">out</span><span class="hljs-params">(cout, <span class="hljs-string">&quot; &quot;</span>)</span></span>;<br>   <span class="hljs-built_in">copy</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), out);<br>   cout &lt;&lt; endl;<br>   <span class="hljs-built_in">copy</span>(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), out);<br>   cout &lt;&lt; endl;<br> <br>   <span class="hljs-built_in">transform</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), out, <span class="hljs-built_in">plus</span>&lt;<span class="hljs-type">int</span>&gt;());<br>       <span class="hljs-comment">// Send result to output stream</span><br>   cout &lt;&lt; endl;<br> <br>   <span class="hljs-built_in">transform</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt;());<br>       <span class="hljs-comment">// Store result back to v1</span><br>   <span class="hljs-built_in">copy</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), out);<br>   cout &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="stream-io-and-file-io"><a class="markdownIt-Anchor" href="#stream-io-and-file-io"></a> Stream IO and File IO</h1><h2 id="stream-io"><a class="markdownIt-Anchor" href="#stream-io"></a> Stream IO</h2><h3 id="the-standard-stream-objects"><a class="markdownIt-Anchor" href="#the-standard-stream-objects"></a> the Standard Stream Objects</h3><ul><li>The <code>&lt;iostream&gt;</code> header declares these <em>standard stream objects</em>:</li></ul><ol><li><p><code>cin</code> (of <code>istream</code> class, <code>basic_istream&lt;char&gt;</code> specialization), <code>wcin</code> (of <code>wistream</code> class, <code>basic_istream&lt;wchar_t&gt;</code> specialization): corresponding to the <em>standard input stream</em>, defaulted to keyword.</p></li><li><p><code>cout</code> (of <code>ostream</code> class), <code>wcout</code> (of <code>wostream</code> class): corresponding to the <em>standard output stream</em>, defaulted to the display console.</p></li><li><p><code>cerr</code> (of <code>ostream</code> class), <code>wcerr</code> (of <code>wostream</code> class): corresponding to the <em>standard error stream</em>, defaulted to the display console.</p></li><li><p><code>clog</code> (of <code>ostream</code> class), <code>wclog</code> (of <code>wostream</code> class): corresponding to the <em>standard log stream</em>, defaulted to the display console.</p></li></ol><h3 id="the-ostream-class"><a class="markdownIt-Anchor" href="#the-ostream-class"></a> The <code>ostream</code> class</h3><ul><li>Formatting Output via the Overloaded Stream Insertion &lt;&lt; Operator</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (type)   <span class="hljs-comment">// type of int, double etc</span><br></code></pre></td></tr></table></figure><div class="note note-success">            <p><code>void *</code>: can be used to print an address.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;apple&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * str2 = <span class="hljs-string">&quot;orange&quot;</span>;<br> <br>cout &lt;&lt; str1 &lt;&lt; endl;   <span class="hljs-comment">// with char *, print C-string</span><br>cout &lt;&lt; str2 &lt;&lt; endl;   <span class="hljs-comment">// with char *, print C-string</span><br>cout &lt;&lt; (<span class="hljs-type">void</span> *) str1 &lt;&lt; endl;  <span class="hljs-comment">// with void *, print address (regular cast)</span><br>cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(str2) &lt;&lt; endl;  <span class="hljs-comment">// with void *, print address</span><br></code></pre></td></tr></table></figure>          </div><ul><li>Flushing the Output Buffer</li></ul><ol><li>flush member function or manipulator:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Member function of ostream class - std::ostream::flush</span><br><span class="hljs-function">ostream &amp; <span class="hljs-title">flush</span> <span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// Example</span><br>cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span>;<br>cout.<span class="hljs-built_in">flush</span>();<br> <br><span class="hljs-comment">// Manipulator - std::flush</span><br><span class="hljs-function">ostream &amp; <span class="hljs-title">flush</span> <span class="hljs-params">(ostream &amp; os)</span></span>;<br><span class="hljs-comment">// Example</span><br>cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; flush;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>endl</code> manipulator, which inserts a newline and flush the buffer. Outputting a newline character '\n' may not flush the output buffer; but <code>endl</code> does.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Manipulator - std::endl</span><br><span class="hljs-function">ostream &amp; <span class="hljs-title">endl</span> <span class="hljs-params">(ostream &amp; os)</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>cin</code>: output buffer is flushed when input is pending, e.g.,</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;Enter a number: &quot;</span>;<br><span class="hljs-type">int</span> number;<br>cin &lt;&lt; number;  <span class="hljs-comment">// flush output buffer so as to show the prompting message</span><br></code></pre></td></tr></table></figure><h3 id="the-istream-class"><a class="markdownIt-Anchor" href="#the-istream-class"></a> The <code>istream</code> class</h3><ul><li>Formatting Input via the Overloaded Stream Extraction &gt;&gt; Operator</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">istream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (type &amp;)   <span class="hljs-comment">// type of int, double etc.</span><br></code></pre></td></tr></table></figure><ul><li>Flushing the Input Buffer - ignore()</li></ul><p>You can use the <code>ignore()</code> to discard characters in the input buffer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">istream &amp; <span class="hljs-title">ignore</span> <span class="hljs-params">(<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> delim = EOF)</span></span>;<br>    <span class="hljs-comment">// Read and discard up to n characters or delim, whichever comes first</span><br> <br><span class="hljs-comment">// Examples</span><br>cin.<span class="hljs-built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="hljs-built_in">max</span>());        <span class="hljs-comment">// Ignore to the end-of-file</span><br>cin.<span class="hljs-built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="hljs-built_in">max</span>(), <span class="hljs-string">&#x27;\n&#x27;</span>);  <span class="hljs-comment">// Ignore to the end-of-line</span><br></code></pre></td></tr></table></figure><h3 id="unformatted-inputoutput-functions"><a class="markdownIt-Anchor" href="#unformatted-inputoutput-functions"></a> Unformatted Input/Output Functions</h3><ul><li><code>put(), get() and getline()</code></li></ul><p>The <code>ostream</code>'s member function <code>put()</code> can be used to put out a <code>char</code>. <code>put()</code> returns the invoking <code>ostream</code> reference, and thus, can be cascaded. For example,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ostream class</span><br><span class="hljs-function">ostream &amp; <span class="hljs-title">put</span> <span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>;  <span class="hljs-comment">// put char c to ostream</span><br><span class="hljs-comment">// Examples</span><br>cout.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>cout.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;A&#x27;</span>).<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;p&#x27;</span>).<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;p&#x27;</span>).<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>cout.<span class="hljs-built_in">put</span>(<span class="hljs-number">65</span>);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// istream class</span><br><span class="hljs-comment">// Single character input</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span> <span class="hljs-params">()</span></span>;   <br>      <span class="hljs-comment">// Get a char and return as int. It returns EOF at end-of-file</span><br><span class="hljs-function">istream &amp; <span class="hljs-title">get</span> <span class="hljs-params">(<span class="hljs-type">char</span> &amp; c)</span></span>;<br>      <span class="hljs-comment">// Get a char, store in c and return the invoking istream reference</span><br> <br><span class="hljs-comment">// C-string input</span><br><span class="hljs-function">istream &amp; <span class="hljs-title">get</span> <span class="hljs-params">(<span class="hljs-type">char</span> * cstr, streamsize n, <span class="hljs-type">char</span> delim = <span class="hljs-string">&#x27;\n&#x27;</span>)</span></span>;<br>      <span class="hljs-comment">// Get n-1 chars or until delimiter and store in C-string array cstr.</span><br>      <span class="hljs-comment">// Append null char to terminate C-string</span><br>      <span class="hljs-comment">// Keep the delim char in the input stream.</span><br><span class="hljs-function">istream &amp; <span class="hljs-title">getline</span> <span class="hljs-params">(<span class="hljs-type">char</span> * cstr, streamsize n, <span class="hljs-type">char</span> delim = <span class="hljs-string">&#x27;\n&#x27;</span>)</span></span>;<br>      <span class="hljs-comment">// Same as get(), but extract and discard delim char from the</span><br>      <span class="hljs-comment">// input stream.</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Examples</span><br><span class="hljs-type">int</span> inChar;<br><span class="hljs-keyword">while</span> ((inChar = cin.<span class="hljs-built_in">get</span>()) != EOF) &#123;  <span class="hljs-comment">// Read till End-of-file</span><br>   cout.<span class="hljs-built_in">put</span>(inchar);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>read(), write() and gcount()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// istream class</span><br><span class="hljs-function">istream &amp; <span class="hljs-title">read</span> <span class="hljs-params">(<span class="hljs-type">char</span> * buf, streamsize n)</span></span>;<br>      <span class="hljs-comment">// Read n characters from istream and keep in char array buf.</span><br>      <span class="hljs-comment">// Unlike get()/getline(), it does not append null char at the end of input.</span><br>      <span class="hljs-comment">// It is used for binary input, instead of C-string.</span><br><span class="hljs-function">streamsize <span class="hljs-title">gcount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>      <span class="hljs-comment">// Return the number of character extracted by the last unformatted input operation</span><br>      <span class="hljs-comment">// get(), getline(), ignore() or read().</span><br> <br><span class="hljs-comment">// ostream class</span><br><span class="hljs-function">ostream &amp; <span class="hljs-title">write</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * buf, streamsize n)</span></span><br></code></pre></td></tr></table></figure><ul><li><code>peek() and putback()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">peek</span> <span class="hljs-params">()</span></span>;<br>      <span class="hljs-comment">//returns the next character in the input buffer without extracting it.</span><br> <br><span class="hljs-function">istream &amp; <span class="hljs-title">putback</span> <span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>;<br>      <span class="hljs-comment">// insert the character back to the input buffer.</span><br></code></pre></td></tr></table></figure><h2 id="file-inputoutput-header-fstream"><a class="markdownIt-Anchor" href="#file-inputoutput-header-fstream"></a> File Input/Output (Header <fstream>)</h2><h3 id="file-output"><a class="markdownIt-Anchor" href="#file-output"></a> File Output</h3><p>Steps:</p><ol><li>Construct an <code>ostream</code> object.</li><li>Connect it to a file (i.e., file open) and set the mode of file operation (e.g, truncate, append).</li><li>Perform output operation via insertion <code>&gt;&gt;</code> operator or <code>write()</code>, <code>put()</code> functions.</li><li>Disconnect (close the file which flushes the output buffer) and free the <code>ostream</code> object.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br>.......<br>ofstream fout;<br>fout.<span class="hljs-built_in">open</span>(filename, mode);<br>......<br>fout.<span class="hljs-built_in">close</span>();<br> <br><span class="hljs-comment">// OR combine declaration and open()</span><br><span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(filename, mode)</span></span>;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>File Modes:</p><p><code>ios::trunc</code> - truncate the file and discard old contents.</p><p>For output, the default mode is <code>ios::out | ios::trunc</code>.</p><p>For input, the default mode is <code>ios::in</code>.</p>          </div><h3 id="file-input"><a class="markdownIt-Anchor" href="#file-input"></a> File Input</h3><p>Steps:</p><ol><li>Construct an <code>istream</code> object.</li><li>Connect it to a file (i.e., file open) and set the mode of file operation.</li><li>Perform output operation via extraction <code>&lt;&lt;</code> operator or <code>read()</code>, <code>get()</code>, <code>getline()</code> functions.</li><li>Disconnect (close the file) and free the <code>istream</code> object.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br>.......<br>ifstream fin;<br>fin.<span class="hljs-built_in">open</span>(filename, mode);<br>......<br>fin.<span class="hljs-built_in">close</span>();<br> <br><span class="hljs-comment">// OR combine declaration and open()</span><br><span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(filename, mode)</span></span>;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <ul><li><p>Most of the <code>&lt;fstream&gt;</code> functions (such as constructors, <code>open()</code>) <strong>supports filename in C-string only</strong>. You may need to extract the C-string from <code>string</code> object via the <code>c_str()</code> member function.</p></li><li><p>The <code>get(char &amp;)</code> function returns a null pointer (converted to <code>false</code>) when it reaches end-of-file.</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">string filename = <span class="hljs-string">&quot;test.txt&quot;</span>;<br><br><span class="hljs-comment">// Write to File</span><br><span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(filename.c_str())</span></span>;  <span class="hljs-comment">// default mode is ios::out | ios::trunc</span><br>fout &lt;&lt; <span class="hljs-string">&quot;apple&quot;</span> &lt;&lt; endl;<br>fout &lt;&lt; <span class="hljs-string">&quot;orange&quot;</span> &lt;&lt; endl;<br>fout &lt;&lt; <span class="hljs-string">&quot;banana&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// Read from file</span><br><span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(filename.c_str())</span></span>;  <span class="hljs-comment">// default mode ios::in</span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span> (fin.<span class="hljs-built_in">get</span>(ch)) &#123;  <span class="hljs-comment">// till end-of-file</span><br>    cout &lt;&lt; ch;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h3 id="binary-file-read-and-write"><a class="markdownIt-Anchor" href="#binary-file-read-and-write"></a> Binary file, read() and write()</h3><p>We need to use <code>read()</code> and <code>write()</code> member functions for binary file (file mode of <code>ios::binary</code>), which read/write raw bytes without interpreting the bytes.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   string filename = <span class="hljs-string">&quot;test.bin&quot;</span>;<br> <br>   <span class="hljs-comment">// Write to File</span><br>   <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(filename.c_str(), ios::out | ios::binary)</span></span>;<br>   <span class="hljs-keyword">if</span> (!fout.<span class="hljs-built_in">is_open</span>()) &#123;<br>      cerr &lt;&lt; <span class="hljs-string">&quot;error: open file for output failed!&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">abort</span>();<br>   &#125;<br>   <span class="hljs-type">int</span> i = <span class="hljs-number">1234</span>;<br>   <span class="hljs-type">double</span> d = <span class="hljs-number">12.34</span>;<br>   fout.<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span> *)&amp;i, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>   fout.<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span> *)&amp;d, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<br>   fout.<span class="hljs-built_in">close</span>();<br> <br>   <span class="hljs-comment">// Read from file</span><br>   <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(filename.c_str(), ios::in | ios::binary)</span></span>;<br>   <span class="hljs-keyword">if</span> (!fin.<span class="hljs-built_in">is_open</span>()) &#123;<br>      cerr &lt;&lt; <span class="hljs-string">&quot;error: open file for input failed!&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">abort</span>();<br>   &#125;<br>   <span class="hljs-type">int</span> i_in;<br>   <span class="hljs-type">double</span> d_in;<br>   fin.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;i_in, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>   cout &lt;&lt; i_in &lt;&lt; endl;<br>   fin.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;d_in, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<br>   cout &lt;&lt; d_in &lt;&lt; endl;<br>   fin.<span class="hljs-built_in">close</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="string-streams"><a class="markdownIt-Anchor" href="#string-streams"></a> String Streams</h2><h3 id="ostringstream-and-istringstream"><a class="markdownIt-Anchor" href="#ostringstream-and-istringstream"></a> <code>ostringstream</code> and <code>istringstream</code></h3><p>String streams act like a <strong>string buffer</strong>.</p><p>Input string stream can be used to validate input data; output string stream can be used to format the output.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// construct output string stream (buffer) - need &lt;sstream&gt; header</span><br>ostringstream sout;  <br>    <br><span class="hljs-comment">// Write into string buffer</span><br>sout &lt;&lt; <span class="hljs-string">&quot;apple&quot;</span> &lt;&lt; endl;<br>sout &lt;&lt; <span class="hljs-string">&quot;orange&quot;</span> &lt;&lt; endl;<br>sout &lt;&lt; <span class="hljs-string">&quot;banana&quot;</span> &lt;&lt; endl;<br> <br><span class="hljs-comment">// Get contents</span><br>cout &lt;&lt; sout.<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// construct input string stream (buffer) - need &lt;sstream&gt; header</span><br><span class="hljs-function">istringstream <span class="hljs-title">sin</span><span class="hljs-params">(<span class="hljs-string">&quot;123 12.34 hello&quot;</span>)</span></span>;<br> <br><span class="hljs-comment">// Read from buffer</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">double</span> d;<br>string s;<br>sin &gt;&gt; i &gt;&gt; d &gt;&gt; s;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; s &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h1 id="miscellaneous-tips-and-traps"><a class="markdownIt-Anchor" href="#miscellaneous-tips-and-traps"></a> Miscellaneous, Tips and Traps</h1><h2 id="exception-handling-2"><a class="markdownIt-Anchor" href="#exception-handling-2"></a> Exception Handling</h2><h3 id="throw-try-and-catch"><a class="markdownIt-Anchor" href="#throw-try-and-catch"></a> throw, try and catch</h3><p>Suppose that we have a class called <code>PositiveInteger</code>, which maintains a data member <code>value</code> containing a positive integer.</p><p><code>PositiveInteger.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Setter with input validation</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PositiveInteger::setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (v &gt; <span class="hljs-number">0</span>) &#123;<br>      value = v;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;value shall be more than 0.&quot;</span>);<br>            <span class="hljs-comment">// need &lt;stdexcept&gt;</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TestPositiveInteger.cpp</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Graceful handling of exception with try-catch</span><br><span class="hljs-keyword">try</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;begin try 1...&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">PositiveInteger <span class="hljs-title">i3</span><span class="hljs-params">(<span class="hljs-number">-8</span>)</span></span>;<br>    <span class="hljs-comment">// Exception thrown.</span><br>    <span class="hljs-comment">// Skip the remaining statements in try and jump to catch.</span><br>    cout &lt;&lt; i3.<span class="hljs-built_in">getValue</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;end try 1...&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// Continue to the next statement after try-catch, if there is no exception</span><br>&#125; <span class="hljs-built_in">catch</span> (invalid_argument &amp; ex) &#123;  <span class="hljs-comment">// need &lt;stdexcept&gt;</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// Continue to the next statement after try-catch</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;after try-catch 1...&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="class-exception-and-its-subclasses"><a class="markdownIt-Anchor" href="#class-exception-and-its-subclasses"></a> Class <code>exception</code> and its subclasses</h3><p><img src="../imgs/202501091252319.png" alt="Class exception and its subclasses" /></p><h3 id="creating-your-own-exception-subclass"><a class="markdownIt-Anchor" href="#creating-your-own-exception-subclass"></a> Creating Your Own exception subclass</h3><p>You can create your own exception by subclassing <code>exception</code> or its subclasses (such as <code>logic_error</code> or <code>runtime_error</code>). For example,</p><p><code>MyException.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Header for the MyException class (MyException.h) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_EXCEPTION_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_EXCEPTION_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> : <span class="hljs-keyword">public</span> std::logic_error &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// Constructor</span><br>   <span class="hljs-built_in">MyException</span>() : std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;my custom error&quot;</span>) &#123; &#125;;<br>&#125;;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>Provide a constructor with a custom what-message.</p>          </div><p><code>TestMyException.cpp</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyException</span>();<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-built_in">fun</span>();<br>   &#125; <span class="hljs-built_in">catch</span> (MyException &amp; ex) &#123;<br>      cout &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="storage-duration-scopes-and-linkages"><a class="markdownIt-Anchor" href="#storage-duration-scopes-and-linkages"></a> Storage Duration, Scopes and Linkages</h2><p>The <em>duration</em> determines when the variable is created and destroyed;</p><p>The <em>Scope</em> determines which part of the program can access the variable;</p><p>The <em>linkage</em> determines whether the variable is available in other source files.</p><img src="../imgs/202501091438580.png" alt="" style="zoom:150%;" /><h3 id="automatic-local-variables-auto-specifier"><a class="markdownIt-Anchor" href="#automatic-local-variables-auto-specifier"></a> Automatic Local Variables (&quot;auto&quot; Specifier)</h3><p>Local variables have default type <code>auto</code>.</p><h3 id="static-variables-static-specifier"><a class="markdownIt-Anchor" href="#static-variables-static-specifier"></a> Static Variables (&quot;static&quot; Specifier)</h3><p>Static variables has three types of linkage:</p><ol><li>external: global static variables <strong>visible in other source files</strong> - defined outside all functions <strong>without keyword <code>static</code></strong>.</li><li>internal: global static file-scope variables <strong>visible in the file</strong> that it is defined - defined outside all functions <strong>with keyword <code>static</code></strong>.</li><li>no linkage: local static variable visible within a function or block for which it is defined - defined inside a function <strong>with keyword <code>static</code></strong>.</li></ol><ul><li>static class members</li></ul><p>A <code>static</code> class member (data or function) belongs to the class, instead of instances. It can be <strong>referenced directly from the class</strong>, without creating instances, via <code>*Classname*::*staticMemberName*</code>. A <code>static</code> data member retains its value throughout the program execution.</p><div class="note note-info">            <ul><li>Summary of <code>static</code> Keyword</li></ul><p>A <code>static</code> variable defined inside a block has block-scope, but having duration for the entire program. It retains its memory and value across multiple invocations.</p><p>A <code>static</code> global variable defined outside all functions has file-scope with internal linkage (i.e., visible only to the file in which it is defined, but not other source files). It has duration for the entire program, and retains its memory and value throughout the program execution. On the other hand, a global variable without the static keyword has file-scope with external linkage. It can be referenced by other file via the <code>extern</code> keyword.</p><p>A <code>static</code> class member belongs to the class, instead of the instances. There is one copy shared by all the instances. It has class scope. To reference it outside the class, use the scope resolution operator <code>*classname*::*static_membername*</code>.</p>          </div><h3 id="external-variables-extern-specifier"><a class="markdownIt-Anchor" href="#external-variables-extern-specifier"></a> External Variables (&quot;extern&quot; Specifier)</h3><p>The <code>extern</code> specifies linkage to another source file. It tells the compiler that the identifier is defined in another (external) source file.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File1.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalVar;  <span class="hljs-comment">// Declare that this variable is defined in another file (external variable).</span><br>                       <span class="hljs-comment">// Cannot assign an value.</span><br>                       <span class="hljs-comment">// Need to link to the other file.</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// File2.cpp</span><br><span class="hljs-type">int</span> globalVar = <span class="hljs-number">88</span>;         <span class="hljs-comment">// Definition here</span><br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalVar = <span class="hljs-number">88</span>;  <span class="hljs-comment">// The &quot;extern&quot; specifier is optional.</span><br>                            <span class="hljs-comment">// The initialization indicates definition</span><br></code></pre></td></tr></table></figure><p>2.5 CV-Qualifiers (const and volatile) and mutable</p><p>The &quot;<code>const</code>&quot; qualifier indicates that the content of the storage location shall not be changed after initialized.</p><p>The &quot;volatile&quot; qualifier indicates that the content of the storage location could be altered outside your program, e.g., by an external hardware. This qualifier is needed to tell compiler not to optimize this particular location (e.g., not to store in register, not to re-order the statement, or collapse multiple statements).</p><p>The <code>mutable</code> specifier can be used in <code>struct</code> or <code>class</code> to indicate that a particular data member is <strong>modifiable even though the instance is declared <code>const</code></strong>.</p><div class="note note-danger">            <ul><li>&quot;const&quot; Global Variables</li></ul><p>By default, a global variable (defined outside all functions) has external linkage. However, <code>const</code> global variable has internal linkage (as if <code>static</code> specifier is used). As the result, you can place all <code>const</code> global variables in a header file, and include the header in all the source files. To set a <code>const</code> global variable to external linkage, include &quot;<code>extern</code>&quot; specifier.</p>          </div><h2 id="type-casting-operators"><a class="markdownIt-Anchor" href="#type-casting-operators"></a> Type Casting Operators</h2><p>C++ introduces 4 new type casting operators: <code>const_cast&lt;new-type&gt;(value)</code>, <code>static_cast&lt;new-type&gt;(value)</code>, <code>dynamic_cast&lt;new-type&gt;(value)</code>, <code>reinterpret_cast&lt;new-type&gt;(value)</code> to regulate type casting.</p><div class="note note-success">            <p>C++ supports C's explicit type casting operations <code>(new-type)value</code> (C-style cast), or <code>new-type(value)</code> (Function-style cast), called <em>regular cast</em>.</p><p>Although the old styles is still acceptable in C++, new styles are preferable.</p>          </div><ul><li><code>static_cast</code></li></ul><p><code>static_cast</code> is used for force implicit conversion. It throws a type-cast error if the conversion fails.</p><p>Can be used to convert values of various fundamental types, e.g., from <code>double</code> to <code>int</code>, from <code>float</code> to <code>long</code>.</p><ul><li><code>dynamic_cast</code></li></ul><p><code>dynamic_cast</code> can be used to verify the type of an object at runtime, before performing the type conversion. It is primarily used to perform &quot;safe downcasting&quot;.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">dynamic_cast</span>&lt;Type *&gt;(ptr)<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base* basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radius</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// Circle specific method</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processShape</span><span class="hljs-params">(Shape* shape)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Circle* circle = <span class="hljs-built_in">dynamic_cast</span>&lt;Circle*&gt;(shape)) &#123;<br>        circle-&gt;<span class="hljs-built_in">radius</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>const_cast</code></li></ul><p>The <code>const_cast</code> can be used to drop the <code>const</code> label, so as to alter its contents (i.e., cast away the <code>const</code>-ness or <code>volatile</code>-ness). This is useful if you have a variable which is constant most of the time, but need to be changed in some circumstances. You can declare the variable as <code>const</code>, and use <code>const_cast</code> to alter its value. The syntax is:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">const_cast&lt;<span class="hljs-keyword">Type</span>&gt;(expression)<br></code></pre></td></tr></table></figure><p><code>const_cast</code> cannot change the type of an object.</p><ul><li><code>reinterpret_cast</code></li></ul><p>Used for low-level casts that yield implementation-dependent result, e.g., casting a pointer to an <code>int</code>.</p><h1 id="data-structure-and-algorithm"><a class="markdownIt-Anchor" href="#data-structure-and-algorithm"></a> Data Structure and Algorithm</h1><h2 id="searching"><a class="markdownIt-Anchor" href="#searching"></a> Searching</h2><ul><li>Linear Search: See &quot;<a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_Basics.html#LinearSearch">Linear Search</a>&quot;.</li><li>Recursive Binary Search for sorted list</li><li>Binary Tree Search</li></ul><h3 id="linear-search"><a class="markdownIt-Anchor" href="#linear-search"></a> Linear Search</h3><p>Simple!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Search the array for the given key</span><br><span class="hljs-comment">// If found, return array index [0, size-1]; otherwise, return size</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">linearSearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (a[i] == key) <span class="hljs-keyword">return</span> i;<br>   &#125;<br>   <span class="hljs-keyword">return</span> size;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="binary-search"><a class="markdownIt-Anchor" href="#binary-search"></a> Binary Search</h3><p>A binary search (or half-interval search) is applicable only to a <strong>sorted array</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Search the array for the given key</span><br><span class="hljs-comment">// If found, return array index; otherwise, return -1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>   <span class="hljs-comment">// Call recursive helper function</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(a, <span class="hljs-number">0</span>, size<span class="hljs-number">-1</span>, key);<br>&#125;<br> <br><span class="hljs-comment">// Recursive helper function for binarySearch</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> iLeft, <span class="hljs-type">int</span> iRight, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>   <span class="hljs-comment">// Test for empty list</span><br>   <span class="hljs-keyword">if</span> (iLeft &gt; iRight) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br> <br>   <span class="hljs-comment">// Compare with middle element</span><br>   <span class="hljs-type">int</span> mid = (iRight + iLeft) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// truncate</span><br>   <span class="hljs-keyword">if</span> (key == a[mid]) &#123;<br>      <span class="hljs-keyword">return</span> mid;<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; a[mid]) &#123;<br>      <span class="hljs-comment">// Recursively search the lower half</span><br>      <span class="hljs-built_in">binarySearch</span>(a, iLeft, mid - <span class="hljs-number">1</span>, key);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Recursively search the upper half</span><br>      <span class="hljs-built_in">binarySearch</span>(a, mid + <span class="hljs-number">1</span>, iRight, key);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sorting"><a class="markdownIt-Anchor" href="#sorting"></a> Sorting</h2><ul><li>Insertion Sort: See &quot;<a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_Basics.html#InsertionSort">Insertion Sort</a>&quot;.</li><li>Selection Sort: See &quot;<a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_Basics.html#SelectionSort">Selection Sort</a>&quot;.</li><li>Bubble Sort: See &quot;<a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_Basics.html#BubbleSort">Bubble Sort</a>&quot;</li><li>Merge Sort (Recursive Top-Down or Interactive Bottom-up)</li><li>Quick Sort (Recursive)</li><li>Bucket Sort</li><li>Heap Sort</li><li>Binary Tree Sort</li></ul><h3 id="insertion-sort"><a class="markdownIt-Anchor" href="#insertion-sort"></a> Insertion sort</h3><p>For each element, compare with all previous elements and insert it at the correct position by shifting the other elements. For example,</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;8,4,5,3,2,9,4,1&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;8&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;4,5,3,2,9,4,1&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;4,8&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;5,3,2,9,4,1&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;4,5,8&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;3,2,9,4,1&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;3,4,5,8&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;2,9,4,1&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;2,3,4,5,8&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;9,4,1&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;2,3,4,5,8,9&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;4,1&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;2,3,4,4,5,8,9&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;1,2,3,4,4,5,8,9&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Sort the given array of size using insertion sort</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>   <span class="hljs-type">int</span> temp;   <span class="hljs-comment">// for shifting elements</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; ++i) &#123;<br>      <span class="hljs-comment">// For element at i, insert into proper position in [0, i-1]</span><br>      <span class="hljs-comment">// which is already sorted.</span><br>      <span class="hljs-comment">// Shift down the other elements</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> prev = <span class="hljs-number">0</span>; prev &lt; i; ++prev) &#123;<br>         <span class="hljs-keyword">if</span> (a[i] &lt; a[prev]) &#123;<br>            <span class="hljs-comment">// insert a[i] at prev, shift the elements down</span><br>            temp = a[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> shift = i; shift &gt; prev; --shift) &#123;<br>               a[shift] = a[shift<span class="hljs-number">-1</span>];<br>            &#125;<br>            a[prev] = temp;<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Insertion sort is not efficient, with complexity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p><h3 id="selection-sort"><a class="markdownIt-Anchor" href="#selection-sort"></a> Selection sort</h3><p>Pass thru the list. Select the smallest element and swap with the head of the list.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Sort the given array of size using selection sort</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>   <span class="hljs-type">int</span> temp; <span class="hljs-comment">// for swapping</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-comment">// [0, i-1] already sort</span><br>      <span class="hljs-comment">// Search for the smallest element in [i, size-1]</span><br>      <span class="hljs-comment">// and swap with a[i]</span><br>      <span class="hljs-type">int</span> minIndex = i;  <span class="hljs-comment">// assume fist element is the smallest</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; size; ++j) &#123;<br>         <span class="hljs-keyword">if</span> (a[j] &lt; a[minIndex]) minIndex = j;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (minIndex != i) &#123;  <span class="hljs-comment">// swap</span><br>         temp = a[i];<br>         a[i] = a[minIndex];<br>         a[minIndex] = temp;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Selection sort is not efficient, with complexity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p><h3 id="bubble-sort"><a class="markdownIt-Anchor" href="#bubble-sort"></a> Bubble sort</h3><p>Pass thru the list, compare two adjacent items and swap them if they are in the wrong order. <strong>Repeat the pass until no swaps are needed</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Sort the given array of size</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>   <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>; <span class="hljs-comment">// terminate if no more swap thru a pass</span><br>   <span class="hljs-type">int</span> temp;          <span class="hljs-comment">// use for swapping</span><br> <br>   <span class="hljs-keyword">while</span> (!done) &#123;<br>      done = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// Pass thru the list, compare adjacent items and swap</span><br>      <span class="hljs-comment">// them if they are in wrong order</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; ++i) &#123;<br>         <span class="hljs-keyword">if</span> (a[i] &gt; a[i+<span class="hljs-number">1</span>]) &#123;<br>            temp = a[i];<br>            a[i] = a[i+<span class="hljs-number">1</span>];<br>            a[i+<span class="hljs-number">1</span>] = temp;<br>            done = <span class="hljs-literal">false</span>;   <span class="hljs-comment">// swap detected, one more pass</span><br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Bubble sort is not efficient, with complexity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p><h3 id="merge-sort"><a class="markdownIt-Anchor" href="#merge-sort"></a> Merge Sort</h3><ul><li><strong>Recursive</strong> Top-Down Merge Sort</li></ul><ol><li>Recursively divide the list into 2 sublists.</li><li>When the sublists contain 1 element (a list of 1 element is sorted), merge two sublists in the right order. Unwind the merging recursively.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Function to merge two sorted subarrays into a single sorted array</span><br><span class="hljs-comment">// arr[left..mid] and arr[mid+1..right] are the subarrays to be merged</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">// Calculate sizes of the two subarrays to be merged</span><br>    <span class="hljs-type">int</span> n1 = mid - left + <span class="hljs-number">1</span>;  <span class="hljs-comment">// Size of left subarray</span><br>    <span class="hljs-type">int</span> n2 = right - mid;     <span class="hljs-comment">// Size of right subarray</span><br>    <br>    <span class="hljs-comment">// Create temporary arrays to store the two halves</span><br>    <span class="hljs-comment">// This extra space is necessary to perform the merge</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n1)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">R</span><span class="hljs-params">(n2)</span></span>;<br>    <br>    <span class="hljs-comment">// Copy data to temporary arrays L[] and R[]</span><br>    <span class="hljs-comment">// This allows us to modify the original array while merging</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++)<br>        L[i] = arr[left + i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n2; j++)<br>        R[j] = arr[mid + <span class="hljs-number">1</span> + j];<br>    <br>    <span class="hljs-comment">// Initialize indices for merging</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-comment">// Initial index of left subarray</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-comment">// Initial index of right subarray</span><br>    <span class="hljs-type">int</span> k = left; <span class="hljs-comment">// Initial index of merged array</span><br>    <br>    <span class="hljs-comment">// Merge the temporary arrays back into arr[left..right]</span><br>    <span class="hljs-comment">// Compare elements from both subarrays and place the smaller one first</span><br>    <span class="hljs-keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>        <span class="hljs-keyword">if</span>(L[i] &lt;= R[j]) &#123;<br>            arr[k] = L[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arr[k] = R[j];<br>            j++;<br>        &#125;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Copy remaining elements of L[], if any</span><br>    <span class="hljs-comment">// If there are any elements left in the left subarray</span><br>    <span class="hljs-keyword">while</span>(i &lt; n1) &#123;<br>        arr[k] = L[i];<br>        i++;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Copy remaining elements of R[], if any</span><br>    <span class="hljs-comment">// If there are any elements left in the right subarray</span><br>    <span class="hljs-keyword">while</span>(j &lt; n2) &#123;<br>        arr[k] = R[j];<br>        j++;<br>        k++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Recursive function to sort an array using merge sort</span><br><span class="hljs-comment">// left is the left index and right is the right index of the subarray to be sorted</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSortRecursive</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">// Base case: if left &gt;= right, subarray has 0 or 1 element (already sorted)</span><br>    <span class="hljs-keyword">if</span>(left &lt; right) &#123;<br>        <span class="hljs-comment">// Find the middle point to divide array into two halves</span><br>        <span class="hljs-comment">// Using (left + right)/2 might cause integer overflow</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// Sort first and second halves recursively</span><br>        <span class="hljs-built_in">mergeSortRecursive</span>(arr, left, mid);      <span class="hljs-comment">// Sort left half</span><br>        <span class="hljs-built_in">mergeSortRecursive</span>(arr, mid + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// Sort right half</span><br>        <br>        <span class="hljs-comment">// Merge the sorted halves</span><br>        <span class="hljs-built_in">merge</span>(arr, left, mid, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Iterative</strong> Bottom-up Merge Sort</li></ul><ol><li>Treat the list as sublists of length 1.</li><li>Interactively merge a pair of sublists bottom-up, until there is only one sublist.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// The merge function remains similar to the recursive version</span><br><span class="hljs-comment">// It combines two sorted subarrays into a single sorted array</span><br><span class="hljs-comment">// arr[left..mid] and arr[mid+1..right] are the subarrays to be merged</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n1 = mid - left + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n2 = right - mid;<br>    <br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n1)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">R</span><span class="hljs-params">(n2)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++)<br>        L[i] = arr[left + i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n2; j++)<br>        R[j] = arr[mid + <span class="hljs-number">1</span> + j];<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = left;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>        <span class="hljs-keyword">if</span>(L[i] &lt;= R[j]) &#123;<br>            arr[k] = L[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arr[k] = R[j];<br>            j++;<br>        &#125;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; n1) &#123;<br>        arr[k] = L[i];<br>        i++;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(j &lt; n2) &#123;<br>        arr[k] = R[j];<br>        j++;<br>        k++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Iterative merge sort implementation using a bottom-up approach</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSortIterative</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-comment">// Start merging subarrays of size 1, then 2, 4, 8, and so on</span><br>    <span class="hljs-comment">// The &#x27;width&#x27; variable represents the size of subarrays being merged</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> width = <span class="hljs-number">1</span>; width &lt; n; width = width * <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// For each pair of subarrays of size &#x27;width&#x27;</span><br>        <span class="hljs-comment">// left marks the start of the first subarray</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left = left + <span class="hljs-number">2</span> * width) &#123;<br>            <span class="hljs-comment">// Calculate the middle point and right boundary</span><br>            <span class="hljs-type">int</span> mid = std::<span class="hljs-built_in">min</span>(left + width - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> right = std::<span class="hljs-built_in">min</span>(left + <span class="hljs-number">2</span> * width - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>            <br>            <span class="hljs-comment">// Merge the two subarrays if they exist</span><br>            <span class="hljs-keyword">if</span>(left &lt; mid &amp;&amp; mid &lt; right) &#123;<br>                <span class="hljs-built_in">merge</span>(arr, left, mid, right);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The worst-case and average-case <strong>time complexity is O(n log n)</strong>. The best-case is typically O(n log n). However, merge sort requires a <strong>space complexity of O(n)</strong> for carrying out the merge-sorting.</p><h3 id="quick-sort"><a class="markdownIt-Anchor" href="#quick-sort"></a> Quick Sort</h3><p>The Core Idea:</p><ol><li>Choose a 'pivot' element from the array</li><li>Partition the array around this pivot (elements smaller than pivot go to the left, larger to the right)</li><li>Recursively apply the same process to the subarrays</li></ol><p>For example, consider the array [10, 7, 8, 9, 1, 5]:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Initial array: <span class="hljs-comment">[10, 7, 8, 9, 1, 5]</span>  (pivot = 5)<br>After partition: <span class="hljs-comment">[1, | 5 | 10, 7, 8, 9]</span><br><br><span class="hljs-comment">[10, 7, 8, 9]</span> (pivot = 9)<br>After partition: <span class="hljs-comment">[7, 8, | 9 | 10]</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// This function takes the last element as pivot, places the pivot </span><br><span class="hljs-comment">// at its correct position, and places smaller elements to the left </span><br><span class="hljs-comment">// and greater elements to the right</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-comment">// Select the rightmost element as pivot</span><br>    <span class="hljs-type">int</span> pivot = arr[high];<br>    <br>    <span class="hljs-comment">// Index of smaller element</span><br>    <span class="hljs-type">int</span> i = low - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// Compare each element with pivot</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = low; j &lt; high; j++) &#123;<br>        <span class="hljs-comment">// If current element is smaller than pivot</span><br>        <span class="hljs-keyword">if</span>(arr[j] &lt;= pivot) &#123;<br>            i++;    <span class="hljs-comment">// Increment index of smaller element</span><br>            std::<span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Place pivot in its final position</span><br>    std::<span class="hljs-built_in">swap</span>(arr[i + <span class="hljs-number">1</span>], arr[high]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// The main QuickSort function</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high) &#123;<br>        <span class="hljs-comment">// Find the partition index</span><br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partition</span>(arr, low, high);<br>        <br>        <span class="hljs-comment">// Separately sort elements before and after partition</span><br>        <span class="hljs-built_in">quickSort</span>(arr, low, pi - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, pi + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The <strong>worst-case time complexity is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></strong>. The <strong>average-case and best-case is O(n log n)</strong>. In-place sorting can be achieved without additional space requirement.</p><h3 id="bucket-sort"><a class="markdownIt-Anchor" href="#bucket-sort"></a> Bucket Sort</h3><p>Bucket sort is a distribution sort, and is a cousin of radix sort.</p><p>The core idea:</p><ol><li>Set up buckets, initially empty.</li><li>Scatter: place each element into an appropriate bucket.</li><li>Sort each non-empty bucket.</li><li>Gather: Gather elements from buckets and put back to the original array.</li></ol><ul><li>Radix Sort</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>   <span class="hljs-comment">// find maximum to decide on the number of significant digits</span><br>   <span class="hljs-type">int</span> max = a[<span class="hljs-number">0</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (a[i] &gt; max) max = a[i];<br>   &#125;<br> <br>   <span class="hljs-comment">// Decide on the max radix (1000, 100, 10, 1, etc)</span><br>   <span class="hljs-type">int</span> radix = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">while</span> (max &gt; <span class="hljs-number">10</span>) &#123;<br>      radix *= <span class="hljs-number">10</span>;<br>      max /= <span class="hljs-number">10</span>;<br>   &#125;<br> <br>   <span class="hljs-comment">// copy the array into a vector</span><br>   <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">list</span><span class="hljs-params">(size)</span></span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>      list[i] = a[i];<br>   &#125;<br>   <span class="hljs-built_in">bucketSort</span>(list, radix);<br>&#125;<br> <br><span class="hljs-comment">// Sort the given array of size on the particular radix (1, 10, 100, etc)</span><br><span class="hljs-comment">// Assume elements are non-negative integers</span><br><span class="hljs-comment">// radix shall be more than 0</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; list, <span class="hljs-type">int</span> radix)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (list.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; radix &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// Sort if more than 1 elements</span><br>      vector&lt;<span class="hljs-type">int</span>&gt; buckets[NUM_BUCKETS];  <span class="hljs-comment">// 10 buckets</span><br> <br>      <span class="hljs-comment">// Distribute elements into buckets</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>         <span class="hljs-type">int</span> bucketIndex = list[i] / radix % <span class="hljs-number">10</span>;<br>         buckets[bucketIndex].<span class="hljs-built_in">push_back</span>(list[i]);<br>      &#125;<br> <br>      <span class="hljs-comment">// Recursively sort the non-empty bucket</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bi = <span class="hljs-number">0</span>; bi &lt; NUM_BUCKETS; ++bi) &#123;<br>         <span class="hljs-keyword">if</span> (buckets[bi].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">bucketSort</span>(buckets[bi], radix / <span class="hljs-number">10</span>);<br>         &#125;<br>      &#125;<br> <br>      <span class="hljs-comment">// Gather all the buckets into list and return</span><br>      list.<span class="hljs-built_in">resize</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// remove all elements</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bi = <span class="hljs-number">0</span>; bi &lt; NUM_BUCKETS; ++bi) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; buckets[bi].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            list.<span class="hljs-built_in">push_back</span>((buckets[bi])[j]);<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>For example:</p><p>Consider the initial array: {28,104,25,593,22,129,4,11,129,4,111,20,9}</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">To</span> sort: &#123;<span class="hljs-number">28</span>,<span class="hljs-number">104</span>,<span class="hljs-number">25</span>,<span class="hljs-number">593</span>,<span class="hljs-number">22</span>,<span class="hljs-number">129</span>,<span class="hljs-number">4</span>,<span class="hljs-number">11</span>,<span class="hljs-number">129</span>,<span class="hljs-number">4</span>,<span class="hljs-number">111</span>,<span class="hljs-number">20</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-attribute">radix</span>=<span class="hljs-number">100</span>: &#123;<span class="hljs-number">28</span>,<span class="hljs-number">25</span>,<span class="hljs-number">22</span>,<span class="hljs-number">4</span>,<span class="hljs-number">11</span>,<span class="hljs-number">4</span>,<span class="hljs-number">20</span>,<span class="hljs-number">9</span>&#125; &#123;<span class="hljs-number">104</span>,<span class="hljs-number">129</span>,<span class="hljs-number">129</span>,<span class="hljs-number">111</span>&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;<span class="hljs-number">593</span>&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;<br><br><span class="hljs-attribute">To</span> sort: &#123;<span class="hljs-number">28</span>,<span class="hljs-number">25</span>,<span class="hljs-number">22</span>,<span class="hljs-number">4</span>,<span class="hljs-number">11</span>,<span class="hljs-number">4</span>,<span class="hljs-number">20</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-attribute">radix</span>=<span class="hljs-number">10</span>: &#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>&#125; &#123;<span class="hljs-number">11</span>&#125; &#123;<span class="hljs-number">28</span>,<span class="hljs-number">25</span>,<span class="hljs-number">22</span>,<span class="hljs-number">20</span>&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;<br><span class="hljs-attribute">To</span> sort: &#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-attribute">radix</span>=<span class="hljs-number">1</span>: &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;<span class="hljs-number">9</span>&#125;<br><span class="hljs-attribute">Sorted</span>: &#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-attribute">To</span> sort: &#123;<span class="hljs-number">28</span>,<span class="hljs-number">25</span>,<span class="hljs-number">22</span>,<span class="hljs-number">20</span>&#125;<br><span class="hljs-attribute">radix</span>=<span class="hljs-number">1</span>: &#123;<span class="hljs-number">20</span>&#125; &#123;&#125; &#123;<span class="hljs-number">22</span>&#125; &#123;&#125; &#123;&#125; &#123;<span class="hljs-number">25</span>&#125; &#123;&#125; &#123;&#125; &#123;<span class="hljs-number">28</span>&#125; &#123;&#125;<br><span class="hljs-attribute">Sorted</span>: &#123;<span class="hljs-number">20</span>,<span class="hljs-number">22</span>,<span class="hljs-number">25</span>,<span class="hljs-number">28</span>&#125;<br><span class="hljs-attribute">Sorted</span>: &#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">20</span>,<span class="hljs-number">22</span>,<span class="hljs-number">25</span>,<span class="hljs-number">28</span>&#125;<br><br><span class="hljs-attribute">To</span> sort: &#123;<span class="hljs-number">104</span>,<span class="hljs-number">129</span>,<span class="hljs-number">129</span>,<span class="hljs-number">111</span>&#125;<br><span class="hljs-attribute">radix</span>=<span class="hljs-number">10</span>: &#123;<span class="hljs-number">104</span>&#125; &#123;<span class="hljs-number">111</span>&#125; &#123;<span class="hljs-number">129</span>,<span class="hljs-number">129</span>&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;<br><span class="hljs-attribute">To</span> sort: &#123;<span class="hljs-number">129</span>,<span class="hljs-number">129</span>&#125;<br><span class="hljs-attribute">radix</span>=<span class="hljs-number">1</span>: &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;<span class="hljs-number">129</span>,<span class="hljs-number">129</span>&#125;<br><span class="hljs-attribute">Sorted</span>: &#123;<span class="hljs-number">129</span>,<span class="hljs-number">129</span>&#125;<br><span class="hljs-attribute">Sorted</span>: &#123;<span class="hljs-number">104</span>,<span class="hljs-number">111</span>,<span class="hljs-number">129</span>,<span class="hljs-number">129</span>&#125;<br><span class="hljs-attribute">Sorted</span>: &#123;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">20</span>,<span class="hljs-number">22</span>,<span class="hljs-number">25</span>,<span class="hljs-number">28</span>,<span class="hljs-number">104</span>,<span class="hljs-number">111</span>,<span class="hljs-number">129</span>,<span class="hljs-number">129</span>,<span class="hljs-number">593</span>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>If the maximum number of the array is M, then the time complexity is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n × log_{10}(M))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>​.</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_{10}(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> is the number of digits in number M.</p>          </div><h2 id="data-structures"><a class="markdownIt-Anchor" href="#data-structures"></a> Data Structures</h2><p>Many applications require dynamic data structures, that can grow and shrink during execution. The commonly used data structures include:</p><ul><li>List: Single linked list, double linked list, etc.</li><li>Queue: FIFO queue, priority queue, etc.</li><li>Stack: LIFO queue</li><li>Tree:</li><li>Map or Associative Array:</li></ul><h3 id="single-linked-list"><a class="markdownIt-Anchor" href="#single-linked-list"></a> Single Linked List</h3><p><img src="../imgs/202501150102557.png" alt="Single Linked List" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>;  <span class="hljs-comment">// Forward reference</span><br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   T data;<br>   Node * nextPtr;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">Node</span> (T d) : <span class="hljs-built_in">data</span>(d), <span class="hljs-built_in">nextPtr</span>(<span class="hljs-number">0</span>) &#123; &#125;; <span class="hljs-comment">// Constructor</span><br>   <span class="hljs-function">T <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data; &#125;;   <span class="hljs-comment">// Public getter for data</span><br>   <span class="hljs-function">Node * <span class="hljs-title">getNextPtr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> nextPtr; &#125; <span class="hljs-comment">// Public getter for nextPtr</span><br> <br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&lt;T&gt;;  <span class="hljs-comment">// Make List class a friend to access private data</span><br>&#125;;<br><br><span class="hljs-comment">// Forward Reference</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> List&lt;T&gt; &amp; lst);<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   Node&lt;T&gt; * frontPtr;  <span class="hljs-comment">// First node</span><br>   Node&lt;T&gt; * backPtr;   <span class="hljs-comment">// Last node</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">List</span>();   <span class="hljs-comment">// Constructor</span><br>   ~<span class="hljs-built_in">List</span>();  <span class="hljs-comment">// Destructor</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushFront</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushBack</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">popFront</span><span class="hljs-params">(T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">popBack</span><span class="hljs-params">(T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br> <br><span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; &lt;&gt;(std::ostream &amp; os, <span class="hljs-type">const</span> List&lt;T&gt; &amp; lst);<br>      <span class="hljs-comment">// Overload the stream insertion operator to print the list</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="double-linked-list"><a class="markdownIt-Anchor" href="#double-linked-list"></a> Double Linked List</h3><p><img src="../imgs/202501151358064.png" alt="Double Linked List" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span>; <span class="hljs-comment">// Forward reference</span><br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedNode</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   T data;<br>   DoubleLinkedNode * nextPtr;<br>   DoubleLinkedNode * prevPtr;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">DoubleLinkedNode</span> (T d) : <span class="hljs-built_in">data</span>(d), <span class="hljs-built_in">nextPtr</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prevPtr</span>(<span class="hljs-number">0</span>) &#123; &#125;;<br>   <span class="hljs-function">T <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data; &#125;;<br>   <span class="hljs-function">DoubleLinkedNode * <span class="hljs-title">getNextPtr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> nextPtr; &#125;<br>   <span class="hljs-function">DoubleLinkedNode * <span class="hljs-title">getPrevPtr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> prevPtr; &#125;<br> <br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span>&lt;T&gt;;<br>   <span class="hljs-comment">// Make DoubleLinkedList class a friend to access private data</span><br>&#125;;<br><br><span class="hljs-comment">// Forward Reference</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os,<br>      <span class="hljs-type">const</span> DoubleLinkedList&lt;T&gt; &amp; lst);<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   DoubleLinkedNode&lt;T&gt; * frontPtr;<br>   DoubleLinkedNode&lt;T&gt; * backPtr;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">DoubleLinkedList</span>();   <span class="hljs-comment">// Constructor</span><br>   ~<span class="hljs-built_in">DoubleLinkedList</span>();  <span class="hljs-comment">// Destructor</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushFront</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushBack</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">popFront</span><span class="hljs-params">(T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">popBack</span><span class="hljs-params">(T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br> <br><span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; &lt;&gt;(std::ostream &amp; os,<br>      <span class="hljs-type">const</span> DoubleLinkedList&lt;T&gt; &amp; lst);<br>      <span class="hljs-comment">// Overload the stream insertion operator to print the list</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="stack-lifo-queue"><a class="markdownIt-Anchor" href="#stack-lifo-queue"></a> Stack (LIFO Queue)</h3><p><img src="../imgs/202501151403734.png" alt="Stack" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Forward Reference</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> Stack&lt;T&gt; &amp; s);<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   T * data;      <span class="hljs-comment">// Array</span><br>   <span class="hljs-type">int</span> tos;       <span class="hljs-comment">// Top of stack, start at index -1</span><br>   <span class="hljs-type">int</span> capacity;  <span class="hljs-comment">// capacity of the array</span><br>   <span class="hljs-type">int</span> increment; <span class="hljs-comment">// each subsequent increment size</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Stack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> increment = <span class="hljs-number">10</span>)</span></span>;<br>   ~<span class="hljs-built_in">Stack</span>();  <span class="hljs-comment">// Destructor</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br> <br><span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; &lt;&gt;(std::ostream &amp; os, <span class="hljs-type">const</span> Stack&lt;T&gt; &amp; s);<br>      <span class="hljs-comment">// Overload the stream insertion operator to print the list</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>We use an array to store the data in the stack and use <code>tos</code> as the index of the array to get the data.</p><h3 id="tree"><a class="markdownIt-Anchor" href="#tree"></a> Tree</h3><p>A Binary Tree:</p><p><img src="../imgs/202501151413745.png" alt="Binary Tree" /></p><ul><li>Depth-First Search (DFS)</li></ul><p>Start at the root and explore as far as possible along each branch before backtracking. There are 3 types of depth-first search:</p><ol><li>Pre-order: visit the root, traverse the left subtree, then the right subtree. E.g., 6 -&gt; 5 -&gt; 4 -&gt; 10 -&gt; 7 -&gt; 9 -&gt;15.</li><li>In-order: traverse the left subtree, visit the root, then the right subtree. E.g., 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 9 -&gt;10 -&gt; 15.</li><li>Post-order: traverse the left subtree, the right subtree, then visit the root. E.g, 4 -&gt; 5 -&gt; 9 -&gt; 7 -&gt; 15 -&gt; 10 -&gt; 6.</li></ol><ul><li>Breadth-First Search (BFS)</li></ul><p>Begin at the root, visit all its child nodes. Then for each of the child nodes visited, visit their child nodes in turn. E.g., 6 -&gt; 5 -&gt; 10 -&gt; 4 -&gt; 7 -&gt; 15 -&gt; 9.</p><ul><li>Binary Search Tree</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>; <span class="hljs-comment">// Forward reference</span><br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   T data;<br>   Node * rightPtr;<br>   Node * leftPtr;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">Node</span> (T d) : <span class="hljs-built_in">data</span>(d), <span class="hljs-built_in">rightPtr</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">leftPtr</span>(<span class="hljs-number">0</span>) &#123; &#125;;<br>   <span class="hljs-function">T <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data; &#125;;<br>   <span class="hljs-function">Node * <span class="hljs-title">getRightPtr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> rightPtr; &#125;<br>   <span class="hljs-function">Node * <span class="hljs-title">getLeftPtr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>  </span>&#123; <span class="hljs-keyword">return</span> leftPtr;  &#125;<br> <br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&lt;T&gt;;<br>   <span class="hljs-comment">// Make BinaryTree class a friend to access private data</span><br>&#125;;<br><br><span class="hljs-comment">// Forward Reference</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> BinaryTree&lt;T&gt; &amp; lst);<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>   Node&lt;T&gt; * rootPtr;<br> <br>   <span class="hljs-comment">// private helper functions</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(Node&lt;T&gt; * &amp; ptr, <span class="hljs-type">const</span> T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrderSubTree</span><span class="hljs-params">(<span class="hljs-type">const</span> Node&lt;T&gt; * ptr, std::ostream &amp; os = std::cout)</span> <span class="hljs-type">const</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrderSubTree</span><span class="hljs-params">(<span class="hljs-type">const</span> Node&lt;T&gt; * ptr, std::ostream &amp; os = std::cout)</span> <span class="hljs-type">const</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrderSubTree</span><span class="hljs-params">(<span class="hljs-type">const</span> Node&lt;T&gt; * ptr, std::ostream &amp; os = std::cout)</span> <span class="hljs-type">const</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeSubTree</span><span class="hljs-params">(Node&lt;T&gt; * &amp; ptr)</span></span>;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">BinaryTree</span>();   <span class="hljs-comment">// Constructor</span><br>   ~<span class="hljs-built_in">BinaryTree</span>();  <span class="hljs-comment">// Destructor</span><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; value)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrderTraversal</span><span class="hljs-params">(std::ostream &amp; os = std::cout)</span> <span class="hljs-type">const</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrderTraversal</span><span class="hljs-params">(std::ostream &amp; os = std::cout)</span> <span class="hljs-type">const</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrderTraversal</span><span class="hljs-params">(std::ostream &amp; os = std::cout)</span> <span class="hljs-type">const</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">breadthFirstTraversal</span><span class="hljs-params">(std::ostream &amp; os = std::cout)</span> <span class="hljs-type">const</span></span>;<br> <br><span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; &lt;&gt;(std::ostream &amp; os, <span class="hljs-type">const</span> BinaryTree&lt;T&gt; &amp; lst);<br>      <span class="hljs-comment">// Overload the stream insertion operator to print the list</span><br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>Breadth-First Search: need a FIFO queue to keep the child nodes.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Breadth First Search (BFS)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> BinaryTree&lt;T&gt;::<span class="hljs-built_in">breadthFirstTraversal</span>(std::ostream &amp; os) <span class="hljs-type">const</span> &#123;<br>   std::queue&lt;Node&lt;T&gt; * &gt; q;<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isEmpty</span>()) q.<span class="hljs-built_in">push</span>(rootPtr);<br> <br>   os &lt;&lt; <span class="hljs-string">&quot;&#123; &quot;</span>;<br>   Node&lt;T&gt; * currentPtr;<br>   <span class="hljs-keyword">while</span> (currentPtr = q.<span class="hljs-built_in">front</span>()) &#123;<br>      std::cout &lt;&lt; currentPtr-&gt;data &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>      <span class="hljs-keyword">if</span> (currentPtr-&gt;leftPtr) q.<span class="hljs-built_in">push</span>(currentPtr-&gt;leftPtr);<br>      <span class="hljs-keyword">if</span> (currentPtr-&gt;rightPtr) q.<span class="hljs-built_in">push</span>(currentPtr-&gt;rightPtr);<br>      q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// remove this node</span><br>   &#125;<br>   os &lt;&lt; <span class="hljs-string">&#x27;&#125;&#x27;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>          </div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>File Systems</title>
    <link href="/2024/12/31/File-System/"/>
    <url>/2024/12/31/File-System/</url>
    
    <content type="html"><![CDATA[<h1 id="file-systems"><a class="markdownIt-Anchor" href="#file-systems"></a> File Systems</h1><blockquote><p><strong>Learning Materials</strong></p><p>Videos:</p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/disks.mp4">Disks</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/fs-intro-audio.mp4">Introduction to file systems</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/fs-naming.mp4">File system naming</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/ffs-audio.mp4">FFS</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/ffs-recovery-audio.mp4">File system recovery</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/ffs-journaling-audio.mp4">Journaling file systems</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/lfs-audio.mp4">LFS</a></p><p>Lecture Slides:</p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/file-systems-new.pptx">File systems</a></p><p>Readings:</p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-disks.pdf">OSTEP] Hard disk drives</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-ssd.pdf">OSTEP] Flash-based SSDs</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf">OSTEP] File system implementation</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-ffs.pdf">OSTEP] Locality and the FFS</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-journaling.pdf">OSTEP] Crash consistency: fsck and journaling</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-lfs.pdf">OSTEP]: Log-structured File Systems</a></p><p><a href="https://www.usenix.org/conference/fast22/presentation/li">ctFS paper at FAST'22 conference</a></p></blockquote><h2 id="hard-disk-drives"><a class="markdownIt-Anchor" href="#hard-disk-drives"></a> Hard Disk Drives</h2><h3 id="disk-basics"><a class="markdownIt-Anchor" href="#disk-basics"></a> Disk Basics</h3><p>A complete I/O:</p><p>First a <strong>seek</strong>, then waiting for the <strong>rotational delay</strong>, and finally the <strong>transfer</strong>(read/write).</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub><mo>=</mo><msub><mi>T</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>k</mi></mrow></msub><mo>+</mo><msub><mi>T</mi><mrow><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>+</mo><msub><mi>T</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{I/O} = T_{seek} + T_{rotation} + T_{transfer}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi><mo stretchy="false">(</mo><msub><mi>R</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub><mo stretchy="false">)</mo><mo>:</mo><msub><mi>R</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>S</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mrow><mi>T</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><msub><mi>T</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">the\ rate\ of\ I/O (R_{I/O}): R_{I/O} = \frac{Size_{Transfer}}{T_{I/O}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.5950509999999998em;vertical-align:-0.60364em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9914109999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3694857142857143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.51308em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.60364em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><img src="../imgs/202412301442334-1740072306166-1.png" alt="" style="zoom:80%;" /><h3 id="disk-scheduling"><a class="markdownIt-Anchor" href="#disk-scheduling"></a> Disk Scheduling</h3><ol><li>SSTF: Shortest Seek Time First</li></ol><blockquote><p>How can we implement SSTF-like scheduling but avoid starvation?</p></blockquote><ol start="2"><li>Elevator (a.k.a. SCAN or C-SCAN)</li></ol><blockquote><p>How can we implement an algorithm that more closely approximates SJF by taking both seek and rotation into account?</p></blockquote><ol start="3"><li>SPTF: Shortest Positioning Time First</li></ol><h3 id="linux-io-schedulers"><a class="markdownIt-Anchor" href="#linux-io-schedulers"></a> Linux I/O Schedulers(*)</h3><h4 id="goals-of-io-schedulers"><a class="markdownIt-Anchor" href="#goals-of-io-schedulers"></a> Goals of I/O schedulers</h4><ul><li>Minimize disk seeks</li><li>Ensure optimum disk performance</li><li>Provide fairness among I/O requests</li></ul><p>Balancing these goals or trading them against one another is the essence of the art of creating an I/O scheduler.</p><h4 id="four-schedulers-in-linux"><a class="markdownIt-Anchor" href="#four-schedulers-in-linux"></a> Four schedulers in Linux</h4><ul><li>NOOP</li></ul><p><strong>All incoming I/O requests</strong> for all processes running on the system, regardless of the I/O request (e.g., read, write, lseek, etc.), go into a simple <strong>first in, first out (FIFO) queue</strong>. The scheduler also does <strong>request merging</strong> to reduce seek time and improve throughput.</p><p>NOOP scheduler does not make any attempts to reduce seek time. Therefore, storage devices that have very little seek time benefit from a NOOP I/O scheduler.</p><ul><li>Anticipatory</li></ul><p>It <strong>anticipates</strong> subsequent block requests and implements <strong>request merging</strong>, a <strong>one-way elevator</strong>, and read and write <strong>request batching</strong>.</p><p>After the scheduler services an I/O request, it pauses slightly to see if the next request is for the subsequent block.</p><p>A <strong>web server</strong> can achieve better performance while <strong>database run</strong> can suffer from a slowdown with anticipatory I/O scheduling.</p><ul><li>Deadline</li></ul><p>Maintain two <strong>deadline queues</strong> in addition to the <strong>sorted queues</strong> for reads and writes.</p><p>Sorted queues are sorted according to their sector numbers(the <strong>elevator</strong> approach).</p><p>Queues for reads are prioritized. If the first request in the deadline queue is expired, execute it immediately; otherwise, the scheduler serves a batch of requests from the sorted queue.</p><p>Useful for <strong>real-time applications</strong> as it keeps latency low, and for <strong>database systems that have <a href="http://en.wikipedia.org/wiki/Tagged_Command_Queuing">TCQ</a>-aware disks</strong> (the hardware makes I/O scheduling decisions).</p><ul><li>CFQ</li></ul><p>Default Linux kernel scheduler</p><p>CFQ synchronously puts requests from processes into a number of <strong>per-process queues</strong> then allocates <strong>time slices</strong> for each of the queues to access the disk.</p><h2 id="flash-based-ssds"><a class="markdownIt-Anchor" href="#flash-based-ssds"></a> Flash-based SSDs</h2><h3 id="flash-basics"><a class="markdownIt-Anchor" href="#flash-basics"></a> Flash Basics</h3><img src="../imgs/202412241704745-1740072306166-2.png" alt=""  /><p>Whenever we want to write to a page, we need to <strong>erase</strong> the whole block first.</p><p>Primary concern of flash chips: <strong>wear out</strong>!</p><blockquote><p>What is <strong>wear out</strong>?</p></blockquote><p>When a flash block is erased and programmed, it slowly accrues a little bit of extra charge. Over time, as that extra charge builds up, it becomes increasingly difficult to differentiate between a 0 and a 1. At the point where it becomes impossible, the block becomes unusable.</p><h3 id="from-raw-flash-to-flash-based-ssds"><a class="markdownIt-Anchor" href="#from-raw-flash-to-flash-based-ssds"></a> From Raw Flash to Flash-Based SSDs</h3><img src="../imgs/202412271130946-1740072306166-4.png" alt="" style="zoom:80%;" /><p><strong>FTL</strong>(flash translation layer): FTL turns clients' read and write requests into internal flash operations(low-level read, erase, and program).</p><h3 id="ftl-organization-a-log-structured-ftl"><a class="markdownIt-Anchor" href="#ftl-organization-a-log-structured-ftl"></a> FTL Organization: A Log-Structured FTL</h3><blockquote><p>How to translate logical block(issued by the client) into physical page(on the actual SSD device)?</p></blockquote><p>FTL maintains a in-memory mapping table.</p><div class="note note-primary">            <blockquote><p>What happens when the client(file system) writes a page to the SSD?</p></blockquote><p>When the client writes to the SSD, The SSD picks the <strong>next free page</strong> and programs the page with the block's contents, and records the <strong>logical-to-physical mapping</strong> in its mapping table.</p>          </div><h3 id="three-major-problems-with-log-structured-ftl"><a class="markdownIt-Anchor" href="#three-major-problems-with-log-structured-ftl"></a> Three major problems with log-structured FTL</h3><ul><li><strong>Cost of Garbage Collection</strong></li></ul><blockquote><p>What happens when we overwrite a page?</p></blockquote><p>Old pages have garbage(old-version data) in them. We need <strong>Garbage Collection</strong>!</p><p>Garbage Collection: Find a block that contains one or more garbage pages, read in the live (non-garbage) pages from that block, write out those live pages to the log, and (finally) reclaim the entire block for use in writing</p><ul><li><strong>Large size of the mapping table</strong></li></ul><blockquote><p>What if we have a very large mapping table?</p></blockquote><ol><li><p><strong>Hybrid Mapping</strong>(log-based + block-based mapping): Maintain a <strong>log table</strong>(a pointer per page) and a <strong>data table</strong>(a pointer per block)</p></li><li><p>Page Mapping Plus <strong>Caching</strong>: Caching hot pieces of the FTL</p></li></ol><ul><li><strong>Wear Leveling</strong></li></ul><blockquote><p>How to balance the erase/program loads among physical blocks of the flash chip so that all blocks wear out roughly at the same time?</p></blockquote><p>The FTL occasionally migrate data from blocks that are mostly read(seldom overwritten) in order to ensure said blocks receive their share of the erase/program load.</p><h2 id="file-system-implementation"><a class="markdownIt-Anchor" href="#file-system-implementation"></a> File System Implementation</h2><h3 id="introduction-to-file-systems"><a class="markdownIt-Anchor" href="#introduction-to-file-systems"></a> Introduction to file systems</h3><p><code>vnode</code> is the internal structure that describes the file.</p><p>The key part of defining a file system is to design the data structure that <strong>maps from an abstract notion of a file to a collection of disk blocks</strong>.</p><img src="../imgs/202412221745667-1740072306166-3.png" style="zoom: 67%;" /><p>File structure:</p><img src="../imgs/202412222134213-1740072306166-7.png" alt="" style="zoom: 50%;" /><h3 id="inode-structure"><a class="markdownIt-Anchor" href="#inode-structure"></a> <code>Inode</code> Structure</h3><img src="../imgs/202501012352680-1740072306166-5.png" alt="" style="zoom:67%;" /><center>The Inode Table</center><p><strong>The Multi-Level Index File System</strong>:</p><p>The <code>inode</code> contains some <strong>direct pointers</strong> pointing to data blocks, and also contains some <strong>indirect pointers</strong> pointing to <strong>indirect blocks</strong>, in which the pointers point to data blocks.</p><h3 id="directory"><a class="markdownIt-Anchor" href="#directory"></a> Directory</h3><img src="../imgs/202412241037406-1740072306166-6.png" alt="" style="zoom:80%;" /><p>Directory is just a special type of file that stores <code>name→inode-number</code> mappings. Thus, a directory has an <code>inode</code>, somewhere in the <code>inode</code> table.</p><p>Root directory has a designated <code>inode</code> number(2).</p><h2 id="locality-and-the-fast-file-system"><a class="markdownIt-Anchor" href="#locality-and-the-fast-file-system"></a> Locality and The Fast File System</h2><p>Data structures of the old file system(really simple!):</p><img src="../imgs/202412301450351-1740072306166-8.png" alt="" style="zoom:67%;" /><p>However, the old file system has pretty bad performance, so the crux of our problem:</p><blockquote><p>How can we organize on-disk data to improve performance?</p></blockquote><h3 id="ffs-disk-awareness"><a class="markdownIt-Anchor" href="#ffs-disk-awareness"></a> FFS: Disk Awareness</h3><p>FFS divides the disk into a number of <strong>cylinder groups</strong>.</p><img src="../imgs/202412301505303-1740072306166-12.png" alt="" style="zoom:80%;" /><p>However, modern drives do not export their geometry information to the file system. Disks only export a <strong>logical address space of blocks</strong>. Therefore, modern file systems instead organize the drive into <strong>block groups</strong>.</p><img src="../imgs/202412301539892-1740072306166-9.png" alt="" style="zoom:80%;" /><p>Accessing files within the same group won't result in long seeks across the disk.</p><p>FFS includes <strong>all the structures</strong> you might expect a file system to have <strong>within each group</strong>.</p><img src="../imgs/202412301542707-1740072306166-10.png" alt="" style="zoom:80%;" /><center>A single cylinder group</center><h3 id="ffs-policies"><a class="markdownIt-Anchor" href="#ffs-policies"></a> FFS Policies</h3><blockquote><p>Assumptions we make?</p></blockquote><p><strong>File Locality</strong>: We assume that files within the same directory accessed together more often.</p><blockquote><p>How to place directories?</p></blockquote><p>Find the cylinder group with</p><ol><li>a <strong>low number of allocated directories</strong> (to balance directories across groups)</li><li>a <strong>high number of free <code>inodes</code></strong>(to subsequently be able to allocate a bunch of files)</li></ol><blockquote><p>How to place files?</p></blockquote><ol><li>Allocate the data blocks of a file in the same group as its <code>inode</code>.</li><li>Place all files that are in the same directory in the cylinder group of the directory they are in.</li></ol><blockquote><p>What is the large-file exception? Why we should place large files differently?</p></blockquote><p>A large file would entirely fill the block group, which prevents subsequent “related” files from being placed within this block group, hurting file-access locality.</p><p>So our policy is: After some number of blocks are allocated into the first block group(the number of direct pointers available within an <code>inode</code>), FFS places the next “large” chunk of the file(those pointed to by the first indirect block) in another block group, and so on…</p><p><img src="../imgs/202412301622139-1740072306166-11.png" alt="File spread across groups" /></p><h2 id="crash-consistency-fsck-and-journaling"><a class="markdownIt-Anchor" href="#crash-consistency-fsck-and-journaling"></a> Crash Consistency: FSCK and Journaling</h2><p>The crux of our problem:</p><blockquote><p>The system may crash or lose power at any time during disk operations, and thus the on-disk state may only partially get updated. How do we ensure the file system <strong>keeps the on-disk image in a reasonable state</strong>?</p></blockquote><h3 id="solution-1-the-file-system-checker"><a class="markdownIt-Anchor" href="#solution-1-the-file-system-checker"></a> Solution #1: The File System Checker</h3><div class="note note-success">            <p>Let inconsistencies happen and then fix them later (when rebooting).</p><p>By consistency, we mean that the file system <strong>metadata is internally consistent</strong>.</p>          </div><p><code>fsck</code> is a UNIX tool for finding such inconsistencies and repairing them:</p><ul><li><p><strong>Superblock</strong>: Check if the superblock looks suspicious and use an alternate copy of the superblock if it finds a suspect superblock.</p><div class="note note-info">            <p>Recall that each block group has a copy of the superblock.</p>          </div></li><li><p><strong>Free blocks</strong>: Produce a <strong>correct version of the allocation bitmaps</strong> by scanning the <code>inodes</code>, indirect blocks, double indirect blocks, …, to resolve any inconsistency between bitmaps and <code>inodes</code>.</p><div class="note note-info">            <p>For now, we trust the information with the <code>inodes</code>.</p>          </div></li><li><p><strong><code>Inode</code> state</strong>: Check each <code>inode</code>, clear the suspected <code>inode</code> and update the <code>inode</code> bitmap correspondingly.</p><div class="note note-info">            <p>The information within the <code>inodes</code> can be corrupted.</p>          </div></li><li><p><strong><code>Inode</code> links</strong>: Verify the link count of each allocated <code>inode</code>.</p><div class="note note-info">            <p>Recall that the link count indicates the number of different directories that contain a reference (i.e., a link) to this particular file.</p>          </div><div class="note note-primary">            <blockquote><p>Aside: What's the difference between hard link and symbolic link?</p></blockquote><p>Symbolic Link: A symbolic link is a special type of file(like regular files and directories), which stores the path name(string) of the target file. It has its own <code>inode</code>: <code>symlink's inode</code>.</p><p>Hard Link: Different directory's entries point to the same <code>inode</code> and are calculated by link count. Deleting the file will decrease the link count by 1.</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">Symbolic Link:<br><span class="hljs-function"><span class="hljs-title">dir</span> entry -&gt;</span> <span class="hljs-function"><span class="hljs-title">symlink</span>&#x27;s inode -&gt;</span> (存储路径字符串: <span class="hljs-string">&quot;/path/to/target&quot;</span>)<br><br>Hard Link:<br>dir entry <span class="hljs-number">1</span> ──┐<br><span class="hljs-function"><span class="hljs-title">dir</span> entry 2 ──┴─&gt; target&#x27;s inode -&gt;</span> (实际数据)<br></code></pre></td></tr></table></figure>          </div></li><li><p><strong>Duplicates</strong>: Check for duplicated pointers, i.e., cases where two different <code>inodes</code> refer to the same block.</p></li><li><p><strong>Bad blocks</strong>: Check for bad block pointers and remove the pointers from the <code>inode</code> or indirect block.</p></li><li><p><strong>Directory checks</strong>: Check on the contents of each directory.</p></li></ul><p><code>fsck</code> requires <strong>scanning the entire disk</strong>, so the problem of <code>fsck</code> is obvious:</p><p>As disks grew bigger, the performance became prohibitive.</p><h3 id="solution-2-journaling-or-write-ahead-logging"><a class="markdownIt-Anchor" href="#solution-2-journaling-or-write-ahead-logging"></a> Solution #2: Journaling (or Write-Ahead Logging)</h3><p>Basic idea: When updating the disk, before overwriting the structures in place, first write down a <strong>little note</strong> to a structure(somewhere else on the disk, in a well-known location) that we organize as a &quot;log&quot;, describing what you are about to do.</p><h4 id="linux-ext3-a-popular-journaling-file-system"><a class="markdownIt-Anchor" href="#linux-ext3-a-popular-journaling-file-system"></a> Linux ext3: a popular journaling file system</h4><p>An ext2 file system (without journaling):</p><img src="../imgs/202501012027229-1740072306166-13.png" alt="" style="zoom:80%;" /><p>An ext3 file system adds a new key structure: <strong>journal</strong></p><img src="../imgs/202501012028597-1740072306166-14.png" alt="" style="zoom:80%;" /><h4 id="data-journaling"><a class="markdownIt-Anchor" href="#data-journaling"></a> Data journaling</h4><img src="../imgs/202501012238287-1740072306166-15.png" alt="" style="zoom:80%;" /><blockquote><p>What if <code>TxE</code> is successfully written to the log while Db(user data) is not?</p><img src="../imgs/202501012240287-1740072306166-16.png" alt="" style="zoom:80%;" /></blockquote><p>If we write theses five blocks all at once, if the system crash before Db is completely written to disk while <code>TxE</code> has been successfully written to disk. The system will assume that journal write is successful, despite it is not, causing problems.</p><blockquote><p>How to avoid this problem?</p></blockquote><p>The file system issues the transactional write in two steps:</p><ol><li><p>Write all blocks except the <code>TxE</code> block at once to the journal.</p><img src="../imgs/202501012245746-1740072306166-17.png" alt="" style="zoom:80%;" /></li><li><p>When those writes complete, the file system issues the write of the <code>TxE</code> block, thus leaving the journal in this final, safe state:</p><img src="../imgs/202501012246518-1740072306166-21.png" alt="" style="zoom: 80%;" /></li></ol><p><code>TxE</code> should be a single 512-byte block to make the write of <code>TxE</code> atomic(the disk guarantees that any 512-byte write will either happen completely or not at all).</p><p>Some file systems(e.g. Linux ext3) perform <strong>batching log updates</strong> by <strong>buffering</strong> multiple updates into a global transaction <strong>in memory</strong>, reducing write traffic to disk.</p><blockquote><p>What if the log becomes full?</p></blockquote><p>We make the log a <strong>circular log</strong> by freeing the space occupied by checkpointed transactions.</p><p>Mark the oldest and newest non-checkpointed transactions in the log in a <strong>journal superblock</strong>:</p><img src="../imgs/202501012306476-1740072306166-18.png" alt="" style="zoom:80%;" /><p>Our final <strong>data journaling</strong> protocol:</p><ol><li><p><strong>Journal write</strong>: Write the contents of the transaction (including <code>TxB</code>, metadata, and data) to the log; wait for these writes to complete.</p></li><li><p><strong>Journal commit</strong>: Write the <strong>transaction commit block</strong> (containing <code>TxE</code>) to the log; wait for write to complete.</p><p>The transaction is now <strong>committed</strong>.</p></li><li><p><strong>Checkpoint</strong>: Write the contents of the update (metadata and data) to their final on-disk locations.</p></li><li><p><strong>Free</strong>: Some time later, mark the transaction free in the journal by updating the journal superblock.</p></li></ol><blockquote><p>However, we are writing each data block to the disk twice, which is a heavy cost to pay considering system crash is rare. How to improve our protocol?</p></blockquote><h4 id="metadata-journaling"><a class="markdownIt-Anchor" href="#metadata-journaling"></a> Metadata Journaling</h4><p>User data is not written to the log. Instead, they are written to disk first.</p><img src="../imgs/202501012319474-1740072306166-19.png" alt="" style="zoom:80%;" /><p>Our protocol:</p><ol><li><p><strong>Data write</strong>: Write data to final location; wait for completion (the wait is optional).</p></li><li><p><strong>Journal metadata write</strong>: Write the begin block and metadata to the log; wait for writes to complete.</p><div class="note note-danger">            <p><strong>Step 3 should wait for step 1&amp;2 to complete!</strong> Step 1 and Step 2 and run concurrently.</p>          </div></li><li><p><strong>Journal commit</strong>: Write the transaction commit block (containing <code>TxE</code>) to the log; wait for the write to complete.</p><p>The transaction (including data) is now committed.</p></li><li><p><strong>Checkpoint metadata</strong>: Write the contents of the metadata update to their final locations within the file system.</p></li><li><p><strong>Free</strong>: Later, mark the transaction free in journal superblock.</p></li></ol><div class="note note-success">            <p>The rule is: Write the pointed-to object before the object that points to it!</p>          </div><p>Linux ext3 gives you the option of choosing either <strong>data, ordered, or unordered modes</strong> (in unordered mode, data can be written at any time).</p><h2 id="log-structured-file-systems"><a class="markdownIt-Anchor" href="#log-structured-file-systems"></a> Log-structured File Systems</h2><h3 id="write-to-disk-sequentially"><a class="markdownIt-Anchor" href="#write-to-disk-sequentially"></a> Write to disk sequentially</h3><blockquote><p>The crux of the problem:</p><p>How to write to disk sequentially?</p></blockquote><p>Before writing to the disk, LFS keeps track of updates in memory.; when it has received a sufficient number of updates, it writes them to disk all at once.</p><p>An example in which LFS buffers two sets of updates into a small segment:</p><img src="../imgs/202501042359351-1740072306166-20.png" alt="" style="zoom:80%;" /><h3 id="find-inodes"><a class="markdownIt-Anchor" href="#find-inodes"></a> Find <code>Inodes</code></h3><blockquote><p>How to find <code>inodes</code> in LFS?</p></blockquote><div class="note note-info">            <p>Recall in FFS we split up the <code>inode</code> table into chunks and places a group of <code>inodes</code> within each cylinder group. So we need to know the address and size of each <code>inode</code> chunk before calculating the address of an <code>inode</code>.</p>          </div><p>Finding <code>inodes</code> in old Unix file system or FFS is simple because all <code>inodes</code> are placed in a fixed area on disk. You can simply calculate an <code>inode</code>'s location given its <code>inode</code> number. However, in LFS, <code>inodes</code> are all across the disk and we never overwrite any <code>inode</code> so the latest version of an <code>inode</code> keeps moving.</p><p>LFS introduces the <strong><code>inode</code> map (<code>imap</code>)</strong>. The <code>imap</code> is a structure that takes an <code>inode</code> number as input and produces the disk address of the most recent version of the <code>inode</code>.</p><div class="note note-info">            <p>Note that the <code>inode</code> map in LFS is a virtualization of <code>inode</code> numbers.</p>          </div><p>LFS places chunks of the <code>inode</code> map right next to where it is writing all of the other new information to avoid frequent disk seeks:</p><img src="../imgs/202501051545857-1740072306166-22.png" alt="" style="zoom:80%;" /><blockquote><p>Now the question is:</p><p>How do we find the <code>inode</code> map, considering now that pieces of it are also now spread across the disk?</p></blockquote><p>LFS has a fixed place on disk, known as the <strong>checkpoint region (CR)</strong>, containing pointers to the latest pieces of the <code>inode</code> map.</p><img src="../imgs/image-20250105155149962-1740072306166-23.png" alt="" style="zoom:80%;" /><p>The entire <code>imap</code> is usually cached in memory, so the extra work LFS does during a read is to look up the <code>inode</code>’s address in the <code>imap</code>.</p><div class="note note-info">            <p>The <code>imap</code> also solves the <strong>recursive update problem</strong>. While an <code>inode</code> keeps moving across the disk, its <code>inode</code> number remains unchanged. Only the <code>imap</code> structure is updated while the directory holds the same <code>name-to-inode-number</code> mapping.</p>          </div><h3 id="garbage-collection"><a class="markdownIt-Anchor" href="#garbage-collection"></a> Garbage Collection</h3><blockquote><p>How to collect garbage in LFS?</p></blockquote><p>Note that LFS always writes the latest version of a file to new locations on disk, leaving old versions of file structures(<strong>garbage</strong>) scattered throughout the disk.</p><p>LFS periodically find these old dead versions of file data, <code>inodes</code>, and other structures, and clean them.</p><p>The LFS cleaner works on a segment-by-segment basis so that subsequent writing can find large contiguous chunks of space. Specifically, we expect the cleaner to read in M existing segments, compact their contents into N new segments (where N &lt; M), and then write the N segments to disk in new locations.</p><blockquote><p>So our problem now is:</p><ol><li>How can LFS tell which blocks within a segment are live, and which are dead?</li><li>How often should the cleaner run, and which segments should it pick to clean?</li></ol></blockquote><p>LFS stores a little extra information(for each data block D, its <code>inode</code> number and its offset) that describes each block in a structure at the head of the segment, known as the <strong>segment summary block</strong>.</p><p>Determine whether a block is live or dead:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">// N is the inode number<br>// T is the offset<br>(N, T) = SegmentSummary[A];<br>inode = Read(imap[N]);<br>if (inode[T] == A)<br>// block D is alive<br>else<br>// block D is garbage<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>File System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Top-Down Approach Studying Notes</title>
    <link href="/2024/12/16/Top-down-approach/"/>
    <url>/2024/12/16/Top-down-approach/</url>
    
    <content type="html"><![CDATA[<p>A Top-Down Approach is a classic textbook in the field of computer networking. Hope this studying note can help you get the key points when you read the textbook!</p><h2 id="chapter-1-what-is-the-internet"><a class="markdownIt-Anchor" href="#chapter-1-what-is-the-internet"></a> Chapter 1 - What is the Internet?</h2><h3 id="a-nuts-and-bolts-description"><a class="markdownIt-Anchor" href="#a-nuts-and-bolts-description"></a> A Nuts-and-Bolts Description</h3><h4 id="basic-concepts"><a class="markdownIt-Anchor" href="#basic-concepts"></a> basic concepts</h4><p>Devices connected to the Internet: <strong>hosts</strong> or <strong>end system</strong></p><p>End systems are connected together by a network of <strong>communication links</strong> and <strong>packet switches</strong>.</p><hr /><h4 id="communication-links"><a class="markdownIt-Anchor" href="#communication-links"></a> communication links</h4><p>Made up of different types of physical media</p><p>Different links have different <strong>transmission rate</strong>, measured in bits/seconds</p><p>When one end system has data to send to another end system, the sending end system segments the data and adds header bytes to each segment. The resulting packages of information, known as <strong>packets</strong>, are then sent through the network to the destination end system, where they are reassembled into the original data</p><hr /><h4 id="packet-switch"><a class="markdownIt-Anchor" href="#packet-switch"></a> packet switch</h4><p>Takes a packet arriving on one of its incoming communication links and forwards that packet on one of its outgoing communication links</p><ul><li><strong>routers</strong></li></ul><blockquote><p>used in the network core</p></blockquote><ul><li><strong>link-layer switches</strong></li></ul><blockquote><p>used in access networks</p></blockquote><p>The sequence of communication links and packet switches traversed by a packet from the sending end system to the receiving end system is known as a <strong>route</strong> or <strong>path</strong> through the network.</p><hr /><h4 id="protocols"><a class="markdownIt-Anchor" href="#protocols"></a> Protocols</h4><p>End systems, packet switches, and other pieces of the Internet run protocols that control the sending and receiving of information within the Internet.</p><ul><li><p>TCP(Transmission Control Protocol)</p></li><li><p>Internet Protocol (IP)</p></li></ul><blockquote><p>specifies the format of packets</p></blockquote><ul><li>TCP/IP</li></ul><h3 id="a-services-description"><a class="markdownIt-Anchor" href="#a-services-description"></a> A services Description</h3><h4 id="definition"><a class="markdownIt-Anchor" href="#definition"></a> Definition</h4><p>The Internet is an infrastructure that provides services to <strong>distributed applications</strong>.</p><hr /><h4 id="socket-interface"><a class="markdownIt-Anchor" href="#socket-interface"></a> socket interface</h4><p>Socket interface is a set of rules that the sending program must follow so that the data can be delivered to destination program.</p><h3 id="what-is-a-protocol"><a class="markdownIt-Anchor" href="#what-is-a-protocol"></a> What is a Protocol?</h3><h4 id="a-human-analogy"><a class="markdownIt-Anchor" href="#a-human-analogy"></a> A Human Analogy</h4><img src="../imgs/202412271816523.png" alt="" style="zoom: 33%;" /><hr /><h4 id="network-protocols"><a class="markdownIt-Anchor" href="#network-protocols"></a> Network Protocols</h4><p>A protocol defines the <strong>format</strong> and the <strong>order</strong> of messages exchanged between two or more communicating entities, as well as the <strong>actions</strong> taken on the transmission and/or receipt of a message or other event.</p><h2 id="the-network-edge"><a class="markdownIt-Anchor" href="#the-network-edge"></a> The Network Edge</h2><img src="../imgs/202412271820546.png" alt="" style="zoom:50%;" /><p>hosts:</p><ul><li>clients</li></ul><p>desktops, laptops, smartphones…</p><ul><li>servers</li></ul><p>powerful machines that store and distribute Web pages, stream video, relay e-mail…</p><p><strong>in large data centers</strong></p><h3 id="access-networks"><a class="markdownIt-Anchor" href="#access-networks"></a> Access Networks</h3><h4 id="home-access"><a class="markdownIt-Anchor" href="#home-access"></a> Home Access</h4><h5 id="dsl-internet-access"><a class="markdownIt-Anchor" href="#dsl-internet-access"></a> DSL Internet access</h5><img src="../imgs/202409041120064.png" alt="" style="zoom:50%;" /><ul><li>DSL modem</li></ul><p>Translate between digital data and high-frequency tones.</p><p>Data and telephone signals are encoded at different frequencies.</p><ul><li>DSLAM</li></ul><p>On the telco side, DSLAM separates the data and phone signals and sends the data into the Internet.</p><ul><li>Splitter</li></ul><p>On the customer side, a splitter separates the data and telephone signals arriving to the home and forwards the data signal to the DSL modem.</p><p>Asymmetric: downstream transmission rate is larger than upstream transmission rate</p><hr /><h5 id="cable-internet-access"><a class="markdownIt-Anchor" href="#cable-internet-access"></a> cable Internet access</h5><img src="../imgs/202409041318239.png" style="zoom:50%;" /><img src="../imgs/202409041509538.png" alt="" style="zoom:50%;" /><img src="../imgs/202409041510599.png" alt="" style="zoom:50%;" /><p>Frequency division multiplexing(FDM): different channels transmitted in different frequency bands</p><p>Asymmetric: downstream transmission rate is larger than upstream transmission rate</p><p>CMTS‘s function is similar to DSLAM</p><hr /><h5 id="fiber-to-the-home-ftth"><a class="markdownIt-Anchor" href="#fiber-to-the-home-ftth"></a> fiber to the home (FTTH)</h5><p>even faster!</p><p>provide an optical fiber path from the CO directly to the home</p><p>FTTH using the PON distribution architecture (passive optical networks):</p><img src="../imgs/202409041339786.png" alt="" style="zoom:50%;" /><p>packets sent from OLT are replicated at the splitter (similar to a cable head end)</p><hr /><h5 id="5g-fixed-wireless"><a class="markdownIt-Anchor" href="#5g-fixed-wireless"></a> 5G fixed wireless</h5><p>without installing costly and failure-prone cabling</p><h4 id="access-in-the-enterprise-and-the-home-ethernet-and-wifi"><a class="markdownIt-Anchor" href="#access-in-the-enterprise-and-the-home-ethernet-and-wifi"></a> Access in the Enterprise (and the Home): Ethernet and WiFi</h4><hr /><ul><li><p>Home Network</p><img src="../imgs/202409041558726.png" style="zoom:50%;" /></li></ul><h4 id="wide-area-wireless-access-3g-and-lte-4g-and-5g"><a class="markdownIt-Anchor" href="#wide-area-wireless-access-3g-and-lte-4g-and-5g"></a> Wide-Area Wireless Access: 3G and LTE 4G and 5G</h4><p>Employ the same wireless infrastructure used for cellular telephony to send/receive packets through a base station that is operated by the cellular network provider.</p><h3 id="physical-media"><a class="markdownIt-Anchor" href="#physical-media"></a> Physical Media</h3><p>guided media / unguided media.</p><ul><li>Twisted-Pair Copper Wire</li></ul><p>Twisted pair is the dominant solution for high-speed LAN networking</p><ul><li>Coaxial Cable</li></ul><p>Coaxial cable can be used as a guided shared medium</p><ul><li><p>Fiber Optics</p></li><li><p>Terrestrial Radio Channels</p></li></ul><p>Require no physical wire to be installed, can penetrate walls, provide connectivity to a mobile user, and can potentially carry a signal for long distances.</p><ul><li>Satellite Radio Channels</li></ul><h2 id="the-network-core"><a class="markdownIt-Anchor" href="#the-network-core"></a> The Network Core</h2><h3 id="packet-switching"><a class="markdownIt-Anchor" href="#packet-switching"></a> Packet Switching</h3><p>R: transmission rate (bps)</p><p>L: length of a packet</p><p><strong>transmission delay</strong>:</p><img src="../imgs/202409121311655.png" alt="" style="zoom:50%;" /><h4 id="store-and-forward-transmission"><a class="markdownIt-Anchor" href="#store-and-forward-transmission"></a> Store-and Forward Transmission</h4><p>it takes 2L/R(time) for a packet to be sent from Source to Destination</p><p>it takes 4L/R(time) for all three packets to be sent from Source to Destination</p><img src="../imgs/202409121419327.png" alt="" style="zoom: 67%;" /><p>More general form: N links each of rate R</p><p><strong>end-to-end delay</strong>:</p><p><img src="../imgs/202409121426382.png" alt="end-to-end delay" /></p><h4 id="queuing-delays-and-packet-loss"><a class="markdownIt-Anchor" href="#queuing-delays-and-packet-loss"></a> Queuing Delays and Packet Loss</h4><p><strong>output buffer</strong> (<strong>output queue</strong>): the arriving packet <strong>wait</strong> here</p><p>result in output buffer <strong>queuing delays</strong></p><p>if the output buffer is full, <strong>packet loss</strong> occurs</p><img src="../imgs/202409121445872.png" alt="" style="zoom:67%;" /><h4 id="forwarding-tables-and-routing-protocols"><a class="markdownIt-Anchor" href="#forwarding-tables-and-routing-protocols"></a> Forwarding Tables and Routing Protocols</h4><blockquote><p>How do forwarding tables get set?</p></blockquote><p>The Internet has a number of special <strong>routing protocols</strong> that are used to <strong>automatically</strong> set the forwarding tables</p><h3 id="circuit-switching"><a class="markdownIt-Anchor" href="#circuit-switching"></a> Circuit Switching</h3><p>When two hosts want to communicate, the network establishes <strong>a dedicated end-to-end connection.</strong></p><blockquote><p>Why is circuit switching less efficient than packet switching?</p></blockquote><p>Circuit switching pre-allocates use of the transmission link  regardless of demand, with allocated but unneeded link time going unused</p><p>Packet switching allocates link use on demand</p><img src="../imgs/202409221640398.png" alt="" style="zoom:50%;" /><h3 id="internet-is-a-network-of-networks"><a class="markdownIt-Anchor" href="#internet-is-a-network-of-networks"></a> Internet is a &quot;network of networks&quot;!</h3><p>Interconnection of ISPs:</p><img src="../imgs/202409221614053.png" alt="" style="zoom: 25%;" /><h2 id="delay-loss-and-throughput-in-packet-switched-networks"><a class="markdownIt-Anchor" href="#delay-loss-and-throughput-in-packet-switched-networks"></a> Delay, Loss, and Throughput in Packet-Switched Networks</h2><p><strong>Four delays:</strong></p><ul><li>transmission delay: time to <strong>push</strong> the entire packet onto the link</li><li>processing delay</li><li>propagation delay</li><li>queueing delay -&gt; congestion and packet loss</li></ul><p><img src="../imgs/image-20250220011638924.png" alt="Four network delays" /></p><p><strong>Throughput:</strong></p><p>analogy to pipes</p><p>rate(bits/time unit) at which bits are being sent from sender to receiver</p><img src="../imgs/202409221937913.png" alt="" style="zoom:25%;" /><h2 id="layering-encapsulation-service-models"><a class="markdownIt-Anchor" href="#layering-encapsulation-service-models"></a> Layering, encapsulation, service models</h2><p>Layering and encapsulation:</p><img src="../imgs/202409222317594.png" alt="" style="zoom: 33%;" /><p>The switches and routers only implement the lower layer of the protocol stack:</p><img src="../imgs/202409222320192.png" alt="" style="zoom: 33%;" /><h1 id="chapter-2-application-layer"><a class="markdownIt-Anchor" href="#chapter-2-application-layer"></a> Chapter 2 - Application Layer</h1><h2 id="21-principles-of-network-applications"><a class="markdownIt-Anchor" href="#21-principles-of-network-applications"></a> 2.1 Principles of Network Applications</h2><h3 id="network-application-architectures"><a class="markdownIt-Anchor" href="#network-application-architectures"></a> Network Application Architectures</h3><ul><li>client-server architecture</li><li>peer-to-peer (P2P) architecture</li></ul><hr /><h3 id="processes-communicating"><a class="markdownIt-Anchor" href="#processes-communicating"></a> Processes Communicating</h3><div class="note note-primary">            <p><strong>Processes</strong> on two different end systems communicate with each other by  <strong>exchanging messages</strong> across the computer network.</p>          </div><h4 id="the-interface-between-the-process-and-the-computer-network"><a class="markdownIt-Anchor" href="#the-interface-between-the-process-and-the-computer-network"></a> The <strong>Interface</strong> Between the Process and the Computer Network</h4><p>A process sends messages into, and receives messages from, the network through a <strong>software interface</strong> called a <strong>socket</strong>.</p><img src="../imgs/202410081900220.png" alt="" style="zoom:80%;" /><h4 id="transport-services-available-to-applications"><a class="markdownIt-Anchor" href="#transport-services-available-to-applications"></a> Transport Services Available to Applications</h4><p>reliable data transfer, throughput, timing, and security</p><h4 id="transport-services-provided-by-the-internettcpip-networks"><a class="markdownIt-Anchor" href="#transport-services-provided-by-the-internettcpip-networks"></a> Transport Services Provided by the Internet(TCP/IP networks)</h4><ul><li><strong>TCP Services</strong></li></ul><p>Connection-oriented Service(handshaking)</p><p>Reliable data transfer</p><p>congestion-control mechanism</p><blockquote><p><em>TCP congestion control attempts to limit each TCP connection to its fair share of network bandwidth.</em></p></blockquote><ul><li><strong>UDP Services</strong></li></ul><hr /><h3 id="application-layer-protocols"><a class="markdownIt-Anchor" href="#application-layer-protocols"></a> Application-Layer Protocols</h3><div class="note note-primary">            <p>An <strong>application-layer protocol</strong> defines <strong>how an application’s processes</strong>, running on different end systems,  <strong>pass messages to each other</strong>.</p>          </div><p>The Web’s application-layer protocol, <strong>HTTP</strong>, defines the <strong>format and sequence of messages</strong> exchanged between browser and Web server.</p><h2 id="22-the-web-and-http"><a class="markdownIt-Anchor" href="#22-the-web-and-http"></a> 2.2 The Web and HTTP</h2><h3 id="http-message-format"><a class="markdownIt-Anchor" href="#http-message-format"></a> HTTP Message Format</h3><h4 id="http-request-message"><a class="markdownIt-Anchor" href="#http-request-message"></a> HTTP Request Message</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/somedir/page.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.someschool.edu<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">User-agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0<br><span class="hljs-attribute">Accept-language</span><span class="hljs-punctuation">: </span>fr<br></code></pre></td></tr></table></figure><p>The first line of an HTTP request message is called the <strong>request line</strong>; the  subsequent lines are called the <strong>header lines</strong>.</p><p><strong>General format:</strong></p><img src="../imgs/202410101654780.png" alt="" style="zoom: 67%;" /><p>If the value of the method field is POST, then the <strong>entity body</strong> contains what the user entered into the form fields.(e.g. when a  user provides search words to a search engine)</p><h4 id="http-response-message"><a class="markdownIt-Anchor" href="#http-response-message"></a> HTTP Response Message</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 18 Aug 2015 15:44:04 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.2.3 (CentOS)<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 18 Aug 2015 15:11:03 GMT<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>6821<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br>(data data data data data ...)<br></code></pre></td></tr></table></figure><p><strong>General Format:</strong></p><img src="../imgs/202410101710955.png" alt="" /><hr /><h3 id="cookies"><a class="markdownIt-Anchor" href="#cookies"></a> Cookies</h3><p>Cookies allow sites to keep track of users.</p><img src="../imgs/202410101743505.png" alt="" style="zoom:80%;" /><hr /><h3 id="web-caching"><a class="markdownIt-Anchor" href="#web-caching"></a> Web Caching</h3><h4 id="web-caching-2"><a class="markdownIt-Anchor" href="#web-caching-2"></a> Web caching</h4><img src="../imgs/202410151249513.png" alt="" style="zoom:80%;" /><h4 id="conditional-get"><a class="markdownIt-Anchor" href="#conditional-get"></a> Conditional GET</h4><img src="../imgs/202410151358041.png" alt="" style="zoom:80%;" /><hr /><h3 id="http2"><a class="markdownIt-Anchor" href="#http2"></a> HTTP/2</h3><ul><li>Framing</li></ul><p>The ability to <strong>break down an HTTP message into independent frames</strong>, <strong>interleave</strong> them, and then <strong>reassemble</strong> them on the other end is the single most important  enhancement of HTTP/2.</p><ul><li>Message Prioritization</li><li>Server Pushing</li></ul><h2 id="23-email"><a class="markdownIt-Anchor" href="#23-email"></a> 2.3 Email</h2><img src="../imgs/202410151542590.png" alt="" style="zoom:80%;" /><h2 id="24-the-domain-name-system-dns"><a class="markdownIt-Anchor" href="#24-the-domain-name-system-dns"></a> 2.4 The Domain Name System: DNS</h2><p><strong>DNS is a distributed, hierarchical database.</strong></p><img src="../imgs/202410151558437.png" alt="" style="zoom: 80%;" /><h2 id="25-peer-to-peer-file-distribution"><a class="markdownIt-Anchor" href="#25-peer-to-peer-file-distribution"></a> 2.5 Peer-to-Peer File Distribution</h2><img src="../imgs/202410241418563.png" alt="" style="zoom: 67%;" /><h2 id="26-video-streaming-and-content-distribution-networks"><a class="markdownIt-Anchor" href="#26-video-streaming-and-content-distribution-networks"></a> 2.6 Video Streaming and Content Distribution Networks</h2><p>DNS redirects a user’s request to a CDN server:</p><img src="../imgs/202410241515469.png" alt="" style="zoom:60%;" /><h2 id="27-socket-programming-with-udp-and-tcp"><a class="markdownIt-Anchor" href="#27-socket-programming-with-udp-and-tcp"></a> 2.7 Socket programming with UDP and TCP</h2><p>UDP client:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>serverName = <span class="hljs-string">&#x27;hostname&#x27;</span><br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># create UDP socket for server</span><br>clientSocket = socket(AF_INET, SOCK_DGRAM)<br>message = raw_input(<span class="hljs-string">&#x27;Input lowercase sentence:&#x27;</span>)<br>clientSocket.sendto(message.encode(), (serverName, serverPort))<br>modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="hljs-number">2048</span>)<br><span class="hljs-built_in">print</span> modifiedMessage.decode()<br>clientSocket.close()<br></code></pre></td></tr></table></figure><p>UDP server:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>serverPort = <span class="hljs-number">12000</span><br>serverSocket = socket(AF_INET, SOCK_DGRAM)<br><span class="hljs-comment"># bind socket to local port number 12000</span><br>serverSocket.bind((<span class="hljs-string">&#x27;&#x27;</span>, serverPort))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The server is ready to receive&quot;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    message, clientAddress = serverSocket.recvfrom(<span class="hljs-number">2048</span>)<br>    modifiedMessage = message.decode().upper()<br>    serverSocket.sendto(modifiedMessage.encode(), clientAddress)<br></code></pre></td></tr></table></figure><p>TCP client:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>serverName = <span class="hljs-string">&#x27;hostname&#x27;</span><br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># create TCP socket for server</span><br>clientSocket = socket(AF_INET, SOCK_STREAM)<br>clientSocket.connect((serverName, serverPort))<br>sentence = raw_input(<span class="hljs-string">&#x27;Input lowercase sentence:&#x27;</span>)<br>clientSocket.send(sentence.encode())<br>modifiedSentence = clientSocket.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span> modifiedSentence.decode()<br>clientSocket.close()<br></code></pre></td></tr></table></figure><p>TCP server:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>serverPort = <span class="hljs-number">12000</span><br>serverSocket = socket(AF_INET, SOCK_STREAM)<br><span class="hljs-comment"># bind socket to local port number 12000</span><br>serverSocket.bind((<span class="hljs-string">&#x27;&#x27;</span>, serverPort))<br>serverSocket.listen(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The server is ready to receive&quot;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    connectionSocket, addr = serverSocket.accept()<br><br>    sentence = connectionSocket.recv(<span class="hljs-number">1024</span>).decode()<br>    capitalizedSentence = sentence.upper()<br>    connectionSocket.send(capitalizedSentence.encode())<br><br>    connectionSocket.close()<br></code></pre></td></tr></table></figure><h1 id="chapter-3-transport-layer"><a class="markdownIt-Anchor" href="#chapter-3-transport-layer"></a> Chapter 3 – Transport Layer</h1><h2 id="31-introduction-and-transport-layer-services"><a class="markdownIt-Anchor" href="#31-introduction-and-transport-layer-services"></a> 3.1 Introduction and Transport-Layer Services</h2><p>UDP services:</p><ul><li>process-to-process data delivery(multiplexing and demultiplexing)</li><li>error checking</li></ul><p>TCP additional services:</p><ul><li><p>reliable data transfer</p></li><li><p>congestion control</p></li></ul><h2 id="32-multiplexing-and-demultiplexing"><a class="markdownIt-Anchor" href="#32-multiplexing-and-demultiplexing"></a> 3.2 Multiplexing and Demultiplexing</h2><p>The transport layer in the receiving host delivers data to an intermediary socket.</p><p>The job of delivering the data in a transport-layer segment to the correct socket is  called <strong>demultiplexing</strong>.</p><p>The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information to create segments, and passing the segments to the network layer is called <strong>multiplexing</strong>.</p><img src="../imgs/202411191030099.png" alt="" style="zoom:80%;" /><h3 id="connectionlessconnection-oriented-multiplexing-and-demultiplexing"><a class="markdownIt-Anchor" href="#connectionlessconnection-oriented-multiplexing-and-demultiplexing"></a> Connectionless/connection-Oriented Multiplexing and Demultiplexing</h3><p>A UDP socket is fully identified by a two-tuple consisting of a destination IP address and a destination port number.</p><p>A TCP socket is identified by a four-tuple:  (source IP address, source port number, destination IP address, destination port number)</p><img src="../imgs/202411191113061.png" alt="" style="zoom:80%;" /><h2 id="33-connectionless-transport-udp"><a class="markdownIt-Anchor" href="#33-connectionless-transport-udp"></a> 3.3 Connectionless Transport: UDP</h2><blockquote><p>Why UDP over TCP?</p></blockquote><ul><li>Finer application-level control over what data is sent, and when.</li><li>No connection establishment.</li><li>No connection state.</li><li>Small packet header overhead.</li></ul><p>DNS: Use UDP to avoid TCP's connection-establishment delays.</p><p>Multimedia applications: tolerate packet loss</p><img src="../imgs/202411191555431.png" alt=""  /><h2 id="34-principles-of-reliable-data-transfer"><a class="markdownIt-Anchor" href="#34-principles-of-reliable-data-transfer"></a> 3.4 Principles of Reliable Data Transfer</h2><h3 id="reliable-data-transfer-over-a-perfectly-reliable-channel-rdt10"><a class="markdownIt-Anchor" href="#reliable-data-transfer-over-a-perfectly-reliable-channel-rdt10"></a> Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0</h3><img src="../imgs/202411191623033.png" alt="" style="zoom:80%;" /><h3 id="reliable-data-transfer-over-a-channel-with-bit-errors-rdt20"><a class="markdownIt-Anchor" href="#reliable-data-transfer-over-a-channel-with-bit-errors-rdt20"></a> Reliable Data Transfer over a Channel with Bit Errors: rdt2.0</h3><p><strong>stop-and-wait</strong> protocols:</p><img src="../imgs/202411191633671.png" alt="" style="zoom:80%;" /><p>Introduce a <strong>sequence number</strong> field:</p><img src="../imgs/202411191642109.png" alt="" style="zoom:80%;" /><img src="../imgs/202411191644823.png" alt="" style="zoom:80%;" /><h3 id="reliable-data-transfer-over-a-lossy-channel-with-bit-errors-rdt30"><a class="markdownIt-Anchor" href="#reliable-data-transfer-over-a-lossy-channel-with-bit-errors-rdt30"></a> Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0</h3><p>Deal with packet loss:</p><img src="../imgs/202411191654536.png" alt="" style="zoom:80%;" /><h3 id="go-back-n-gbn-protocol"><a class="markdownIt-Anchor" href="#go-back-n-gbn-protocol"></a> Go-Back-N (GBN) protocol</h3><p><strong>sliding-window protocol</strong>:</p><img src="../imgs/202411191708285.png" alt="" style="zoom:80%;" /><img src="../imgs/202411191836312.png" alt=""  /><p>If a timeout occurs, the sender resends <strong>all packets</strong>(<strong>base ~ nextseqnum - 1</strong>) that have been previously sent but that have not yet been acknowledged.</p><p>The receiver discards out-of-order packets instead of buffering them.</p><p>For the case of a window size of 4 packets:</p><img src="../imgs/202411191846881.png" alt="" style="zoom:80%;" /><h3 id="selective-repeat-sr-protocol"><a class="markdownIt-Anchor" href="#selective-repeat-sr-protocol"></a> Selective Repeat (SR) protocol</h3><blockquote><p>Problems of GBN protocol?</p></blockquote><p>When the window size is big and as the probability of channel errors increases, the pipeline can become filled with unnecessary retransmissions.</p><h2 id="35-connection-oriented-transport-tcp"><a class="markdownIt-Anchor" href="#35-connection-oriented-transport-tcp"></a> 3.5 Connection-Oriented Transport: TCP</h2><blockquote><p>What is MSS(Maximum Segment Size)?</p></blockquote><p>The maximum amount of application-layer  data in each segment, not the maximum size of the TCP segment including headers.</p><img src="../imgs/202411211025980.png" alt="" style="zoom: 60%;" /><h3 id="tcp-segment-structure"><a class="markdownIt-Anchor" href="#tcp-segment-structure"></a> TCP segment structure</h3><img src="../imgs/202411211056470.png" alt="" style="zoom: 80%;" /><p>The acknowledgment number is the sequence number of the next byte of data that the host is waiting for.</p><h3 id="tcp-flow-control"><a class="markdownIt-Anchor" href="#tcp-flow-control"></a> TCP flow control</h3><p>The sender maintains: LastByteSent – LastByteAcked &lt;= rwnd(spare room in rcvbuffer)</p><h3 id="tcp-three-way-handshake"><a class="markdownIt-Anchor" href="#tcp-three-way-handshake"></a> TCP three-way handshake</h3><img src="../imgs/202411211253742.png" alt="" style="zoom:80%;" /><blockquote><p>How to close a TCP connection?</p></blockquote><img src="../imgs/202411211256294.png" alt="" style="zoom: 67%;" /><h3 id="tcp-congestion-control"><a class="markdownIt-Anchor" href="#tcp-congestion-control"></a> TCP Congestion Control</h3><p>The sender maintain: LastByteSent – LastByteAcked &lt;= min{cwnd, rwnd}</p><p>Because TCP uses acknowledgments to trigger (or clock) its increase in  congestion window size, TCP is said to be <strong>self-clocking</strong>.</p><img src="../imgs/image-20250221174242095.png" alt="" style="zoom:80%;" /><p>TCP Reno and TCP CUBIC:</p><img src="../imgs/202411211430700.png" alt="" style="zoom:80%;" /><p>Explicit Congestion Notification(ECN):</p><img src="../imgs/202411211502816.png" alt="" style="zoom: 67%;" /><blockquote><p>Why is TCP's AIMD algorithm fair?</p></blockquote><p>TCP results in an equal share of bandwidth among connections.</p><img src="../imgs/202411211516954.png" alt="" style="zoom: 80%;" /><h1 id="chapter-4-the-network-layer-data-plane"><a class="markdownIt-Anchor" href="#chapter-4-the-network-layer-data-plane"></a> Chapter 4 - The Network Layer: Data Plane</h1><h2 id="forwarding-and-routing"><a class="markdownIt-Anchor" href="#forwarding-and-routing"></a> Forwarding and Routing</h2><h3 id="control-plane"><a class="markdownIt-Anchor" href="#control-plane"></a> Control Plane</h3><ul><li><strong>Traditional approach:</strong></li></ul><p>The routing algorithm determines the contents of the routers’ forwarding tables.</p><p>The routing algorithm function in one router <strong>communicates</strong> with the routing algorithm function in other routers to compute the values for its forwarding table by <strong>exchanging routing messages</strong> containing routing information according to a <strong>routing protocol</strong>.</p><img src="../imgs/202502211810664.png" alt="" style="zoom:67%;" /><ul><li><strong>SDN approach:</strong></li></ul><p>A physically separate, remote controller computes and distributes the forwarding tables to be used by each and every router.</p><p>Control-plane routing functionality is <strong>separated from the physical router</strong>.</p><img src="../imgs/202502211810666.png" alt="" style="zoom: 60%;" /><h2 id="inside-a-router"><a class="markdownIt-Anchor" href="#inside-a-router"></a> Inside a Router</h2><h3 id="router-architecture"><a class="markdownIt-Anchor" href="#router-architecture"></a> Router architecture</h3><img src="../imgs/202502211810667.png" alt="" style="zoom:80%;" /><h3 id="input-port-processing"><a class="markdownIt-Anchor" href="#input-port-processing"></a> Input Port Processing</h3><img src="../imgs/202502211810668.png" alt="" style="zoom:80%;" /><p>The forwarding table is either:</p><ol><li>computed and updated by the <strong>routing processor</strong> (using a routing protocol to interact with the routing processors in other network routers)</li><li>or is received from a <strong>remote SDN controller</strong>.</li></ol><p>Input Queueing:</p><ol><li><p>switch fabric slower than input ports combined</p></li><li><p><strong>HOL blocking</strong></p></li></ol><img src="../imgs/202502211810669.png" alt="" style="zoom:80%;" /><h3 id="switching"><a class="markdownIt-Anchor" href="#switching"></a> Switching</h3><ul><li><strong>switching rate</strong>:</li></ul><p>rate at which packets can be transfer from inputs to outputs</p><p>N inputs: <strong>switching rate N times line rate</strong> desirable</p><ul><li><strong>Three switching techniques:</strong></li></ul><img src="../imgs/202502211810670.png" alt="" style="zoom:80%;" /><ul><li><strong>Parallelism</strong>:</li></ul><ol><li>Multistage switch</li></ol><p>fragment datagram into fixed length cells at the input port</p><p>switch cells through the fabric, reassemble datagram at the output port</p><img src="../imgs/202502211810671.png" alt="" style="zoom:80%;" /><ol start="2"><li>multiple switching planes in parallel</li></ol><img src="../imgs/202502211810672.png" alt="" style="zoom:80%;" /><h3 id="output-port-processing"><a class="markdownIt-Anchor" href="#output-port-processing"></a> Output Port Processing</h3><img src="../imgs/202502211810673.png" alt="" style="zoom:80%;" /><ul><li><strong>Output port queuing</strong>:</li></ul><img src="../imgs/202502211810674.png" alt="" style="zoom:80%;" /><ul><li><strong>Packet Scheduling</strong>:</li></ul><ol><li>FIFO</li><li>Priority Queuing</li></ol><img src="../imgs/202502211810675.png" alt="" style="zoom:80%;" /><ol start="3"><li>Round Robin and Weighted Fair Queuing (WFQ)</li></ol><img src="../imgs/202502211810676.png" alt="" style="zoom:80%;" /><h2 id="ip-protocol"><a class="markdownIt-Anchor" href="#ip-protocol"></a> IP Protocol</h2><h3 id="ipv4"><a class="markdownIt-Anchor" href="#ipv4"></a> IPv4</h3><p>Network layer functions:</p><img src="../imgs/202502211810677.png" alt="" style="zoom:80%;" /><p><strong>IPv4 datagram format</strong>:</p><img src="../imgs/202502211810678.png" alt=""  /><h3 id="ip-addressing"><a class="markdownIt-Anchor" href="#ip-addressing"></a> IP Addressing</h3><p>An IP address is technically associated with an <strong>interface</strong>,  rather than with the host or router containing that interface.</p><blockquote><p>What is a subnet?</p></blockquote><p>Device interfaces that can physically reach each other without passing through an intervening router.</p><p><strong>Address Aggregation</strong>:</p><img src="../imgs/202502211810679.png" alt=""  /><blockquote><p>How to obtain a block of IP addresses?</p></blockquote><ol><li>Contact its ISP</li></ol><img src="../imgs/202502211810680.png" alt="" style="zoom: 67%;" /><ol start="2"><li>Contact global authority (ICANN)</li></ol><blockquote><p>How to obtain a Host Address?</p></blockquote><p>Dynamic Host Configuration Protocol (DHCP): <strong>plug-and-play</strong> capability</p><p>DHCP is a client-server protocol:</p><img src="../imgs/202502211810681.png" alt="" style="zoom: 60%;" /><p>DHCP protocol is a four-step process:</p><ol><li>Broadcast <strong>DHCP discover message</strong> to all nodes attached to the subnet.(Discover the DHCP server)</li><li>A DHCP server receiving a DHCP discover message broadcasts <strong>DHCP offer message</strong> to all nodes on the subnet.</li><li>The newly arriving client choose from among one or more server offers and respond to its selected offer with a <strong>DHCP request message</strong>,  echoing back the configuration parameters.</li><li>The server responds to the DHCP request message with a <strong>DHCP ACK message</strong>, confirming the requested parameters.</li></ol><img src="../imgs/202502211810682.png" alt="" style="zoom:80%;" /><h3 id="network-address-translation-nat"><a class="markdownIt-Anchor" href="#network-address-translation-nat"></a> Network Address Translation (NAT)</h3><p>In essence, the NAT-enabled router is <strong>hiding the details of the home network from the outside world</strong>.</p><p>The router gets its address from the ISP’s DHCP server, and the router runs a DHCP server to provide addresses to computers within the <strong>NAT-DHCP-router-controlled</strong> home network’s address space.</p><img src="../imgs/202502211810683.png" alt="" style="zoom:80%;" /><h2 id="generalized-forwarding-and-sdn"><a class="markdownIt-Anchor" href="#generalized-forwarding-and-sdn"></a> Generalized Forwarding and SDN</h2><img src="../imgs/202502211810684.png" alt="" style="zoom:80%;" /><p>OpenFlow: flow table entries</p><img src="../imgs/202502211810685.png" alt="" style="zoom:80%;" /><h2 id="middleboxes"><a class="markdownIt-Anchor" href="#middleboxes"></a> Middleboxes</h2><blockquote><p>Definition: Any intermediary box performing functions apart from normal, <strong>standard functions of an IP router</strong> on the data path between a source host and destination  host</p></blockquote><ul><li>THE IP HOURGLASS</li></ul><p>The IP protocol <strong>hides the detailed differences</strong> among the various underlying technologies and present a <strong>uniform service interface</strong> to the applications above.</p><img src="../imgs/202411252058039.png" alt="" style="zoom: 67%;" /><h1 id="chapter-5-the-network-layer-control-plane"><a class="markdownIt-Anchor" href="#chapter-5-the-network-layer-control-plane"></a> Chapter 5 - The Network  Layer: Control Plane</h1><h2 id="routing-algorithm"><a class="markdownIt-Anchor" href="#routing-algorithm"></a> Routing Algorithm</h2><img src="../imgs/202412051732443.png" alt="" style="zoom: 80%;" /><p><strong>Centralized Routing Algorithm (link-state (LS) algorithm)</strong>: the algorithm has complete information about connectivity and link costs.</p><p><strong>Decentralized Routing Algorithm (distance-vector (DV) algorithm)</strong>: each node maintains a vector of estimates of the costs (distances) to all other nodes in the net work.</p><hr /><h3 id="link-state-ls-algorithm"><a class="markdownIt-Anchor" href="#link-state-ls-algorithm"></a> Link-State (LS) Algorithm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">/* Link-State (LS) Algorithm for Source Node u */<br>Initialization: <br> N’ = &#123;u&#125;<br> for all nodes v<br>   if v is a neighbor of u<br>     then D(v) = c(u,v)<br>   else D(v) = infinity<br><br>Loop<br> find w not in N’ such that D(w) is a minimum<br> add w to N’<br> update D(v) for each neighbor v of w and not in N’:<br>       D(v) = min(D(v), D(w)+ c(w,v) )<br>  /* new cost to v is either old cost to v or known<br>  least path cost to w plus cost from w to v */<br>until N’= N<br></code></pre></td></tr></table></figure><img src="../imgs/202412051732443.png" alt="" style="zoom: 80%;" /><img src="../imgs/202412151922392.png" alt="" style="zoom:80%;" /><img src="../imgs/202412152148301.png" alt="" style="zoom:80%;" /><p>The implementation of this LS algorithm has worst-case complexity of order n squared: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​</p><div class="note note-primary">            <blockquote><p>How to avoid <strong>oscillations</strong> with <strong>congestion-sensitive</strong> routing?</p></blockquote><p>Ensure that not all routers run the LS algorithm at the same time.</p><p><strong>Randomize</strong> the time each router sends out a link advertisement in order to avoid the self-synchronization of the algorithm execution instance.</p>          </div><hr /><h3 id="distance-vector-dv-routing-algorithm"><a class="markdownIt-Anchor" href="#distance-vector-dv-routing-algorithm"></a> Distance-Vector (DV) Routing Algorithm</h3><img src="../imgs/202412051732443.png" alt="" style="zoom: 80%;" /><p>Bellman-Ford equation:</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">d_{x}(y) = min_v \{c(x, v) + d_v(y)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>x</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>D</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>y</mi><mtext> </mtext><mi>i</mi><mi>n</mi><mtext> </mtext><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Dx = [D_x(y): y\ in\ N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span> is node x’s distance vector</p><p>From time to time, each node sends a copy of its <strong>distance vector</strong> to each of its neighbors. When a node x receives a new distance vector from any of its neighbors w, it saves w’s distance vector, and then uses the Bellman-Ford equation to update its own distance vector as follows:</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>D</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mtext> </mtext><mi>f</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mtext> </mtext><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mtext> </mtext><mi>y</mi><mtext> </mtext><mi>i</mi><mi>n</mi><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">D_{x}(y) = min_v \{c(x, v) + D_v(y)\}\ for\ each\ node\ y\ in\ N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">}</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>If node x’s distance vector has changed as a result of this update step, node x will then  send its updated distance vector to each of its neighbors, which can in turn update  their own distance vectors.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">/* Distance-Vector (DV) Algorithm <br> * At each node, x:<br> */<br>Initialization:<br>   for all destinations y in N:<br>      Dx(y)= c(x,y)/* if y is not a neighbor then c(x,y)= infinity */<br>   for each neighbor w<br>      Dw(y) = ? for all destinations y in N<br>   for each neighbor w<br>      send distance vector  Dx = [Dx(y): y in N] to w<br><br>loop <br>    wait  (until I see a link cost change to some neighbor w              or until I receive a distance vector from some                neighbor w)<br>    <br>    for each y in N:<br>        Dx(y) = minv&#123;c(x,v) + Dv(y)&#125;<br>    /* for each destination y, node x also determines v*(y)          and updates its forwarding table for destination y. */<br><br>if Dx(y) changed for any destination y<br>        send distance vector Dx  = [Dx(y): y in N] to all             neighbors<br><br>forevers<br></code></pre></td></tr></table></figure><blockquote><p>How to avoid the <strong>count-to-infinity</strong> problem?</p></blockquote><img src="../imgs/202412160222283.png" alt="" style="zoom:80%;" /><p><strong>Poisoned reverse</strong>: If z routes through y to get to destination x,  then z will advertise to y that its distance to x is infinity, that is, z will advertise to y that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi><mi>n</mi><mi>f</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">D_z(x) = infinity</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></p><h2 id="intra-as-routing-in-the-internet-ospf"><a class="markdownIt-Anchor" href="#intra-as-routing-in-the-internet-ospf"></a> Intra-AS Routing in the Internet: OSPF</h2><p>The routing algorithm running within an AS(<strong>autonomous system</strong>) is called an <strong>intra-autonomous system routing protocol</strong>.</p><hr /><h3 id="open-shortest-path-first-ospf"><a class="markdownIt-Anchor" href="#open-shortest-path-first-ospf"></a> Open Shortest Path First (OSPF)</h3><p>OSPF is a <strong>link-state protocol</strong> that uses flooding of <strong>link-state information</strong> and a <strong>Dijkstra’s least-cost path algorithm</strong>.</p><p>A router broadcasts <strong>link-state information</strong> whenever there is a change in a link’s state. It also broadcasts a link’s state periodically, even if the link’s state has not changed.</p><p>OSPF runs directly over IP.</p><div class="note note-info">            <blockquote><p>OSPF supports <strong>hierarchy</strong> within a single AS</p></blockquote><p>An OSPF autonomous system can be configured hierarchically into <strong>areas</strong>.</p><p>Within each area, there are one or more <strong>area border routers</strong>.</p><p>Within an AS, there is exactly one <strong>backbone area</strong>.</p><p><strong>Inter-area routing</strong> within the AS requires that the packet be first routed to an <strong>area border router</strong> (intra-area routing), then routed through the backbone to the area border router that is in the destination area, and then routed to the final destination.</p>          </div><h2 id="routing-among-the-isps-bgp"><a class="markdownIt-Anchor" href="#routing-among-the-isps-bgp"></a> Routing Among the ISPs: BGP</h2><img src="../imgs/202412161639345.png" alt="" style="zoom: 67%;" /><img src="../imgs/202412161640250.png" alt="" style="zoom: 80%;" /><p>Each BGP route is a list with three components: <strong>NEXT-HOP</strong>; <strong>AS-PATH</strong>; <strong>destination prefix</strong></p><img src="../imgs/202412161700708.png" alt="" style="zoom: 67%;" /><hr /><h3 id="route-selection-algorithm"><a class="markdownIt-Anchor" href="#route-selection-algorithm"></a> Route-Selection Algorithm</h3><ol><li>A route is assigned a <strong>local preference value</strong> as one of its attributes (in addition  to the AS-PATH and NEXT-HOP attributes). The routes with the highest local preference values are selected.</li><li>From the remaining routes (all with the same highest local preference value),  the route with the <strong>shortest AS-PATH</strong> is selected.</li><li>From the remaining routes, <strong>hot potato routing</strong> is used, that is, the route with the <strong>closest NEXT-HOP router</strong> is selected.</li><li>If more than one route still remains, the router uses <strong>BGP identifiers</strong> to select the route</li></ol><hr /><h3 id="ip-anycast"><a class="markdownIt-Anchor" href="#ip-anycast"></a> IP-Anycast</h3><img src="../imgs/202412161736416.png" alt="" style="zoom: 67%;" /><p>IP-anycast is extensively used by the DNS system to direct DNS queries to the <strong>closest root DNS server</strong>.</p><h1 id="chapter-6-the-link-layer-and-lans"><a class="markdownIt-Anchor" href="#chapter-6-the-link-layer-and-lans"></a> Chapter 6 - The Link Layer and LANs</h1><p>A typical host architecture:</p><img src="../imgs/202412161905144.png" alt="" style="zoom: 67%;" /><h2 id="switched-local-area-networks"><a class="markdownIt-Anchor" href="#switched-local-area-networks"></a> Switched Local Area Networks</h2><h3 id="link-layer-addressing-and-arp"><a class="markdownIt-Anchor" href="#link-layer-addressing-and-arp"></a> Link-Layer Addressing and ARP</h3><img src="../imgs/202412161922853.png" alt="" style="zoom: 80%;" /><ul><li>ARP</li></ul><p>ARP resolves IP addresses only for hosts and router interfaces on the <strong>same subnet</strong>.</p><img src="../imgs/image-20241216195033045-1740143775464-181.png" alt="" style="zoom:80%;" /><hr /><h3 id="ethernet"><a class="markdownIt-Anchor" href="#ethernet"></a> Ethernet</h3><img src="../imgs/image-20241216200639093-1740143790085-183.png" alt="" style="zoom:80%;" /><h2 id="link-layer-switches"><a class="markdownIt-Anchor" href="#link-layer-switches"></a> Link-Layer Switches</h2><p>switches are <strong>self-learning</strong>:</p><ol><li>The switch table is initially empty.</li><li>For each incoming frame received on an interface, the switch stores in its table  (1) the MAC address in the frame’s source address field, (2) the interface from  which the frame arrived, and (3) the current time.</li><li>The switch deletes an address in the table if no frames are received with that  address as the source address after some period of time (<strong>the aging time</strong>). In  this manner, if a PC is replaced by another PC (with a different adapter),</li></ol><p>Switches are <strong>plug-and-play</strong> devices.</p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELEC331</tag>
      
      <tag>Computer Networking</tag>
      
      <tag>Top-Down Approach</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paging</title>
    <link href="/2024/11/14/Paging/"/>
    <url>/2024/11/14/Paging/</url>
    
    <content type="html"><![CDATA[<p>Think about this problem while you are learning this part:</p><blockquote><p>Why we are doing paging?</p></blockquote><p>This part is crucial for you to implementing OS/161 Assignment 6 correctly!</p><h1 id="paging"><a class="markdownIt-Anchor" href="#paging"></a> Paging</h1><blockquote><p><strong>Learning Materials</strong></p><p>Video:</p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/vm1-waudio.mp4">Intro to Virtual Memory</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/vm-tlb-waudio.mp4">Translation Lookaside Buffer (TLB)</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/vm-x86.mp4">Virtual memory on x86</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/vm-paging-waudio.mp4">Intro to paging</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/vm-paging2-waudio.mp4">Continuation of paging by Margo Seltzer</a></p><p>Lecture Slides:</p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/VM-new.pptx"> Virtual memory (Intro)</a></p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Paging-new.pptx">Paging</a></p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Paging-disk.pptx">Paging to disk</a></p><p>Readings:</p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-api.pdf">OSTEP] Memory API</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-tlbs.pdf">OSTEP] Translation lookaside buffers</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf">OSTEP] Free space management</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/mips-TLB.pdf">MIPS MMU and TLB</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-paging.pdf">OSTEP] Introduction to Paging</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-smalltables.pdf">OSTEP] Advanced paging</a></p></blockquote><h2 id="paging-2"><a class="markdownIt-Anchor" href="#paging-2"></a> Paging</h2><h3 id="definition-and-concept"><a class="markdownIt-Anchor" href="#definition-and-concept"></a> Definition and Concept</h3><h4 id="define-paging"><a class="markdownIt-Anchor" href="#define-paging"></a> Define paging</h4><p>The operating system creates the illusion of unlimited memory by using physical memory as a cache of virtual pages.</p><img src="../imgs/202411191055926.png" alt="" style="zoom:67%;" /><h4 id="page-faults"><a class="markdownIt-Anchor" href="#page-faults"></a> Page Faults</h4><p>Paging relaxes the requirement that all the pages in a process's virtual address space must be in physical memory. Instead, we allow a process to have pages either on disk or in memory. When the process issues an access to a page that is on disk, a page fault occurs. The operating system must retrieve the page from disk and bring it into memory.</p><img src="../imgs/202410291208365.png" alt="" style="zoom:67%;" /><p>The translation does not exist in the page table (<strong>the page is on disk</strong>), the OS must:</p><ol><li>Allocate a place in physical memory to store the page.</li><li>(If physical memory is full, evict a page. If the evicted page is modified or does not currently have a copy on disk, write the page to disk)</li><li>Read the page from disk.</li><li>Update the page table entry with the new virtual-to-physical address translation.</li><li>Update the TLB to contain the new translation.</li><li>Resume execution of the user program.</li></ol><p>Notice that when the operating system selects a location in physical memory in which to place the new page, the space may already be occupied. In this case, the operating system must <strong>evict</strong> that other page from memory. If the page has been <strong>modified</strong> or <strong>does not currently have a copy on disk</strong>, then the old page must first be written to disk before the physical page can be reallocated. If the old page has <strong>not been modified</strong> and <strong>already has a copy on disk</strong>, then the write to disk can be avoided. The appropriate page table entry must be updated to reflect the fact that the page is no longer in memory.</p><p>Memory serves as the cache of disk. As with any caching system, performance of your virtual memory system depends on the policy used to decide which things are kept in memory(cache) and which are evicted (to disk). On a page fault, the kernel must decide which page to replace. Ideally, it will evict a page that will not be needed soon. Many systems (such as UNIX) avoid the delay of synchronously writing memory pages to disk on a page fault by <strong>writing modified pages to disk in advance</strong>, so that subsequent page faults can be completed more quickly.</p><h4 id="multi-level-page-tables"><a class="markdownIt-Anchor" href="#multi-level-page-tables"></a> Multi-Level Page Tables</h4><p>Two-level page table:</p><p>Use a page directory which points to pages of the page table.</p><img src="../imgs/202411221844280.png" alt="" style="zoom:67%;" /><img src="../imgs/202411231627475.png" alt="" style="zoom: 67%;" /><h3 id="mips-virtual-memory-map"><a class="markdownIt-Anchor" href="#mips-virtual-memory-map"></a> MIPS Virtual Memory Map</h3><p>KSEG0, KSEG1 addresses: directly map to physical RAM starting at 0</p><p>KUSEG, KSEG2 addresses: translate with the help of the TLB</p><img src="../imgs/202411232002776.png" alt="" style="zoom:67%;" /><h3 id="tlb"><a class="markdownIt-Anchor" href="#tlb"></a> TLB</h3><h4 id="associative-tlb"><a class="markdownIt-Anchor" href="#associative-tlb"></a> Associative TLB</h4><img src="../imgs/202411262252428.png" alt="" style="zoom: 50%;" /><h4 id="address-translation-process"><a class="markdownIt-Anchor" href="#address-translation-process"></a> Address Translation Process</h4><img src="../imgs/202411262252356.png" alt="" style="zoom: 50%;" /><h4 id="mips-mmu-and-tlb"><a class="markdownIt-Anchor" href="#mips-mmu-and-tlb"></a> MIPS MMU and TLB</h4><p>No hardware support for page tables.</p><p>MIPS makes the format and contents of the TLB entry public to the kernel.</p><img src="../imgs/202411261139273.png" alt="" style="zoom:80%;" /><img src="../imgs/202411262254163.png" alt="" style="zoom:80%;" /><p>MIPS R3000 TLB:</p><img src="../imgs/202411232013748.png" alt="" style="zoom: 67%;" /><ul><li><code>global</code>: 1 bit; if set, ignore the pid bits in the TLB.</li><li><code>valid</code>: 1 bit; set if the TLB entry contains a valid translation.</li><li><code>dirty</code>: 1 bit; enables writing to the page referenced by the entry; if this bit is 0, the page is only accessible for reading.</li><li><code>nocache</code>: 1 bit; <strong>unused in System/161</strong>. In a real processor, indicates that the hardware cache will be disabled when accessing this page.</li><li><code>pid</code>: 6 bits; a process or address space ID that can be used to allow entries to remain in the TLB after a process switch.</li></ul><blockquote><p>How to handle TLB miss in OS/161?</p></blockquote><p>Write <strong><code>vm_fault</code></strong> function:</p><img src="../imgs/202411232038054.png" alt="" style="zoom: 50%;" /><blockquote><p>What is the <strong>TLB shootdown</strong>?</p></blockquote><p>If we want to evict a page whose virtual-to-physical translation might be in one/more TLBs, we need to revoke the corresponding TLB entry in all the TLBs. But, from one processor you can't directly access another processor's TLB; instead you have to poke the other processor and ask it to do the revocation for you. The process of doing so is called &quot;TLB shootdown&quot;.</p><blockquote><p>How to implement the <strong>TLB shootdown</strong>?</p></blockquote><p>Issue an inter-processor interrupt (IPI) to the processors that (may) have the mappings you want removed in their TLBs. These processors, upon receiving the interrupt, do the necessary TLB flush operations, and then signal back in some fashion that they've finished.</p><h3 id="mips-r3000-virtual-addresses"><a class="markdownIt-Anchor" href="#mips-r3000-virtual-addresses"></a> MIPS R3000 Virtual Addresses</h3><img src="../imgs/202411232018049.png" alt="" style="zoom: 50%;" /><blockquote><p>How to manage physical memory in OS/161?</p></blockquote><img src="../imgs/202411232038812.png" alt="" style="zoom: 60%;" /><h3 id="roadmap-to-a6"><a class="markdownIt-Anchor" href="#roadmap-to-a6"></a> Roadmap to A6</h3><img src="../imgs/202411232040973.png" alt="" style="zoom: 50%;" /><h2 id="paging-to-disk"><a class="markdownIt-Anchor" href="#paging-to-disk"></a> Paging to disk</h2><img src="../imgs/202411232048424.png" alt="" style="zoom:60%;" /><blockquote><p>How to choose pages to be evicted to disk? Which pages won't be needed soon? Which pages are easier to evict?(Do all pages need to be written to disk?)</p></blockquote><p><strong>Page replacement algorithm.</strong></p><p>Clean pages(Code pages) are easier to evict since they don't need to be written to disk.</p><img src="../imgs/202411241636311.png" alt="" style="zoom: 50%;" /><img src="../imgs/202411241748500.png" alt="" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">/* Function call chain */<br>foo() -&gt; kmalloc -&gt; getppages -&gt; evict -&gt; write to swap<br></code></pre></td></tr></table></figure><p>When a page get evicted, we need to <strong>invalidate the page in TLB</strong>.</p><p>If the page you evict might be in another TLB, do a <strong>TLB shootdown</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Paging</tag>
      
      <tag>Virtual Memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS161 Assignment 5</title>
    <link href="/2024/11/11/OS161-A5/"/>
    <url>/2024/11/11/OS161-A5/</url>
    
    <content type="html"><![CDATA[<h1 id="assignment5"><a class="markdownIt-Anchor" href="#assignment5"></a> Assignment5</h1><blockquote><p>Implement <code>fork, execv, waitpid, getpid and _exit</code>.</p></blockquote><h2 id="questions-to-think-about"><a class="markdownIt-Anchor" href="#questions-to-think-about"></a> Questions to think about</h2><blockquote><ol><li>How to <strong>create a copy of an existing user process</strong> and make the new process <strong>return to user mode with a different return value</strong> than the original process. Code in <code>runprogram.c</code> and in the function it calls and in <code>proc_create_runprogram</code> will be very helpful in figuring that out.</li></ol></blockquote><p><code>fork</code> system call is responsible for creating a copy of an existing user process and making the new(child) process return to user mode with a different return value than the original(parent) process.</p><p>To create a new user process, we first need to create a new kernel thread to provide to it. This newly-created kernel thread should change child's <code>trapframe</code> and return to user mode in a different manner than the parent.</p><blockquote><ol start="2"><li>How to replace the address space of a process created via <code>fork</code> with a completely new address space and executable.</li></ol></blockquote><p>When we want to create a process with a completely new address space and executable. we need to call <code>execv</code> after <code>fork</code>. In <code>execv</code>, we need to create the new address space, switch to and activate it. With the new address space set up, we can load the new executable and define the user stack.</p><blockquote><ol start="3"><li>How to copy in/out of the <code>userspace</code> the argument vector for the <code>execv</code> system call. This code requires lots of pointer arithmetic and handling various corner cases.</li></ol></blockquote><p>This is the most tricky part when we implement <code>execv</code>. We need to copy in/out not only the argument array, but also the pointers pointing to those arguments. First, we need to copy argument array and pointer array into the kernel from the old address space, then copy those out to the new address space.</p><blockquote><ol start="4"><li>How to manage the process IDs, so you don't run out as processes are created and retired.</li></ol></blockquote><p>We need to implement the <strong>PID system</strong> that dynamically allocates and reclaims PID.</p><blockquote><ol start="5"><li>How to synchronize the parent and child processes in <code>waitpid()</code> and <code>_exit()</code>.</li></ol></blockquote><p>To synchronize parent and child processes, we need to implement the <strong>process wait and exit mechanism</strong>. For now, just need to understand that parent processes call <code>waitpid</code> to wait for their child processes to exit. When child processes exit, they need to signal their parents.</p><div class="note note-danger">            <p>It's important to note that a process will not necessarily be cleaned up right after it exits. It strongly depends on how you design your process wait and cleanup mechanism.</p>          </div><blockquote><ol start="6"><li>How to manage the file table synchronization, given that starting from this assignment two or more processes might concurrently access the same file object (<strong>processes created via fork share the file objects</strong>).</li></ol></blockquote><p>In the last assignment, we already take this synchronization problem into account. As long as we hold the file handle lock right after we get the file handle, we are fine.</p><h2 id="system-calls-to-implement"><a class="markdownIt-Anchor" href="#system-calls-to-implement"></a> System calls to implement</h2><p>Make sure to read the system calls man page carefully to understand every detail of these system calls:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getpid</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>Main task: Implement <strong><code>pid</code> allocation and reclamation</strong></p><hr /><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fork</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p><code>sys_fork</code> is responsible for:</p><ol><li>Copy address space(<code>as_copy</code> in <code>dumbvm</code>)</li></ol><p>The forked process should have the exact same address space as the original process.</p><img src="../imgs/202410262356451.png" alt="" style="zoom:50%;" /><ol start="2"><li>Copy the file table</li></ol><p>When a process is forked, file descriptor entries of the new process point to the <strong>same file handles</strong> as in the parent process.</p><img src="../imgs/202410262356432.png" alt="" style="zoom:50%;" /><blockquote><p>What kind of race conditions do you have to worry about?</p></blockquote><p>Two processes simultaneously modifying the values of the offset.</p><blockquote><p>Can you hold a spinlock while doing I/O?</p></blockquote><p>Spinlocks turn off interrupts; I/O completion is signaled via an interrupt. If you turn off interrupts and then go do I/O, YOU WILL NEVER GET NOTIFIED!</p><blockquote><p>Hold a regular lock? That will work. But do we have to hold the lock?</p></blockquote><p>-- Not really. We can set up the <code>uio</code> struct with the right offset, release the lock, do the I/O, then acquire it again and update the offset if I/O was successful. Can’t update the offset prior to I/O completion – what if it fails?</p><ol start="3"><li>Copy architectural state(Copy and tweak <code>trapframe</code>)</li></ol><p>In the implementation of A5, you will have to make sure <strong>the right value is returned to the right process!</strong></p><blockquote><p>How will you need to modify the child's <code>trapframe</code> to make sure that the child correctly returns to user mode?</p></blockquote><p>Set the correct return value (0), signal no error, and advance to next instruction in the <code>trapframe</code>.</p><blockquote><p>When do you need to copy the parent's <code>trapframe</code>? Remember that as soon as the parent is returned from the system call, its <code>trapframe</code> will be destroyed or modified!</p></blockquote><p>Copy the parent's <code>trapframe</code> to <code>child_tf</code> before creating the kernel thread for the child process.</p><ol start="4"><li>Copy kernel thread(<code>thread_fork</code>)</li></ol><p><strong>When you fork a new process, you fork a new kernel thread to provide to the child process.</strong></p><p><strong>To fork that thread, you need to provide it a function to run. You’ll need to write that function.</strong></p><p>As mentioned above, <code>thread_fork</code> is used to fork a new kernel thread for the newly-forked process. <code>enter_forked_process</code> is provided to the newly-created thread.</p><p>You need to implement the <code>enter_forked_process</code> to modify the child process's <code>trapframe</code> and return to user mode:</p><img src="../imgs/202410262324165-1740473621641-3.png" alt="" style="zoom: 67%;" /><ol start="5"><li>Return to user mode</li><li>Both the parent and child return to user mode</li></ol><p>The parent just returns from exception(<code>mips_trap</code>).</p><p>The child returns via the <code>mips_usermode</code> function.</p><blockquote><p>How does a thread enter user mode for the first time?</p></blockquote><p><code>mips_usermode</code> in <code>trap.c</code>. This function shouldn't used by threads returning from traps - they should just return from <code>mips_trap</code>.</p><hr /><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execv</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>It must replace the existing address space with a brand new one for the new executable (created by calling <code>as_create</code> in the current <code>dumbvm</code> system) and then run it.</p><p>While this is similar to starting a process straight out of the kernel (as <code>runprogram()</code> does), it's not quite that simple. Remember that this call is <strong>coming out of <code>userspace</code>, into the kernel, and then returning back to <code>userspace</code></strong>. You must manage the memory that travels across these boundaries very carefully.</p><p>(Also, notice that <code>runprogram()</code> doesn't take an argument vector -- but this must of course be handled correctly in <code>execv()</code>)</p><p>As you are replacing an old address space with a new one, you must not leak memory used by the old address space.</p><p>Carefully read the <a href="http://ece.ubc.ca/~os161/man/syscall/execv.html">man page</a> for <code>execv()</code> to understand the trickery in <strong>passing the potentially very large argument vector to/from <code>userspace</code></strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span></span><br><span class="hljs-function"><span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *program, <span class="hljs-type">char</span> **args)</span></span>;<br></code></pre></td></tr></table></figure><p><code>sys_execv</code> is responsible for:</p><p>• Replace the old address space with a new one</p><p>• Copy the arguments into the new address space</p><p>• Return to user mode</p><p><strong>The mechanics of <code>exec()</code></strong>:</p><p><img src="../imgs/202411041428372-1740473621641-5.png" alt="" /></p><p><strong>To think before starting exec():</strong></p><blockquote><p><strong>Where are the arguments located</strong> when the exec system call in invoked? In whose address space? How do you know their address?</p><p>How do we get them into the kernel? How do you figure out their total size?</p><p>Where do the arguments need to end up before we return to the user mode? Whose address space? Stack or heap?</p><p>How do we get them there? How do we organize them there.</p><p>What if the arguments array is huge and you cannot allocate enough kernel memory contiguously?</p></blockquote><p><strong>Passing arguments(<code>copyin</code> and <code>copyout</code>)</strong>:</p><div class="note note-primary">            <p>It's important to emphasize that we need to pass not only the arguments, but also the pointers to those arguments.</p>          </div><p><img src="../imgs/202411041449905-1740473621641-7.png" alt="" /></p><p><img src="../imgs/202411041450806-1740473621641-9.png" alt="" /></p><p><img src="../imgs/202411041454332-1740473621641-11.png" alt="" /></p><hr /><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">waitpid</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>Require a fair bit of design.</p><p><strong>If a parent process exits before one or more of its children, it can no longer be expected collect their exit status.</strong> There are several ways to handle this case in practice, of which the traditional Unix method is only one. This is something you should design.</p><hr /><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">_exit</span>()</span><br></code></pre></td></tr></table></figure><p>Closely connected to the implementation of <code>waitpid()</code>.</p><p>Most of the time, the code for <code>_exit()</code> will be simple and the code for <code>waitpid()</code> relatively complicated.</p><h2 id="error-handling"><a class="markdownIt-Anchor" href="#error-handling"></a> Error handling</h2><p>If there are conditions that can happen that are not listed in the man page, return the most appropriate error code from <code>kern/include/kern/errno.h</code>.</p><p>Note that if you add an error code to <code>src/kern/include/kern/errno.h</code>, you need to add a corresponding error message to the file <code>src/kern/include/kern/errmsg.h</code>.</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">kill_curthread</span><br></code></pre></td></tr></table></figure><p>Feel free to write <code>kill_curthread()</code> in as simple a manner as possible.</p><div class="note note-success">            <p><code>kill_curthread</code> is similar to <code>_exit</code>, except that in <code>kill_curthread</code>, we need to signal the parent process that current process is dead. We only need to change the <code>p_exitcode</code>.</p>          </div><h2 id="plan-your-work"><a class="markdownIt-Anchor" href="#plan-your-work"></a> Plan your work</h2><p>Implement <code>fork</code> first.</p><p>You will be able to test it using <code>/testbin/forktest</code> (set <code>no wait</code> to 1 in <code>forktest.c</code> if you would like to run it before <code>waitpid</code> is implemented)</p><p>You may first implement <code>fork()</code> with a very simple <code>pid</code> assignment scheme, and improve on it later as you are designing the rest of the system calls.</p><h2 id="test-your-code"><a class="markdownIt-Anchor" href="#test-your-code"></a> Test your code</h2><ol><li><strong>Testing using the shell</strong></li></ol><p>In user <code>/bin/sh</code> you will find a simple shell that will allow you to test your new system call interfaces.</p><p>You can exit the shell by typing &quot;exit&quot;.</p><p>Before you run the shell, you need to put some synchronization code into <code>common_prog()</code>(in <code>menu.c</code>:114) to make sure that the menu thread is not trying to run concurrently with your shell and does not compete with it for the console input/output.</p><ol start="2"><li><strong>Error handling</strong></li></ol><p>Use the devious <code>/testbin/badcall</code> (which you should now be able to invoke from a shell). At this point your system should not crash no matter what the user program does.</p><p>Even <code>/testbin/forkbomb</code> should not crash your kernel.</p><ol start="3"><li><strong>Memory leaks</strong></li></ol><p>Your <code>execv</code> should properly dispose of the old address space (and any other old unneeded state) and returned the memory back to the system.</p><p>If a system call fails in the middle of execution (e.g., because of a bad pointer coming from user space) you must free up the resources allocated up to that point.</p><p>You can debug memory leaks by changing <code>#undef LABELS</code> to <code>#define labels</code> in <code>vm/kmalloc.c</code> and then invoking <code>khdump</code> from the kernel menu to examine the heap.</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dns">OS/<span class="hljs-number">161</span> kernel [? for menu]: khdump<br>Remaining allocations from generation <span class="hljs-number">3</span>:<br>  <span class="hljs-number">16</span> bytes at <span class="hljs-number">0x80042e70</span>, allocated at <span class="hljs-number">0x80012d80</span><br>  <span class="hljs-number">64</span> bytes at <span class="hljs-number">0x80040140</span>, allocated at <span class="hljs-number">0x80006080</span><br>  <span class="hljs-number">64</span> bytes at <span class="hljs-number">0</span>x<span class="hljs-number">800401c0</span>, allocated at <span class="hljs-number">0</span>x8001162c<br>  <span class="hljs-number">64</span> bytes at <span class="hljs-number">0x80040200</span>, allocated at <span class="hljs-number">0x80006080</span><br>  <span class="hljs-number">64</span> bytes at <span class="hljs-number">0x80040340</span>, allocated at <span class="hljs-number">0x80006080</span><br>  <span class="hljs-number">64</span> bytes at <span class="hljs-number">0</span>x<span class="hljs-number">800403c0</span>, allocated at <span class="hljs-number">0x80006080</span><br>  <span class="hljs-number">64</span> bytes at <span class="hljs-number">0x80040480</span>, allocated at <span class="hljs-number">0x80006080</span><br>  <span class="hljs-number">64</span> bytes at <span class="hljs-number">0x80040540</span>, allocated at <span class="hljs-number">0x80006080</span><br>  <span class="hljs-number">64</span> bytes at <span class="hljs-number">0x80040680</span>, allocated at <span class="hljs-number">0x80006080</span><br> <span class="hljs-number">128</span> bytes at <span class="hljs-number">0</span>x<span class="hljs-number">8003f780</span>, allocated at <span class="hljs-number">0</span>x80023cfc<br> <span class="hljs-number">256</span> bytes at <span class="hljs-number">0x80041b00</span>, allocated at <span class="hljs-number">0</span>x8001162c<br> <span class="hljs-number">512</span> bytes at <span class="hljs-number">0x80043c00</span>, allocated at <span class="hljs-number">0</span>x8001162c<br>Operation took <span class="hljs-number">1.195788680</span> seconds<br></code></pre></td></tr></table></figure><p>You see that this command outputs a bunch of virtual addresses that were allocated via <code>kmalloc</code> and the corresponding addresses of code locations, where those items were allocated. To find out what these code locations are, you can use <code>os161-addr2line</code> (the OS/161 version of this standard Unix tool). For example, using an address from the example above:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">os161-addr2line -e ~<span class="hljs-regexp">/Work/</span>os161<span class="hljs-regexp">/root/</span>kernel <span class="hljs-number">0</span>x80023cfc<br><span class="hljs-regexp">/Users/</span>UBC-home<span class="hljs-regexp">/Work/</span>os161<span class="hljs-regexp">/src/</span>kern<span class="hljs-regexp">/compile/</span>DUMBVM<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/thread/</span>thread.c:<span class="hljs-number">132</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>How we will mark your code</strong></li></ol><p>We will run a subset of the following tests on your kernel (all from /testbin)</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">forktest<br>argtest<br><span class="hljs-keyword">bigfile</span><br><span class="hljs-keyword"></span>crash<br>farm<br>faulter<br>forkbomb<br><span class="hljs-keyword">multiexec</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">badcall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bigexec</span><br></code></pre></td></tr></table></figure><p><code>Forktest</code> and <code>argtest</code> are the simplest test programs, so first make sure that your kernel runs those. <code>Badcall</code> and <code>bigexec</code> are the most challenging.</p><h2 id="my-solution"><a class="markdownIt-Anchor" href="#my-solution"></a> My Solution</h2><p>I have revealed enough tips(secrets) above, more than enough for you to implement this assignment correctly! <strong>Please do not look at my solution below until you have finished coding!</strong> Otherwise, you will lose the joy of coding!</p><p>Now, I will dive deep down into my design and implementation. SPOIL (CODE) ALERT!</p><p>This assignment has 4 major parts:</p><ol><li>PID system</li><li>Process creation(<code>fork</code>)</li><li>Process wait and exit mechanism</li><li>Program replacement(<code>execv</code>)</li></ol><h3 id="pid-system"><a class="markdownIt-Anchor" href="#pid-system"></a> PID system</h3><p>First of all, we need to design our PID system that dynamically allocates and reclaims PID so that PID won't be used up as processes are created and destroyed.</p><p>Although the assignment handout suggest that we first implement a simple PID scheme before implementing <code>fork</code> and improve on it later when we try to implement more system calls, personally I prefer implementing the complete PID system before moving on.</p><p>My PID system design is rather simple. I maintain a global <code>pid_table</code>, with entries <code>pid_entry</code>. The index of the <code>pid_table</code> entry can be translated to <code>pid</code>. Since the index starts at 0 and the <code>pid</code> starts at <code>PID_MIN</code>(2), so <code>index = pid - PID_MIN</code>. I also use a <code>next_pid</code> variable to keep track of the next PID to try for allocation. Whenever we want to allocate a new PID, start trying from <code>next_pid</code>.</p><p>How do we know whether a <code>pid</code> is available? The <code>pid_entry</code> structure has a <code>proc</code> field. We simply examines whether <code>pid_entry-&gt;proc == NULL</code>. We free a <code>pid</code> by setting <code>pid_entry-&gt;proc = NULL</code></p><p>I set kernel process's <code>pid</code> to <code>PID_KERNEL</code>(1) just for convenience sake, and user processes' <code>pid</code> begin at 2(PID_MIN).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Create the process structure for the kernel.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">proc_bootstrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>kproc = <span class="hljs-built_in">proc_create</span>(<span class="hljs-string">&quot;[kernel]&quot;</span>);<br><span class="hljs-keyword">if</span> (kproc == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;proc_create for kproc failed\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* Allocate PID for kernel process */</span><br>kproc-&gt;p_pid = PID_KERNEL;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>proc_remove_pid</code> is called only during process cleanup to free the <code>pid</code>. Therefore, in my implementation, <strong><code>pid</code> freeing is always called in company with process destruction</strong>. It is important to emphasize that <code>pid</code> should not be freed until the process is destroyed (not exits!).</p><p><code>pid_bootstrap</code> needs to be called during initial boot sequence(early initialization) to indicate that all PIDs are available to use.</p><p>Lastly, don't forget to call <code>pid_allocate</code> in <code>proc_create_fork</code> and <code>proc_create_runprogram</code>.</p><p>The complete code of <code>pid.h</code> and <code>pid.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Process ID management.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PID_KERNEL    1</span><br><br><span class="hljs-comment">/* Number of PIDs available */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PID_COUNT   (PID_MAX - PID_MIN + 1)</span><br><br><span class="hljs-comment">/* Error value returned by pid_allocate */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOPID      (-1)    <span class="hljs-comment">/* No PIDs available */</span></span><br><br><span class="hljs-comment">/* PID table entry structure */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_entry</span> &#123;</span><br>    <span class="hljs-type">pid_t</span> pid;               <span class="hljs-comment">/* Process ID */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">proc</span>;</span>      <span class="hljs-comment">/* Pointer to process structure */</span><br>&#125;;<br><br><span class="hljs-comment">/* Global PID management state */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_entry</span> *<span class="hljs-title">pid_table</span>;</span>     <span class="hljs-comment">/* PID allocation table */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">pid_lock</span>;</span>        <span class="hljs-comment">/* Lock for PID operations */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pid_count;          <span class="hljs-comment">/* Number of PIDs in use */</span><br><span class="hljs-type">pid_t</span> next_pid;                  <span class="hljs-comment">/* Next PID to try for allocation */</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Initialize the PID management system.</span><br><span class="hljs-comment"> * Called during system bootstrap.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pid_bootstrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Allocate a new PID and associate it with a process.</span><br><span class="hljs-comment"> * Returns allocated PID on success, ENOPID on failure.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">pid_allocate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *proc)</span>;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Convert PID to table index.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pid_to_index</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get process structure associated with PID.</span><br><span class="hljs-comment"> * Returns NULL if PID is invalid or not in use.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> proc *<span class="hljs-title function_">pid_get_proc</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span>;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Remove process from PID table. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">proc_remove_pid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *proc)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Initialize the PID management system</span><br><span class="hljs-comment"> * Called during system bootstrap</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">pid_bootstrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>    <span class="hljs-type">size_t</span> table_size = PID_COUNT * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pid_entry);<br>    <br>    <span class="hljs-comment">/* Allocate PID table */</span><br>    pid_table = kmalloc(table_size);<br>    <span class="hljs-keyword">if</span> (pid_table == <span class="hljs-literal">NULL</span>) &#123;<br>        panic(<span class="hljs-string">&quot;pid_bootstrap: Unable to allocate PID table\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Initialize PID table entries */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PID_COUNT; i++) &#123;<br>        pid_table[i].pid = PID_MIN + i;<br>        pid_table[i].proc = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Initialize lock and state */</span><br>    spinlock_init(&amp;pid_lock);<br>    pid_count = <span class="hljs-number">0</span>;<br>    next_pid = PID_MIN;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Convert PID to table index</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pid_to_index</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span> <br>&#123;<br>    KASSERT(pid &gt;= PID_MIN &amp;&amp; pid &lt;= PID_MAX);<br>    <span class="hljs-keyword">return</span> pid - PID_MIN;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check if a PID entry is available</span><br><span class="hljs-comment"> * Must be called with pid_lock held</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">is_pid_available</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pid_entry *entry)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> entry-&gt;proc == <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Find next available PID starting from next_pid</span><br><span class="hljs-comment"> * Must be called with pid_lock held</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">pid_t</span> <br><span class="hljs-title function_">find_free_pid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> start = pid_to_index(next_pid);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = start;<br><br>    <span class="hljs-comment">/* Search for a free PID */</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (is_pid_available(&amp;pid_table[i])) &#123;<br>            <span class="hljs-keyword">return</span> PID_MIN + i;<br>        &#125;<br>        i = (i + <span class="hljs-number">1</span>) % PID_COUNT;<br>    &#125; <span class="hljs-keyword">while</span> (i != start);<br><br>    <span class="hljs-keyword">return</span> ENOPID;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Allocate a new PID and associate it with the given process</span><br><span class="hljs-comment"> * Returns allocated PID on success, ENOPID on failure</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pid_t</span> <br><span class="hljs-title function_">pid_allocate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *proc)</span> <br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> index;<br><br>    KASSERT(proc != <span class="hljs-literal">NULL</span>);<br><br>    spinlock_acquire(&amp;pid_lock);<br><br>    <span class="hljs-comment">/* Check if we&#x27;ve reached maximum PIDs */</span><br>    <span class="hljs-keyword">if</span> (pid_count &gt;= PID_COUNT) &#123;<br>        spinlock_release(&amp;pid_lock);<br>        <span class="hljs-keyword">return</span> ENOPID;<br>    &#125;<br><br>    <span class="hljs-comment">/* Find next available PID */</span><br>    pid = find_free_pid();<br>    <span class="hljs-keyword">if</span> (pid == ENOPID) &#123;<br>        spinlock_release(&amp;pid_lock);<br>        <span class="hljs-keyword">return</span> ENOPID;<br>    &#125;<br><br>    <span class="hljs-comment">/* Associate PID with process */</span><br>    index = pid_to_index(pid);<br>    KASSERT(pid_table[index].proc == <span class="hljs-literal">NULL</span>);<br>    pid_table[index].proc = proc;<br>    pid_count++;<br><br>    <span class="hljs-comment">/* Update next_pid to start search from next position */</span><br>    next_pid = (pid &lt; PID_MAX) ? (pid + <span class="hljs-number">1</span>) : PID_MIN;<br><br>    spinlock_release(&amp;pid_lock);<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get process structure associated with PID</span><br><span class="hljs-comment"> * Returns NULL if PID is invalid or not in use</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> proc *<br><span class="hljs-title function_">pid_get_proc</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span> <br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">/* Validate PID */</span><br>    <span class="hljs-keyword">if</span> (pid &lt; PID_MIN || pid &gt; PID_MAX) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    spinlock_acquire(&amp;pid_lock);<br>    <br>    <span class="hljs-type">int</span> index = pid_to_index(pid);<br>    p = pid_table[index].proc;<br>    <br>    spinlock_release(&amp;pid_lock);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Remove process from PID table </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">proc_remove_pid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *proc)</span> &#123;<br>    spinlock_acquire(&amp;pid_lock);<br>    pid_table[pid_to_index(proc-&gt;p_pid)].proc = <span class="hljs-literal">NULL</span>;<br>    pid_count--;<br>    spinlock_release(&amp;pid_lock);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="process-creationfork"><a class="markdownIt-Anchor" href="#process-creationfork"></a> Process creation(<code>fork</code>)</h3><p>Once we have our PID system ready, we can implement our <code>fork</code> logic: creating a new process, which is the exact same copy of the original process. Review the <code>sys_fork</code>'s responsibility above and understand what it should do.</p><p>Now let's break it down:</p><ol><li>Create a copy of the parent's <code>trapframe</code> to provide to the newly-created kernel thread for use.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create child trapframe copy</span><br>child_tf = kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br><span class="hljs-keyword">if</span> (child_tf == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> ENOMEM;<br>&#125;<br>*child_tf = *tf;<br></code></pre></td></tr></table></figure><ol start="2"><li>Create the child's <code>proc</code> structure <code>child_proc</code></li></ol><p>Remember that we need to create a new kernel thread to provide to the child process. Therefore, we first need to create the child's <code>proc</code> structure.</p><p>That's <code>proc_create_fork</code>'s responsibility! In this function, we need to make the exact same copy of the parent process: copy the file table and allocate a new PID.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create a fresh proc for use by fork. */</span><br><span class="hljs-keyword">struct</span> proc *<br><span class="hljs-title function_">proc_create_fork</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">newproc</span>;</span><br><br>newproc = proc_create(name);<br><span class="hljs-keyword">if</span> (newproc == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>    newproc-&gt;p_addrspace = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* Copy file table from parent process. */</span><br>    newproc-&gt;p_ft = filetable_copy(curproc-&gt;p_ft);<br>    <span class="hljs-keyword">if</span> (newproc-&gt;p_ft == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        proc_destroy(newproc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br><span class="hljs-comment">/* Allocate PID */</span><br>    newproc-&gt;p_pid = pid_allocate(newproc);<br>    <span class="hljs-keyword">if</span> (newproc-&gt;p_pid == ENOPID) &#123;<br>        proc_destroy(newproc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br><span class="hljs-comment">/* Set parent process for fork. */</span><br>newproc-&gt;p_parent = curproc;<br><br><span class="hljs-comment">/* Add to parent&#x27;s child array */</span><br><span class="hljs-keyword">if</span> (array_add(curproc-&gt;p_children, newproc, <span class="hljs-literal">NULL</span>)) &#123;<br>proc_destroy(newproc);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lock the current process to copy its current directory.</span><br><span class="hljs-comment"> * (We don&#x27;t need to lock the new process, though, as we have</span><br><span class="hljs-comment"> * the only reference to it.)</span><br><span class="hljs-comment"> */</span><br>spinlock_acquire(&amp;curproc-&gt;p_lock);<br><span class="hljs-keyword">if</span> (curproc-&gt;p_cwd != <span class="hljs-literal">NULL</span>) &#123;<br>VOP_INCREF(curproc-&gt;p_cwd);<br>newproc-&gt;p_cwd = curproc-&gt;p_cwd;<br>&#125;<br>spinlock_release(&amp;curproc-&gt;p_lock);<br><br><span class="hljs-keyword">return</span> newproc;<br>&#125;<br></code></pre></td></tr></table></figure><p>You may be confused with the <code>p_parent</code> and <code>p_children</code> fields in the code above. Don't worry, I will explain why we need those fields in <code>proc</code> structure when I explain my process wait and exit mechanism.</p><p>In <code>sys_fork</code>, we call <code>proc_create_fork</code> to get the child <code>proc</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create new process structure</span><br>child_proc = proc_create_fork(<span class="hljs-string">&quot;child&quot;</span>);<br><span class="hljs-keyword">if</span> (child_proc == <span class="hljs-literal">NULL</span>)<br>&#123;<br>    kfree(child_tf);<br>    <span class="hljs-keyword">return</span> ENOMEM;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>What's the difference between <code>proc_create_fork</code> and <code>proc_create_runprogram</code>?</p></blockquote><p><code>proc_create_fork</code> is called by <code>sys_fork</code>. In <code>proc_create_fork</code>, we create a new process that is the copy of the current process. Therefore, we need to copy the file table and add the new process to the current process's children array. <code>proc_create_runprogram</code> is called by the kernel to create a new process for use by <code>runprogram</code>. It will have no address space and will inherit the current process's (the kernel menu's) current directory.</p><ol start="3"><li>Copy address space</li></ol><p>Notice that in <code>proc_create_fork</code>, I didn't copy the parent's address space. I choose to do this in <code>sys_fork</code> after we get a child <code>proc</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy address space</span><br>result = as_copy(proc_getas(), &amp;child_as);<br><span class="hljs-keyword">if</span> (result)<br>&#123;<br>    proc_destroy(child_proc);<br>    kfree(child_tf);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Set up child process</span><br>child_proc-&gt;p_addrspace = child_as;<br></code></pre></td></tr></table></figure><ol start="4"><li>Create a new kernel thread</li></ol><p>Remember that we need to create a new kernel thread to provide to the child process so that the child and the parent can return to user mode in their own way.</p><p><code>thread_fork</code> is used to create a new thread to provide to the forked process. It needs to have an <code>entrypoint</code> where the new thread starts executing. Remember that the new thread needs to tweak <code>trapframe</code> to make sure the child has a different return value and return to user mode in a different manner than the parent. This function is performed by <code>enter_forked_process</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Create new thread for child process</span><br>result = thread_fork(<br>    curthread-&gt;t_name,<br>    child_proc,<br>    (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>))enter_forked_process,    <span class="hljs-comment">// New entry point function</span><br>    child_tf,           <span class="hljs-comment">// Pass child trapframe as data1</span><br>    <span class="hljs-number">0</span>                    <span class="hljs-comment">// Unused data2</span><br>);<br></code></pre></td></tr></table></figure><p>There we go! We find the <code>entrypoint</code> function for the new thread. Now it's time to implement <code>enter_forked_process</code>:</p><ol><li>Copy the child's <code>trapframe</code> to our kernel stack from the heap.</li><li>Tweak the child's <code>trapframe</code></li><li>Activate child process's address space</li><li>Enter user mode</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Enter user mode for a newly forked process.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function is provided as a reminder. You need to write</span><br><span class="hljs-comment"> * both it and the code that calls it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Thus, you can trash it and do things another way if you prefer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enter_forked_process</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trapframe *tf)</span></span><br><span class="hljs-function"></span>&#123;<br>(<span class="hljs-type">void</span>)tf;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">trapframe</span> child_tf; <span class="hljs-comment">// create child&#x27;s trapframe on the stack</span><br><br><span class="hljs-comment">// Copy trapframe to our kernel stack</span><br>child_tf = *tf;<br><br><span class="hljs-built_in">kfree</span>(tf);<br><br><span class="hljs-comment">// Child process returns 0 from fork()</span><br>child_tf.tf_v0 = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* signal no error */</span><br>child_tf.tf_a3 = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// Advance to next instruction</span><br>child_tf.tf_epc += <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// Activate child&#x27;s address space</span><br><span class="hljs-built_in">as_activate</span>();<br><br><span class="hljs-comment">// Enter user mode with child&#x27;s trapframe</span><br><span class="hljs-built_in">mips_usermode</span>(&amp;child_tf);<br><br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;enter_forked_process: mips_usermode returned\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Have you thought about why we need the trouble to first copy parent's <code>trapframe</code> onto the heap and then copy it to the kernel stack from the heap?</p></blockquote><p>Because parent's <code>trapframe</code> is on its stack and will be destroyed as soon as it returns from trap. In the mean time, our newly-created kernel thread run concurrently and may lose the <code>trapframe</code> if the parent returns from trap too early. That's why we need to save a copy of the <code>trapframe</code> on the heap before the parent returns.</p><ol start="5"><li>Parent returns from trap</li></ol><p>While the child returns via the <code>mips_usermode</code> function in its own kernel thread. The parent just returns from trap(<code>mips_trap</code>) with the return value of its child's PID.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Parent returns child&#x27;s PID</span><br>*retval = child_proc-&gt;p_pid;<br></code></pre></td></tr></table></figure><p>The complete code of <code>sys_fork</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trapframe *tf, <span class="hljs-type">pid_t</span> *retval)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">child_tf</span>;</span>  <span class="hljs-comment">// Child&#x27;s trapframe</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrspace</span> *<span class="hljs-title">child_as</span>;</span>  <span class="hljs-comment">// Child&#x27;s address space</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">child_proc</span>;</span>     <span class="hljs-comment">// Child process</span><br>    <span class="hljs-type">int</span> result;<br><br>    <span class="hljs-comment">// Create child trapframe copy</span><br>    child_tf = kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>    <span class="hljs-keyword">if</span> (child_tf == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ENOMEM;<br>    &#125;<br>    *child_tf = *tf;<br><br>    <span class="hljs-comment">// Create new process structure</span><br>    child_proc = proc_create_fork(<span class="hljs-string">&quot;child&quot;</span>);<br>    <span class="hljs-keyword">if</span> (child_proc == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(child_tf);<br>        <span class="hljs-keyword">return</span> ENOMEM;<br>    &#125;<br><br>    <span class="hljs-comment">// Copy address space</span><br>    result = as_copy(proc_getas(), &amp;child_as);<br>    <span class="hljs-keyword">if</span> (result)<br>    &#123;<br>        proc_destroy(child_proc);<br>        kfree(child_tf);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// Set up child process</span><br>    child_proc-&gt;p_addrspace = child_as;<br><br>    <span class="hljs-comment">// Create new thread for child process</span><br>    result = thread_fork(<br>        curthread-&gt;t_name,<br>        child_proc,<br>        (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>))enter_forked_process,    <span class="hljs-comment">// New entry point function</span><br>        child_tf,           <span class="hljs-comment">// Pass child trapframe as data1</span><br>        <span class="hljs-number">0</span>                    <span class="hljs-comment">// Unused data2</span><br>    );<br><br>    <span class="hljs-keyword">if</span> (result)<br>    &#123;<br>        proc_destroy(child_proc);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// Parent returns child&#x27;s PID</span><br>    *retval = child_proc-&gt;p_pid;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="process-wait-and-exit-mechanism"><a class="markdownIt-Anchor" href="#process-wait-and-exit-mechanism"></a> Process wait and exit mechanism</h3><p>This assignment gives us the freedom to design the <strong>process wait and exit mechanism</strong>. The assignment handout says:</p><blockquote><p>Most of the time, the code for <code>_exit()</code> will be simple and the code for <code>waitpid()</code> relatively complicated.</p></blockquote><p>However, my design requires a more complex <code>_exit</code> than <code>waitpid</code>. Maybe it is not the best design, but it is a working design!</p><p>Now let's break down my design:</p><blockquote><p>The crux of the problem:</p><ol><li>When should the process be cleaned up?</li><li>How to implement the mechanism for the parent process to wait for its child to exit?</li><li>How to kill a process when it encounters an error.</li></ol></blockquote><ul><li><strong>Process cleanup mechanism</strong></li></ul><p>The main problem is that when a process exits, it should not be cleaned up right away. Instead, it should become <code>zombie</code> until its parent process call <code>waitpid</code> to collect its exit code.</p><p>Therefore, my first thought is to clean up the child process as soon as its parent collects its exit code.</p><blockquote><p>However, that bring us a new problem:</p><p>What if the parent process never calls <code>waitpid</code> before it exits? Or the parent exits before its child exits? How to prevent its <code>zombie</code> child from hanging forever?</p></blockquote><p>My solution to this problem is to delay the child process's cleanup until the parent process exits. That is to say, when a process exits, it should traverse all of its children, clean up zombie children( exit code already be collected) and make running children(haven't yet exited) become orphans. Those orphan processes would be cleaned up right away as soon as they exits(skip the process of becoming <code>zombies</code>).</p><p>After handling its children, the process should check if itself is orphaned. If so, just clean itself up(in <code>thread_exit</code>. If not, signal its parent and becomes <code>zombie</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// In `thread_exit`</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * The code below is a bit more complex than it needs to be.</span><br><span class="hljs-comment"> * Actually, it only needs to check current process is orphaned</span><br><span class="hljs-comment"> * before clean it up. I add some additional check just for</span><br><span class="hljs-comment"> * robustness.</span><br><span class="hljs-comment"> */</span><br><br>...<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Clean up process if:</span><br><span class="hljs-comment"> * 1. This is the last thread AND</span><br><span class="hljs-comment"> * 2. One of the following is true:</span><br><span class="hljs-comment"> *    - Process is marked DEAD (normal case) OR</span><br><span class="hljs-comment"> *    - Process has no parent (orphaned case)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>    lock_acquire(p-&gt;p_mutex);<br>    <span class="hljs-keyword">if</span> (threadarray_num(&amp;p-&gt;p_threads) == <span class="hljs-number">0</span> &amp;&amp; <br>        (p-&gt;p_state == PROC_DEAD || p-&gt;p_parent == <span class="hljs-literal">NULL</span>)) &#123;<br>        lock_release(p-&gt;p_mutex);<br><br>        <span class="hljs-comment">/* Clean up process */</span><br>        proc_remove_pid(p);<br>        proc_destroy(p);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        lock_release(p-&gt;p_mutex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Now this explains why I maintain a <code>p_parent</code> and <code>p_children</code> field in <code>proc</code> structure.</p><p>The flow chart below shows the normal life of a process:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">PROC_RUNNING -&gt; <span class="hljs-function"><span class="hljs-params">(PROC_ZOMBIE)</span> -&gt;</span> PROC_DEAD &amp; proc_destroy &amp; proc_remove_pid -&gt; PID <span class="hljs-keyword">is</span> avaiable<br></code></pre></td></tr></table></figure><p>The complete code of <code>sys__exit</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Exit system call.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sys__exit</span><span class="hljs-params">(<span class="hljs-type">int</span> exitcode)</span><br>&#123;<br>    KASSERT(curproc != <span class="hljs-literal">NULL</span>);<br>    KASSERT(curproc != kproc); <span class="hljs-comment">/* Kernel process cannot exit */</span><br><br>    <span class="hljs-comment">/* Get the lock */</span><br>    lock_acquire(curproc-&gt;p_mutex);<br><br>    <span class="hljs-comment">/* Set exit code and change state to zombie */</span><br>    curproc-&gt;p_exitcode = _MKWAIT_EXIT(exitcode);<br>    curproc-&gt;p_state = PROC_ZOMBIE;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Handle children</span><br><span class="hljs-comment">     * - zombies and dead children get cleaned up immediately,</span><br><span class="hljs-comment">     * - running processes become orphans that clean themselves up</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">child</span>;</span><br>    <span class="hljs-keyword">while</span> (array_num(curproc-&gt;p_children) &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        child = array_get(curproc-&gt;p_children, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">if</span> (child-&gt;p_state == PROC_ZOMBIE || child-&gt;p_state == PROC_DEAD)<br>        &#123;<br>            KASSERT(array_num(child-&gt;p_children) == <span class="hljs-number">0</span>);<br><br>            child-&gt;p_state = PROC_DEAD;<br><br>            <span class="hljs-comment">/* Remove from children array */</span><br>            array_remove(curproc-&gt;p_children, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">/* Clean up the zombie/dead child */</span><br>            proc_remove_pid(child);<br>            proc_destroy(child);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* Mark as orphaned - will self-cleanup when done */</span><br>            child-&gt;p_parent = <span class="hljs-literal">NULL</span>;<br><br>            <span class="hljs-comment">/* Remove from children array */</span><br>            array_remove(curproc-&gt;p_children, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* Signal parent if we have one, otherwise self-cleanup */</span><br>    <span class="hljs-keyword">if</span> (curproc-&gt;p_parent != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        cv_signal(curproc-&gt;p_cv, curproc-&gt;p_mutex); <span class="hljs-comment">// Wake up waiting parent</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* Orphaned process cleans itself up */</span><br>        curproc-&gt;p_state = PROC_DEAD;<br>    &#125;<br><br>    lock_release(curproc-&gt;p_mutex);<br><br>    thread_exit();<br><br>    <span class="hljs-comment">/* Should never get here */</span><br>    panic(<span class="hljs-string">&quot;sys__exit: thread_exit returned\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Process wait mechanism</strong></li></ul><p><code>waitpid</code> is called by the parent process to wait for its child process to exit. When the child process exits, it signals its parent. My design is to let the parent process wait on its child's condition variable. When the child exits, it wakes up the parent.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// In `sys_waitpid`</span><br><br>...<br><span class="hljs-comment">/* Wait for child to exit */</span><br><span class="hljs-keyword">while</span> (child-&gt;p_state == PROC_RUNNING) &#123;<br>    cv_wait(child-&gt;p_cv, child-&gt;p_mutex);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// In `sys__exit`</span><br><br>...<br><span class="hljs-comment">/* Signal parent if we have one, otherwise self-cleanup */</span><br><span class="hljs-keyword">if</span> (curproc-&gt;p_parent != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    cv_signal(curproc-&gt;p_cv, curproc-&gt;p_mutex); <span class="hljs-comment">// Wake up waiting parent</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">/* Orphaned process cleans itself up */</span><br>    curproc-&gt;p_state = PROC_DEAD;<br>&#125;<br></code></pre></td></tr></table></figure><p>Special case: recall that in my process cleanup mechanism, we clean up zombie children when the parent process exits. But if current process is the kernel process, it does not exit. Therefore, we need to clean up its child right after it collects its child's exit code in <code>waitpid</code>.</p><p>As in fact, the kernel does need to wait for its child to exit in OS/161 and we need to implement that logic:</p><p>In OS/161, the kernel thread, (or menu thread), after it gets command arguments from the command line, it goes into <code>common_prog</code>. In <code>common_prog</code>, it creates a new thread to provide to the new program. We need to make it wait for the subprogram to finish(exit) before allowing it to return to menu.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// In `common_prog`</span><br><br>...<br><span class="hljs-comment">/* Save the pid before we fork */</span><br>pid = proc-&gt;p_pid;<br><br>result = thread_fork(args[<span class="hljs-number">0</span>] <span class="hljs-comment">/* thread name */</span>,<br>                     proc <span class="hljs-comment">/* new process */</span>,<br>                     cmd_progthread <span class="hljs-comment">/* thread function */</span>,<br>                     args <span class="hljs-comment">/* thread arg */</span>, nargs <span class="hljs-comment">/* thread arg */</span>);<br><span class="hljs-keyword">if</span> (result) &#123;<br>    kprintf(<span class="hljs-string">&quot;thread_fork failed: %s\n&quot;</span>, strerror(result));<br>    proc_destroy(proc);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The new process will be destroyed when the program exits...</span><br><span class="hljs-comment"> * once you write the code for handling that.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Wait for the subprogram to finish */</span><br>result = sys_waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;result);<br><span class="hljs-keyword">if</span> (result) &#123;<br>    kprintf(<span class="hljs-string">&quot;waitpid failed: %s\n&quot;</span>, strerror(result));<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// Return to menu</span><br></code></pre></td></tr></table></figure><p>The complete code of <code>sys_waitpid</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Waitpid system call.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">userptr_t</span> status, <span class="hljs-type">int</span> options, <span class="hljs-type">int</span> *retval)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">child</span>;</span><br>    <span class="hljs-type">int</span> exitcode;<br>    <br>    <span class="hljs-comment">/* Check for invalid options */</span><br>    <span class="hljs-keyword">if</span> (options != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> EINVAL;<br>    &#125;<br>    <br>    <span class="hljs-comment">/* Get the child process */</span><br>    child = pid_get_proc(pid);<br>    <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> ESRCH;  <span class="hljs-comment">/* No such process */</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/* Verify this is our child */</span><br>    lock_acquire(child-&gt;p_mutex);<br>    <span class="hljs-keyword">if</span> (child-&gt;p_parent != curproc) &#123;<br>        lock_release(child-&gt;p_mutex);<br>        <span class="hljs-keyword">return</span> ECHILD;  <span class="hljs-comment">/* Not a child of calling process */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* Wait for child to exit */</span><br>    <span class="hljs-keyword">while</span> (child-&gt;p_state == PROC_RUNNING) &#123;<br>        cv_wait(child-&gt;p_cv, child-&gt;p_mutex);<br>    &#125;<br><br>    <span class="hljs-comment">/* Get exit status while holding the lock */</span><br>    exitcode = child-&gt;p_exitcode;<br>    child-&gt;p_state = PROC_DEAD;<br><br>    lock_release(child-&gt;p_mutex);<br><br>    <span class="hljs-keyword">if</span> (curproc == kproc) &#123;<br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">         * If we&#x27;re the kernel, we do not exit, so we need to</span><br><span class="hljs-comment">         * clean up the child process here.</span><br><span class="hljs-comment">         */</span><br>        proc_remove_pid(child);<br>        proc_destroy(child);<br>    &#125;<br><br>    <span class="hljs-comment">/* Now copy out exit status if requested */</span><br>    <span class="hljs-keyword">if</span> (status != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">int</span> result = copyout(&amp;exitcode, status, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span> (result) &#123;<br>            <span class="hljs-keyword">return</span> EFAULT;<br>        &#125;<br>    &#125;<br>    <br>    *retval = pid;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Kill a process</strong></li></ul><p>When a user process hits a fatal fault, we need to kill it. But instead of crashing the entire kernel, we need to signal parent of its death and clean it up neatly.</p><p>This is very much like normal <code>_exit</code>, except that we need to set exit code to signal death.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Set exit code for signal death */</span><br>curproc-&gt;p_exitcode = _MKWAIT_SIG(sig);<br></code></pre></td></tr></table></figure><p>The complete code of <code>kill_curthread</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// In `kill_curthread`</span><br><br>...<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We have faced a fatal fault in user-level code, instead of</span><br><span class="hljs-comment"> * crashing the entire kernel. We need to clean up the process</span><br><span class="hljs-comment"> * and signal the parent if necessary.</span><br><span class="hljs-comment"> */</span><br><br>kprintf(<span class="hljs-string">&quot;Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n&quot;</span>,<br>        code, sig, trapcodenames[code], epc, vaddr);<br><br>KASSERT(curproc != <span class="hljs-literal">NULL</span>);<br>KASSERT(curproc != kproc); <span class="hljs-comment">/* Kernel process cannot be killed */</span><br><br><span class="hljs-comment">/* Get the lock */</span><br>lock_acquire(curproc-&gt;p_mutex);<br><br><span class="hljs-comment">/* Set exit code for signal death and change state to zombie */</span><br>curproc-&gt;p_exitcode = _MKWAIT_SIG(sig);<br>curproc-&gt;p_state = PROC_ZOMBIE;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Handle children</span><br><span class="hljs-comment">     * - zombies and dead children get cleaned up immediately,</span><br><span class="hljs-comment">     * - running processes become orphans that clean themselves up</span><br><span class="hljs-comment">     */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">child</span>;</span><br><span class="hljs-keyword">while</span> (array_num(curproc-&gt;p_children) &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    child = array_get(curproc-&gt;p_children, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (child-&gt;p_state == PROC_ZOMBIE || child-&gt;p_state == PROC_DEAD)<br>    &#123;<br>        KASSERT(array_num(child-&gt;p_children) == <span class="hljs-number">0</span>);<br><br>        child-&gt;p_state = PROC_DEAD;<br><br>        <span class="hljs-comment">/* Remove from children array */</span><br>        array_remove(curproc-&gt;p_children, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">/* Clean up the zombie/dead child */</span><br>        proc_remove_pid(child);<br>        proc_destroy(child);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* Mark as orphaned - will self-cleanup when done */</span><br>        child-&gt;p_parent = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">/* Remove from children array */</span><br>        array_remove(curproc-&gt;p_children, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* Signal parent if we have one, otherwise self-cleanup */</span><br><span class="hljs-keyword">if</span> (curproc-&gt;p_parent != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    cv_signal(curproc-&gt;p_cv, curproc-&gt;p_mutex); <span class="hljs-comment">// Wake up waiting parent</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">/* Orphaned process cleans itself up */</span><br>    curproc-&gt;p_state = PROC_DEAD;<br>&#125;<br><br>lock_release(curproc-&gt;p_mutex);<br><br>thread_exit();<br><br><span class="hljs-comment">/* Should never reach here */</span><br>panic(<span class="hljs-string">&quot;thread_exit returned in kill_curthread!\n&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="program-replacementexecv"><a class="markdownIt-Anchor" href="#program-replacementexecv"></a> Program replacement(<code>execv</code>)</h3><p>We often needs to replace the currently executing program, (probably in a newly-forked process) with a newly-loaded program image(with completely new address space and executable).</p><p>That's the job of <code>execv</code>! This is also the most tricky system call we need to implement in the entire OS/161. Review the <code>sys_execv</code>'s responsibility above and understand what it should do.</p><p>I break it down into 4 parts:</p><ol><li><code>Copyin</code> the arguments from the old address space</li><li>Load the new program image</li><li><code>Copyout</code> the arguments into the new address space</li><li>Clean the old address space and return</li></ol><p><code>Copyin</code> and <code>Copyout</code> arguments are the most tricky parts, you can really mess up with those pointers! It is important to emphasize it again that we need to pass both the arguments(strings) and the pointers pointing to those arguments(strings).</p><p><img src="../imgs/202502170921959.png" alt="" /></p><ul><li><strong><code>Copyin</code> arguments from user space</strong></li></ul><div class="note note-primary">            <p>It's important to emphasize that we need to pass not only the arguments, but also the pointers to those arguments.</p>          </div><p><img src="../imgs/202411041449905-1740473621641-7.png" alt="" /></p><p><img src="../imgs/202411041450806-1740473621641-9.png" alt="" /></p><p>First of all, I've defined two variables. <code>kargbuf</code> stores arguments(strings) in contiguous space(each individual string is stored in 4-bytes aligned address) and <code>kargs</code> stores the pointers array, pointing to individual strings in <code>kargbuf</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> **kargs;    <span class="hljs-comment">// Kernel buffer for args array</span><br><span class="hljs-type">char</span> *kargbuf;   <span class="hljs-comment">// Kernel buffer for arg strings</span><br></code></pre></td></tr></table></figure><p>Next, we need to know the number of arguments(strings) and the total bytes needed for strings, so that we can reserve space on the kernel heap to incept them.</p><ol><li>Number of arguments(strings)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* First, count the number of arguments */</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>    <span class="hljs-type">userptr_t</span> arg;<br>    result = copyin((<span class="hljs-type">const_userptr_t</span>)&amp;args[nargs], &amp;arg, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">userptr_t</span>));<br>    <span class="hljs-keyword">if</span> (result)<br>    &#123;<br>        <span class="hljs-keyword">goto</span> err1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (arg == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">break</span>;<br>    nargs++;<br>&#125;<br><br><span class="hljs-comment">/* Allocate kernel args array */</span><br><span class="hljs-keyword">if</span> (nargs &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    kargs = kmalloc(nargs * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span> *));<br>    <span class="hljs-keyword">if</span> (kargs == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        result = ENOMEM;<br>        <span class="hljs-keyword">goto</span> err1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>After we know the number of arguments(strings) and reserve the space for <code>kargs</code>, we copy the array of argument pointers from user space to <code>kargs</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Copy the array of argument pointers from user space */</span><br>result = copyin((<span class="hljs-type">const_userptr_t</span>)args, kargs, nargs * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span> *));<br><span class="hljs-keyword">if</span> (result)<br>&#123;<br>    <span class="hljs-keyword">goto</span> err2;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>Note that now the <code>karg</code> array store the pointers pointing to user address space. After we copy the arguments(strings) into the kernel, we need to make those pointers pointing to the arguments inside the kernel.</p>          </div><ol start="2"><li>Total bytes for arguments(strings)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Calculate total bytes needed for strings */</span><br>total_bytes = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nargs; i++)<br>&#123;<br>    <span class="hljs-type">size_t</span> len;<br>    <span class="hljs-type">char</span> temp_buf;<br>    result = copyinstr((<span class="hljs-type">const_userptr_t</span>)kargs[i], &amp;temp_buf, ARG_MAX, &amp;len);<br>    <span class="hljs-keyword">if</span> (result)<br>    &#123;<br>        <span class="hljs-keyword">goto</span> err2;<br>    &#125;<br>    total_bytes += ROUNDUP(len, <span class="hljs-number">4</span>); <span class="hljs-comment">// Align to 4 bytes</span><br>&#125;<br><br><span class="hljs-comment">/* Check if total size exceeds ARG_MAX */</span><br><span class="hljs-keyword">if</span> (total_bytes &gt; ARG_MAX)<br>&#123;<br>    result = E2BIG;<br>    <span class="hljs-keyword">goto</span> err2;<br>&#125;<br><br><span class="hljs-comment">/* Allocate buffer for argument strings */</span><br>kargbuf = kmalloc(total_bytes);<br><span class="hljs-keyword">if</span> (kargbuf == <span class="hljs-literal">NULL</span>)<br>&#123;<br>    result = ENOMEM;<br>    <span class="hljs-keyword">goto</span> err2;<br>&#125;<br></code></pre></td></tr></table></figure><p>After we know the total bytes needed for arguments(strings) and reserve space for <code>kargbuf</code>, we copy the arguments(strings) into <code>kargbuf</code> and make pointers in <code>kargs</code> pointing to the new locations(in kernel) of the arguments.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Copy strings to kernel buffer */</span><br><span class="hljs-type">char</span> *bufptr = kargbuf;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nargs; i++)<br>&#123;<br>    <span class="hljs-type">size_t</span> len;<br>    <span class="hljs-comment">/* Copy string from user space */</span><br>    result = copyinstr((<span class="hljs-type">const_userptr_t</span>)kargs[i], bufptr, ARG_MAX, &amp;len);<br>    <span class="hljs-keyword">if</span> (result)<br>    &#123;<br>        <span class="hljs-keyword">goto</span> err3;<br>    &#125;<br>    kargs[i] = bufptr; <span class="hljs-comment">/* Store pointer to string in kernel array */</span><br>    bufptr += ROUNDUP(len, <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Load the new program image</strong></li></ul><ol><li>Create and switch to the new address space</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create new address space */</span><br>new_as = as_create();<br><span class="hljs-keyword">if</span> (new_as == <span class="hljs-literal">NULL</span>)<br>&#123;<br>    result = ENOMEM;<br>    vfs_close(v);<br>    <span class="hljs-keyword">goto</span> err3;<br>&#125;<br><br><span class="hljs-comment">/* Switch to new address space */</span><br>old_as = proc_setas(new_as);<br>as_activate();<br></code></pre></td></tr></table></figure><ol start="2"><li>Open and load the new executable</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Copy the program path and verify it */</span><br>kprogram = kmalloc(PATH_MAX);<br><span class="hljs-keyword">if</span> (kprogram == <span class="hljs-literal">NULL</span>)<br>&#123;<br>    result = ENOMEM;<br>    <span class="hljs-keyword">goto</span> err1;<br>&#125;<br>result = copyinstr(program, kprogram, PATH_MAX, &amp;actual);<br><span class="hljs-keyword">if</span> (result)<br>&#123;<br>    <span class="hljs-keyword">goto</span> err1;<br>&#125;<br><br><span class="hljs-comment">/* Open the executable */</span><br>result = vfs_open(kprogram, O_RDONLY, <span class="hljs-number">0</span>, &amp;v);<br><span class="hljs-keyword">if</span> (result)<br>&#123;<br>    <span class="hljs-keyword">goto</span> err3;<br>&#125;<br><br><span class="hljs-comment">/* Load the new executable */</span><br>result = load_elf(v, &amp;entrypoint);<br>vfs_close(v);<br><span class="hljs-keyword">if</span> (result)<br>&#123;<br>    proc_setas(old_as);<br>    as_activate();<br>    as_destroy(new_as);<br>    <span class="hljs-keyword">goto</span> err3;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>Define a new stack region</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Define the user stack */</span><br>result = as_define_stack(new_as, &amp;stackptr);<br><span class="hljs-keyword">if</span> (result)<br>&#123;<br>    proc_setas(old_as);<br>    as_activate();<br>    as_destroy(new_as);<br>    <span class="hljs-keyword">goto</span> err3;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>Copyout</code> arguments to user stack</strong></li></ul><blockquote><p>How to copy the arguments to the new address space?</p></blockquote><p><img src="../imgs/202411041454332-1740464409429-5-1740473621644-15.png" alt="" /></p><p>We first obtain the initial <code>stackptr</code> via <code>as_define_stack</code>.</p><p>Next we calculate where the strings should begin:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Adjust stack pointer for strings */</span><br>stackptr -= total_bytes;<br>stackptr = ROUNDUP(stackptr - <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br><br><span class="hljs-comment">/* Remember where strings start */</span><br><span class="hljs-type">vaddr_t</span> strings_start = stackptr;<br></code></pre></td></tr></table></figure><p>Then copy the strings starting at <code>stackptr</code>(<code>strings_start</code>) and save the new user space address of the strings in <code>kargs</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Copy strings and save their user-space addresses in kargs */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nargs; i++)<br>&#123;<br>    <span class="hljs-type">size_t</span> got;<br>    <span class="hljs-comment">/* Copy string to user stack */</span><br>    result = copyoutstr((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)kargs[i], (<span class="hljs-type">userptr_t</span>)stackptr, ARG_MAX, &amp;got);<br>    <span class="hljs-keyword">if</span> (result) &#123; ... &#125;<br>    <span class="hljs-comment">/* Save user space address in kargs */</span><br>    kargs[i] = (<span class="hljs-type">char</span> *)stackptr;<br>    <span class="hljs-comment">/* Move to next aligned position */</span><br>    stackptr += ROUNDUP(got, <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Why do we need to save the strings' user space address?</p></blockquote><p>After we copy the strings to user space address, we also need to copy the pointers to those strings.</p><p>We first calculate where the pointers should begin. Note that the pointers should store below the strings, as the stack grows in the direction of low address.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> ptrs_space = (nargs + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">userptr_t</span>); <span class="hljs-comment">// +1 for NULL terminator</span><br><br><span class="hljs-comment">/* Adjust stack pointer for argv array */</span><br>stackptr = strings_start - ptrs_space;<br>stackptr = ROUNDUP(stackptr - <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>Then we copy the pointers (to the strings) starting at <code>stackptr</code>(This is also the final <code>stackptr</code> we need to pass to <code>enter_new_process</code> in order to enter user mode):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Copy out argv array */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nargs; i++)<br>&#123;<br>    result = copyout((<span class="hljs-type">const_userptr_t</span>)&amp;kargs[i], (<span class="hljs-type">userptr_t</span>)(stackptr + i * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">userptr_t</span>)), <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">userptr_t</span>));<br>    <span class="hljs-keyword">if</span> (result) &#123; ... &#125;<br>&#125;<br><br><span class="hljs-comment">/* Set the last pointer to NULL */</span><br><span class="hljs-type">void</span> *null_val = <span class="hljs-literal">NULL</span>;<br>result = copyout(&amp;null_val, (<span class="hljs-type">userptr_t</span>)(stackptr + nargs * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">userptr_t</span>)), <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">userptr_t</span>));<br><span class="hljs-keyword">if</span> (result) &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>This is the overview of user stack before we enter user mode:</p><p><img src="../imgs/202412151509009.jpg" alt="" /></p><ul><li><strong>Clean the old address space and return to user mode</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Clean up */</span><br>as_destroy(old_as);<br><span class="hljs-keyword">if</span> (kprogram)<br>    kfree(kprogram);<br><span class="hljs-keyword">if</span> (kargs)<br>    kfree(kargs);<br><span class="hljs-keyword">if</span> (kargbuf)<br>    kfree(kargbuf);<br><br><span class="hljs-comment">/* Enter user mode */</span><br>enter_new_process(nargs <span class="hljs-comment">/*argc*/</span>, (<span class="hljs-type">userptr_t</span>)stackptr <span class="hljs-comment">/*argv*/</span>, <span class="hljs-literal">NULL</span> <span class="hljs-comment">/*env*/</span>, stackptr, entrypoint);<br></code></pre></td></tr></table></figure><h2 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish!</h2><p>Those are the files I have modified/created. Do not get here unless you are stuck in coding!</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">* kern<span class="hljs-regexp">/arch/mi</span>ps<span class="hljs-regexp">/locore/</span>trap.c<br>* kern<span class="hljs-regexp">/include/</span>syscall.h<br>* kern<span class="hljs-regexp">/arch/mi</span>ps<span class="hljs-regexp">/syscall/</span>syscall.c<br>* kern<span class="hljs-regexp">/include/</span>pid.h<br>* kern<span class="hljs-regexp">/proc/</span>pid.c<br>* kern<span class="hljs-regexp">/include/</span>proc.h<br>* kern<span class="hljs-regexp">/proc/</span>proc.c<br>* kern<span class="hljs-regexp">/main/m</span>ain.c<br>* kern<span class="hljs-regexp">/main/m</span>enu.c<br>* kern<span class="hljs-regexp">/syscall/</span>_exit_syscalls.c<br>* kern<span class="hljs-regexp">/syscall/</span>waitpid_syscalls.c<br>* kern<span class="hljs-regexp">/syscall/g</span>etpid_syscalls.c<br>* kern<span class="hljs-regexp">/syscall/</span>execv_syscalls.c<br>* kern<span class="hljs-regexp">/syscall/</span>fork_syscalls.c<br>* kern<span class="hljs-regexp">/thread/</span>thread.c<br></code></pre></td></tr></table></figure><p>We have passed all tests in Assignment5!</p><img src="../imgs/image-20250225164450312-1740473621644-16.png" style="zoom:67%;" /><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">OS/<span class="hljs-number">161</span> kernel [? <span class="hljs-keyword">for</span> menu]: p testbin/crash<br>[a] read <span class="hljs-keyword">from</span> NULL<br>[b] read <span class="hljs-keyword">from</span> invalid address<br>[c] read <span class="hljs-keyword">from</span> kernel address<br>[d] write <span class="hljs-keyword">to</span> NULL<br>[e] write <span class="hljs-keyword">to</span> invalid address<br>[f] write <span class="hljs-keyword">to</span> code segment<br>[g] write <span class="hljs-keyword">to</span> kernel address<br>[h] jump <span class="hljs-keyword">to</span> NULL<br>[i] jump <span class="hljs-keyword">to</span> invalid address<br>[j] jump <span class="hljs-keyword">to</span> kernel address<br>[k] alignment <span class="hljs-keyword">error</span><br>[l] illegal instruction<br>[m] divide <span class="hljs-keyword">by</span> zero<br>[n] <span class="hljs-built_in">mod</span> <span class="hljs-keyword">by</span> zero<br>[o] Recurse infinitely<br>[*] Run everything (<span class="hljs-keyword">in</span> subprocesses)<br><span class="hljs-symbol">Note:</span> [f] may <span class="hljs-built_in">not</span> cause an exception <span class="hljs-keyword">on</span> some platforms, <span class="hljs-keyword">in</span> which<br><span class="hljs-keyword">case</span> it<span class="hljs-comment">&#x27;ll appear to fail.</span><br><span class="hljs-symbol">Choose:</span> Running: [a] read <span class="hljs-keyword">from</span> NULL<br>Fatal user mode trap <span class="hljs-number">2</span> sig <span class="hljs-number">11</span> (TLB miss <span class="hljs-keyword">on</span> load, epc <span class="hljs-number">0</span>x400310, vaddr <span class="hljs-number">0</span>x0)<br>Signal <span class="hljs-number">11</span> (correct)<br><span class="hljs-symbol">Running:</span> [b] read <span class="hljs-keyword">from</span> invalid address<br>Fatal user mode trap <span class="hljs-number">2</span> sig <span class="hljs-number">11</span> (TLB miss <span class="hljs-keyword">on</span> load, epc <span class="hljs-number">0</span>x40032c, vaddr <span class="hljs-number">0</span>x40000000)<br>Signal <span class="hljs-number">11</span> (correct)<br><span class="hljs-symbol">Running:</span> [c] read <span class="hljs-keyword">from</span> kernel address<br>Fatal user mode trap <span class="hljs-number">4</span> sig <span class="hljs-number">10</span> (Address <span class="hljs-keyword">error</span> <span class="hljs-keyword">on</span> load, epc <span class="hljs-number">0</span>x400348, vaddr <span class="hljs-number">0</span>x80000000)<br>Signal <span class="hljs-number">10</span> (correct)<br><span class="hljs-symbol">Running:</span> [d] write <span class="hljs-keyword">to</span> NULL<br>Fatal user mode trap <span class="hljs-number">3</span> sig <span class="hljs-number">11</span> (TLB miss <span class="hljs-keyword">on</span> store, epc <span class="hljs-number">0</span>x400364, vaddr <span class="hljs-number">0</span>x0)<br>Signal <span class="hljs-number">11</span> (correct)<br><span class="hljs-symbol">Running:</span> [e] write <span class="hljs-keyword">to</span> invalid address<br>Fatal user mode trap <span class="hljs-number">3</span> sig <span class="hljs-number">11</span> (TLB miss <span class="hljs-keyword">on</span> store, epc <span class="hljs-number">0</span>x400374, vaddr <span class="hljs-number">0</span>x40000000)<br>Signal <span class="hljs-number">11</span> (correct)<br><span class="hljs-symbol">Running:</span> [f] write <span class="hljs-keyword">to</span> code segment<br>I wasn<span class="hljs-comment">&#x27;t killed - test fails!</span><br><span class="hljs-keyword">Exit</span> <span class="hljs-number">1</span>; expected signal <span class="hljs-number">11</span><br><span class="hljs-symbol">Running:</span> [g] write <span class="hljs-keyword">to</span> kernel address<br>Fatal user mode trap <span class="hljs-number">5</span> sig <span class="hljs-number">10</span> (Address <span class="hljs-keyword">error</span> <span class="hljs-keyword">on</span> store, epc <span class="hljs-number">0</span>x400394, vaddr <span class="hljs-number">0</span>x80000000)<br>Signal <span class="hljs-number">10</span> (correct)<br><span class="hljs-symbol">Running:</span> [h] jump <span class="hljs-keyword">to</span> NULL<br>Fatal user mode trap <span class="hljs-number">2</span> sig <span class="hljs-number">11</span> (TLB miss <span class="hljs-keyword">on</span> load, epc <span class="hljs-number">0</span>x4003a0, vaddr <span class="hljs-number">0</span>x0)<br>Signal <span class="hljs-number">11</span> (correct)<br><span class="hljs-symbol">Running:</span> [i] jump <span class="hljs-keyword">to</span> invalid address<br>Fatal user mode trap <span class="hljs-number">2</span> sig <span class="hljs-number">11</span> (TLB miss <span class="hljs-keyword">on</span> load, epc <span class="hljs-number">0</span>x4003ac, vaddr <span class="hljs-number">0</span>x40000000)<br>Signal <span class="hljs-number">11</span> (correct)<br><span class="hljs-symbol">Running:</span> [j] jump <span class="hljs-keyword">to</span> kernel address<br>Fatal user mode trap <span class="hljs-number">4</span> sig <span class="hljs-number">10</span> (Address <span class="hljs-keyword">error</span> <span class="hljs-keyword">on</span> load, epc <span class="hljs-number">0</span>x4003b8, vaddr <span class="hljs-number">0</span>x80000000)<br>Signal <span class="hljs-number">10</span> (correct)<br><span class="hljs-symbol">Running:</span> [k] alignment <span class="hljs-keyword">error</span><br>Fatal user mode trap <span class="hljs-number">4</span> sig <span class="hljs-number">10</span> (Address <span class="hljs-keyword">error</span> <span class="hljs-keyword">on</span> load, epc <span class="hljs-number">0</span>x4003f0, vaddr <span class="hljs-number">0</span>x7fffffa9)<br>Signal <span class="hljs-number">10</span> (correct)<br><span class="hljs-symbol">Running:</span> [l] illegal instruction<br>Fatal user mode trap <span class="hljs-number">10</span> sig <span class="hljs-number">4</span> (Illegal instruction, epc <span class="hljs-number">0</span>x4003c0, vaddr <span class="hljs-number">0</span>x0)<br>Signal <span class="hljs-number">4</span> (correct)<br><span class="hljs-symbol">Running:</span> [m] divide <span class="hljs-keyword">by</span> zero<br>Fatal user mode trap <span class="hljs-number">9</span> sig <span class="hljs-number">5</span> (Break instruction, epc <span class="hljs-number">0</span>x40042c, vaddr <span class="hljs-number">0</span>x0)<br>Signal <span class="hljs-number">5</span> (correct)<br><span class="hljs-symbol">Running:</span> [n] <span class="hljs-built_in">mod</span> <span class="hljs-keyword">by</span> zero<br>Fatal user mode trap <span class="hljs-number">9</span> sig <span class="hljs-number">5</span> (Break instruction, epc <span class="hljs-number">0</span>x400468, vaddr <span class="hljs-number">0</span>x0)<br>Signal <span class="hljs-number">5</span> (correct)<br><span class="hljs-symbol">Running:</span> [o] Recurse infinitely<br>Fatal user mode trap <span class="hljs-number">3</span> sig <span class="hljs-number">11</span> (TLB miss <span class="hljs-keyword">on</span> store, epc <span class="hljs-number">0</span>x400488, vaddr <span class="hljs-number">0</span>x7ffedff0)<br>Signal <span class="hljs-number">11</span> (correct)<br>Operation took <span class="hljs-number">30.033709583</span> seconds<br></code></pre></td></tr></table></figure><img src="../imgs/image-20250225164904864-1740473621645-17.png" style="zoom:67%;" /><img src="../imgs/image-20250225164949387-1740473621645-18.png" alt="badcall" style="zoom: 67%;" /><p>We have finished Assignment5!😊</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>OS161</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>OS161</tag>
      
      <tag>System Calls</tag>
      
      <tag>Process Management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Processes and Threads</title>
    <link href="/2024/10/24/Processes-and-Threads/"/>
    <url>/2024/10/24/Processes-and-Threads/</url>
    
    <content type="html"><![CDATA[<p>In this part, we will cover the topics of processes, threads, context switch, pipes, file descriptors and some system calls that manage processes. This part is crucial for you to implementing OS/161 Assignment 4&amp;5 correctly!</p><h1 id="processes-and-threads"><a class="markdownIt-Anchor" href="#processes-and-threads"></a> Processes and Threads</h1><blockquote><p><strong>Learning Materials</strong></p><p>Videos:</p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/context-switching.mp4">Context switching</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/processes.mp4">Processes and threads</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/process-components.mp4">Process components</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/process-management.mp4">Process management</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/fork-exec.mp4">Fork and exec</a></p><p><a href="https://people.ece.ubc.ca/~os161/man/syscall/">OS161 man pages for the system calls you are implementing in A4.</a></p><p>Lecture Slides:</p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Implementing-system-calls.pptx">Implementing system calls</a></p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Processes-vs-threads.pptx">Processes and threads</a></p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Processes-file-tables.pptx">Processes and file descriptors</a></p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Processes-vs-threads.pptx">Processes and threads</a></p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Process-creation.pptx">Process creation: fork() and shared file objects</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/LECTURES-CODE/fork.c">fork.c</a>, <a href="https://people.ece.ubc.ca/~os161/download/LECTURES-CODE/pipes.c">pipes.c</a>, <a href="https://people.ece.ubc.ca/~os161/download/LECTURES-CODE/pipes2.c">pipes2.c</a>, <a href="https://people.ece.ubc.ca/~os161/download/LECTURES-CODE/pipes2.c">pipes-exec.c</a><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Process-exec.pptx">Processes: exec()</a>, <a href="https://people.ece.ubc.ca/~os161/download/LECTURES-CODE/exec.c">exec.c</a></p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Process-wait-exit.pptx">Processes: waitpid/exit</a></p><p>Readings:</p><p><a href="https://sites.google.com/view/cpen331fall2020/calendar/file-descriptors-in-unix">File descriptors in Unix</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/book-rev8.pdf">Chapter 2 in the xv6 book</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf">OSTEP] Introduction of the Unix process API (fork/exec, etc.)</a></p></blockquote><h2 id="context-switching"><a class="markdownIt-Anchor" href="#context-switching"></a> Context Switching</h2><blockquote><p><strong>terminology</strong>:</p><img src="../imgs/202410091638369.png" alt="" style="zoom: 50%;" /></blockquote><blockquote><p>What does the kernel do on a Trap?</p></blockquote><ol><li>The kernel finds a stack on which to run. (Every real* user-level thread has a corresponding kernel stack.)</li><li>The kernel saves state.</li><li>Figure out what caused the trap.</li></ol><hr /><h3 id="process-switch"><a class="markdownIt-Anchor" href="#process-switch"></a> Process Switch</h3><ol><li>change protection domain(user to kernel)</li><li>switch from using the user-level stack to using a kernel stack</li><li>save execution state <strong>on kernel's stack</strong></li><li>do kernel stuff</li><li>kernel thread switch</li><li>restore user-level execution state</li><li>change protection domain(kernel to user)</li></ol><hr /><h3 id="mips-r3000-hardware-in-trap-handling"><a class="markdownIt-Anchor" href="#mips-r3000-hardware-in-trap-handling"></a> MIPS R3000 Hardware in Trap Handling</h3><img src="../imgs/image-20241009221502551.png" alt="" style="zoom: 40%;" /><p>When a trap happens, the hardware saves <code>PC</code> into <code>exception PC</code>, and sets <code>PC</code> to the address of the trap handler(software program). The hardware also sets the <code>status</code> register and <code>cause</code> register.</p><p>As shown below, the left line of hardware registers need to be saved on the kernel stack(by trap handling software) and <code>K0</code> and <code>K1</code> are the two spare registers to achieve that.</p><img src="../imgs/202410092232867.png" alt="" style="zoom: 40%;" /><p>After hardware does its job, we let the trap handling software to do the rest.</p><hr /><h3 id="mips-r3000-software-in-trap-handling"><a class="markdownIt-Anchor" href="#mips-r3000-software-in-trap-handling"></a> MIPS R3000 Software in Trap Handling</h3><ol><li>Assembly code</li></ol><p>Use as few hareware registers as possible and save all the states that you need.</p><img src="../imgs/202410092220239.png" alt="" style="zoom:50%;" /><p>Create a <strong>trap frame</strong> on the kernel stack: <strong>Save away all the registers</strong> and start using these registers to execute something else.</p><blockquote><p>How to find the kernel stack to save the <code>trapframe</code>?</p></blockquote><p>Each processor(cpu) has its own kernel stack to save the <code>trapframe</code>.</p><p>Extract processor number from <code>K1</code>(<code>context</code> register) as an index(Base is in <code>K0</code>).</p><p>Add K1 to K0 so that K0 points to the stack for the current processor.</p><img src="../imgs/202410092310547.png" alt="" style="zoom: 40%;" /><ol start="2"><li>trap C code</li></ol><img src="../imgs/202410092226748.png" alt="" style="zoom:50%;" /><hr /><h3 id="syscall-details"><a class="markdownIt-Anchor" href="#syscall-details"></a> Syscall Details</h3><blockquote><p>How did we leave the arguments?</p></blockquote><p>First four in a0-a3; rest on the stack.</p><blockquote><p>How does the kernel deal with <code>fork</code> system call?</p></blockquote><ol><li>Make sure forking process is not running on user level.</li><li>Save all state from forking process.</li><li>Make a copy of the code, data, and stack.</li><li>Copy <code>trapframe</code> of the original process into the new one.</li><li>Make the new process known to the dispatcher</li></ol><blockquote><p>How does the kernel deal with <code>exec</code> system call?</p></blockquote><p>Replace the current program image with the code and data of a new program.</p><h2 id="processes-and-threads-2"><a class="markdownIt-Anchor" href="#processes-and-threads-2"></a> Processes and Threads</h2><p>Multithreaded process:</p><img src="../imgs/202410262233235.png" alt="" style="zoom: 50%;" /><p>User-level threads:</p><p>The stack of the additional thread is created on the heap by the user program.</p><img src="../imgs/202410262243094.png" alt="" style="zoom:50%;" /><blockquote><p>What comprises a process's state?</p></blockquote><p>1.Address space</p><p>2.Threads</p><p>3.Architectural state</p><p>4.File table</p><p>5.<strong>A kernel thread that gets assigned to a process when the process traps into the kernel</strong></p><p>We can think of user processes and kernel, each with multiple threads, as running in their own address spaces.</p><div class="note note-info">            <p>However, deep into the details, user address space often contains kernel mappings, which is only accessible when the processor is in kernel mode.</p>          </div><h2 id="pipes"><a class="markdownIt-Anchor" href="#pipes"></a> Pipes</h2><img src="../imgs/202409162140360.png" alt="" style="zoom:33%;" /><p>Mechanics:</p><p>The pipe file is just a memory buffer.</p><img src="../imgs/202410241127412.png" alt="" style="zoom:80%;" /><p>Redirecting Pipe I/O:</p><img src="../imgs/202410262357565.png" alt="" style="zoom:80%;" /><h2 id="process-components"><a class="markdownIt-Anchor" href="#process-components"></a> Process Components</h2><h3 id="parts-of-a-process-not-in-the-executable"><a class="markdownIt-Anchor" href="#parts-of-a-process-not-in-the-executable"></a> Parts of a process not in the Executable</h3><ul><li><strong>Execution state</strong></li></ul><p>Execution state is a snapshot of hardware, so it is hardware-specific</p><ul><li><strong>Resources</strong></li></ul><ol><li>File information</li></ol><p>Mutiple threads within a process share a file descriptor table.</p><ol start="2"><li>Scheduling information</li></ol><ul><li><p>How much time the process has used</p></li><li><p>its priority</p></li><li><p>resource consumption</p></li></ul><p>These information is provided to the scheduler for it to decide which process to run.</p><ul><li><p><strong>Address space</strong></p></li><li><p><strong>Other</strong></p></li></ul><ol><li>process id(PID)</li><li>credentials(what permissions/capabilities a process has)</li><li>signal information</li></ol><hr /><h3 id="process-data-structures"><a class="markdownIt-Anchor" href="#process-data-structures"></a> Process Data Structures</h3><blockquote><p>Which parts of the process are machine (in)dependent?</p></blockquote><blockquote><p>Which parts need to be per-thread and which are per-process?(although not necessary in os161 which only considers single-thread process)</p></blockquote><p>Prcess Control Block(<strong>PCB</strong>)</p><p>PCB encapsulates an entire process, which contains references to other structures:</p><ul><li>Address space</li><li>Threads associated with the process</li><li>Credentials</li></ul><p>All the PCBs are gathered together into a <strong>process table</strong>.</p><h2 id="file-descriptors-in-unix"><a class="markdownIt-Anchor" href="#file-descriptors-in-unix"></a> File descriptors in Unix</h2><h3 id="kernel-three-table-data-structure-for-open-files"><a class="markdownIt-Anchor" href="#kernel-three-table-data-structure-for-open-files"></a> Kernel three-table data structure for open files</h3><img src="../imgs/202410111635355.png" alt="" style="zoom: 67%;" /><ul><li>Table1: Process table</li></ul><p>Each process entry in the <strong>process table</strong> contains a <strong>file description table</strong>(a table of open file descriptors).</p><ul><li>Table2: Open file table</li></ul><p>The file descriptors index the entries in the file description table. Each entry contains a <strong>pointer</strong> to an entry in the <strong>open files table</strong>(a table that the kernel maintains for all open files).</p><p>Each entry in this open files table contains the <strong>file status flags</strong> (read, write, append, etc.), the current <strong>file offset</strong>, and a <strong>pointer</strong> to the entry for this file in the so-called <strong>v-node table</strong>.</p><ul><li>Table3: V-node table</li></ul><p>The v-node table (or part of it) is stored on the physical device. For now, you can think of its entries as the &quot;real'' file contents on a disk, with associated informations like file location on disk, size, name, owner, etc.</p><blockquote><p>What if two processes want to independently open the same physical file, i.e. with each process mantaining its own access mode (read, write or append) and file offset as well?</p></blockquote><p>Here the <strong>open file table has two independent entries for the same file</strong>, each associated to one of the processes.</p><img src="../imgs/202410111653805.png" alt="" style="zoom:60%;" /><blockquote><p>What if we need to have in one process <em>two</em> file descriptors opened for the same file?</p></blockquote><p>Duplication of file descriptors:</p><img src="../imgs/202410111701382.png" alt="" style="zoom:67%;" /><blockquote><p>How we achieve this?</p></blockquote><p>The <code>dup()</code> and <code>dup2()</code> system calls do this job.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* duplicate the passed file descriptor, returning the smallest available one. */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes)</span>;<br><span class="hljs-comment">/* specify in what file descriptor you want the copy */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">int</span> fildes2)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>Why we need the duplication of file descriptors?</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>    <span class="hljs-keyword">if</span> (fork()==<span class="hljs-number">0</span>)<br>    &#123;<br>        close(STDIN_FILENO); <br>        dup(datafd); <span class="hljs-comment">/* datafd duplicated in stdin */</span><br>        execlp(<span class="hljs-string">&quot;sed&quot;</span>, <span class="hljs-string">&quot;sed&quot;</span>, (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>);<br>        perror(<span class="hljs-string">&quot;sed&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>What is the problem of <code>dup()</code>? How we solve this?</p></blockquote><p>The close-and-duplicate sequence above is not atomic.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-keyword">if</span> (fork()==<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-comment">/* atomic operation */</span><br>    dup2(datafd, STDIN_FILENO);<br>    execlp(<span class="hljs-string">&quot;sed&quot;</span>, <span class="hljs-string">&quot;sed&quot;</span>, (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>);<br>    perror(<span class="hljs-string">&quot;sed&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>A potential failure case:</p><img src="../imgs/202410172312054.png" alt="" style="zoom: 60%;" /><p>This special case illustrates the need of the <strong>reference count</strong> field in the file object structure.</p><h2 id="fork-and-exec-process-creation"><a class="markdownIt-Anchor" href="#fork-and-exec-process-creation"></a> fork and exec (process creation)</h2><h3 id="the-oss-job-during-process-creation"><a class="markdownIt-Anchor" href="#the-oss-job-during-process-creation"></a> The OS's job during process creation</h3> <img src="../imgs/202410111821822.png" alt="" style="zoom: 50%;" /><p>Child processes share the same file descriptor table with the parent process, which is the basis of <strong>pipes</strong>.</p><hr /><h3 id="sys_fork"><a class="markdownIt-Anchor" href="#sys_fork"></a> <code>sys_fork</code></h3><p><code>sys_fork</code> is responsible for:</p><ol><li>Copy address space</li></ol><p>Use the functions in <code>addrspace.c</code>.</p><img src="../imgs/202410262300766.png" alt="" style="zoom:50%;" /><ol start="2"><li>Copy the file table</li></ol><p>When a process is forked, file descriptor entries of the new process point to the <strong>same file objects</strong> as in the parent process.</p><img src="../imgs/202410262300141.png" alt="" style="zoom:50%;" /><blockquote><p>What kind of race conditions do you have to worry about?</p></blockquote><p>Two processes simultaneously modifying the values of the offset.</p><blockquote><p>Can you hold a spinlock while doing I/O?</p></blockquote><p>Spinlocks turn off interrupts; I/O completion is signaled via an interrupt. If you turn off interrupts and then go do I/O, YOU WILL NEVER GET NOTIFIED!</p><blockquote><p>Hold a regular lock? That will work. But do we have to hold the lock?</p></blockquote><p>-- Not really. We can set up the <code>uio</code> struct with the right offset, release the lock, do the I/O, then acquire it again and update the offset if I/O was successful. Can’t update the offset prior to I/O completion – what if it fails?</p><ol start="3"><li>Copy architectural state(Copy and tweak <code>trapframe</code>)</li></ol><p>In the implementation of A5, you will have to make sure <strong>the right value is returned to the right process!</strong></p><ol start="4"><li>Copy kernel thread(<code>thread_fork</code>)</li></ol><p><strong>When you fork a new process, you fork a new kernel thread to provide to the child process.</strong></p><p><strong>To fork that thread, you need to provide it a function to run. You’ll need to write that function.</strong></p><ol start="5"><li>Return to user mode</li><li>Both the parent and child return to user mode</li></ol><p>The parent just returns from exception.</p><p>The child returns via the <code>usermode</code> function.</p><img src="../imgs/202410262324165.png" alt="" style="zoom: 67%;" /><blockquote><p>How does a thread enter user mode for the first time?</p></blockquote><p><code>mips_usermode</code> in <code>trap.c</code></p><hr /><h3 id="sys_execv"><a class="markdownIt-Anchor" href="#sys_execv"></a> <code>sys_execv</code></h3><p><code>sys_execv</code> is responsible for:</p><p>• Replace the old address space with a new one</p><p>• Copy the arguments into the new address space</p><p>• Return to user mode</p><p><strong>The mechanics of <code>exec()</code></strong>:</p><img src="../imgs/202411041428372.png" alt="" style="zoom: 67%;" /><p><strong>To think before starting exec():</strong></p><blockquote><p><strong>Where are the arguments located</strong> when the exec system call in invoked? In whose address space? How do you know their address?</p></blockquote><blockquote><p>How do we get them into the kernel? How do you figure out their total size?</p></blockquote><blockquote><p>Where do the arguments need to end up before we return to the user mode? Whose address space? Stack or heap?</p></blockquote><blockquote><p>How do we get them there? How do we organize them there.</p></blockquote><p><strong>Passing arguments(<code>copyin</code> and <code>copyout</code>)</strong>:</p><div class="note note-primary">            <p>It's important to emphasize that we need to pass not only the arguments, but also the pointers to those arguments.</p>          </div><img src="../imgs/202411041449905.png" alt="" style="zoom:67%;" /><img src="../imgs/202411041450806.png" alt="" style="zoom:67%;" /><blockquote><p>What if the arguments array is huge and you cannot allocate enough kernel memory contiguously?</p></blockquote><img src="../imgs/202411041454332.png" alt="" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>File Descriptor</tag>
      
      <tag>Process</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS161 Assignment 4</title>
    <link href="/2024/10/22/OS161-A4/"/>
    <url>/2024/10/22/OS161-A4/</url>
    
    <content type="html"><![CDATA[<h1 id="assignment4"><a class="markdownIt-Anchor" href="#assignment4"></a> Assignment4</h1><blockquote><p>In this assignment you will implement a few <strong>system calls that allow user programs to use files</strong>. This assignment will further train you how to navigate and understand a large and complex source base, and will teach you how to implement system calls and transfer control between the user mode and the kernel. You will implement part of the process management subsystem, which will be the subject of the next assignment.</p></blockquote><h2 id="code-reading-exercises"><a class="markdownIt-Anchor" href="#code-reading-exercises"></a> Code reading exercises</h2><blockquote><ol><li>What are the ELF magic numbers?</li></ol></blockquote><p>The ELF (Executable and Linkable Format) magic numbers are a sequence of bytes <strong>(0x7f, 'E', 'L', 'F')</strong> at the beginning of an ELF file that identify it as an ELF file and provide some basic information about its format.</p><p>These magic numbers help operating systems and other tools quickly identify ELF files and determine their basic characteristics without having to parse the entire file structure.</p><blockquote><ol start="2"><li>What is the difference between <code>UIO_USERISPACE</code> and <code>UIO_USERSPACE</code>? When should one use UIO_SYSSPACE instead?</li></ol></blockquote><p>The <code>enum uio_seg</code> is typically used in Unix-like operating systems to specify the memory segment for I/O operations.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Source/destination. */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">uio_seg</span> &#123;</span><br>        UIO_USERISPACE,<span class="hljs-comment">/* User process code. */</span><br>        UIO_USERSPACE,<span class="hljs-comment">/* User process data. */</span><br>        UIO_SYSSPACE,<span class="hljs-comment">/* Kernel. */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>UIO_USERISPACE</code>(User process instruction space) refers to the memory segment where the user process's executable code (instructions) resides.</p><p><code>UIO_USERSPACE</code>(User process data space) refers to the memory segment where the user process's data resides.</p><p><code>UIO_SYSSPACE</code> is used when the memory being accessed is in kernel space rather than user space. It is typically used within kernel code or drivers when performing I/O operations on kernel-owned memory.</p><blockquote><ol start="3"><li>Why can the struct <code>uio</code> that is used to read in a segment be allocated on the stack in <code>load_segment()</code> (i.e., where does the memory read actually go)?</li></ol></blockquote><p>The <code>uio</code> structure describes an I/O operation that will read data from the file (<code>vnode v</code>) into the user's address space at <code>vaddr</code>.</p><p>The struct <code>uio</code> is allocated on the stack in the <code>load_segment()</code> function. This is fine because the structure is just used to describe the I/O operation, not to hold the actual data being read. The actual read operation (<code>VOP_READ</code>) will use this information to copy the data directly into the user's address space.</p><p>The key is in this line:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">iov.iov_ubase = (<span class="hljs-type">userptr_t</span>)vaddr;<br></code></pre></td></tr></table></figure><p>Here, <code>vaddr</code> is the virtual address in the user's address space where the segment should be loaded.</p><blockquote><ol start="4"><li>In <code>runprogram()</code>, why is it important to call <code>vfs_close()</code> before going to user mode?</li></ol></blockquote><p>Once the program is loaded, there's no need for the kernel to maintain access to the executable file. Closing the file before going to user mode ensures that the new user process doesn't have unnecessary open file handles.</p><blockquote><ol start="5"><li>What function forces the processor to switch into user mode? Is this function machine dependent?</li></ol></blockquote><p>The function that forces the processor to switch into user mode is: <code>mips_usermode()</code>, which calls <code>asm_usermode()</code>.</p><p>This function is machine dependent. Specifically, it's designed for the MIPS architecture.</p><blockquote><ol start="6"><li>In what file are <code>copyin</code> and <code>copyout</code> defined? <code>memmove</code>? Why can't <code>copyin</code> and <code>copyout</code> be implemented as simply as <code>memmove</code>?</li></ol></blockquote><p><code>copyin</code> and <code>copyout</code> are defined in <code>~/src/kern/vm/copyinout.c</code></p><p><code>memmove</code> is defined in <code>~/src/common/libc/string/memmove.c</code></p><p>The <code>copyin</code> and <code>copyout</code> functions cannot be implemented as simply as <code>memmove</code> because they involve copying data between user space and kernel space, which introduces security and reliability concerns that <code>memmove</code> doesn't have to deal with.</p><p>There's a <code>copycheck</code> function call at the beginning of both <code>copyin</code> and <code>copyout</code> because the kernel must verify that the user-provided addresses are valid and within the user's accessible memory range.</p><p>The complexity in <code>copyin</code> and <code>copyout</code> comes from setting up safeguards (like <code>tm_badfaultfunc</code> and <code>setjmp</code>) to catch and handle potential faults, performing necessary checks, and ensuring the operation is secure and doesn't compromise the system's integrity.</p><p>In contrast, <code>memmove</code> operates entirely within a single memory space (either all kernel or all user space) and can assume that all addresses it's working with are valid and accessible, which allows for a much simpler implementation.</p><blockquote><ol start="7"><li>What (briefly) is the purpose of <code>userptr_t</code>?</li></ol></blockquote><p>The purpose of <code>userptr_t</code> is to create a distinct pointer type for user-space addresses that cannot be accidentally confused or mixed with kernel-space pointers. It serves as a safeguard in the kernel code to clearly differentiate and safely handle pointers to user-space memory.</p><blockquote><ol start="8"><li>What is the numerical value of the exception code for a MIPS system call?</li></ol></blockquote><p>The exception code for a MIPS system call is 8.</p><blockquote><ol start="9"><li>How many bytes is an instruction in MIPS?</li></ol></blockquote><p>By examining the <code>syscall(struct trapframe *tf)</code> function, we can determine that each MIPS instruction is <strong>4 bytes</strong>. This is evident from the following code snippet:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Now, advance the program counter, to avoid restarting</span><br><span class="hljs-comment"> * the syscall over and over again.</span><br><span class="hljs-comment"> */</span><br>tf-&gt;tf_epc += <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>The line <code>tf-&gt;tf_epc += 4;</code> increments the program counter by 4, indicating that each instruction in MIPS occupies 4 bytes.</p><blockquote><ol start="10"><li>Why do you &quot;probably want to change&quot; the implementation of <code>kill_curthread()</code>?</li></ol></blockquote><p>Since this function handles fatal faults in user-level code by calling <code>panic()</code>, which will crash the entire system. For a single user-level fault, we don't need to crash the entire kernel or system. We can simply signal the parent and clean up the process.</p><blockquote><ol start="11"><li>What would be required to implement a system call that took more than 4 arguments?</li></ol></blockquote><p>To implement a system call with more than 4 arguments, the following steps would be necessary:</p><ol><li><p><strong>Pass the first 4 arguments in registers <code>a0-a3</code></strong>.</p></li><li><p><strong>Fetch the remaining arguments from the user stack</strong>: For arguments beyond the 4th, we need to get them from the user stack, in detail, fetching from <code>sp+16</code> to skip over the space reserved for the first 4 registerized arguments.(We need use the <code>copyin()</code> function to safely retrieve these arguments from the user space into the kernel space. )</p></li></ol><blockquote><ol start="12"><li>What is the purpose of the SYSCALL macro?</li></ol></blockquote><p>The main purpose of the <code>SYSCALL</code> macro is to simplify the definition and handling of system calls, ensuring that each system call is properly numbered and recognized by the kernel.</p><ol><li><p><strong>Generate Assembly Code for System Calls</strong>:It generates the necessary assembly code to load the system call number into the appropriate register and call the generic <code>__syscall</code> handler.</p></li><li><p><strong>Simplify the Registration Process</strong>:By using the <code>SYSCALL</code> macro, developers don't have to manually write the assembly code for each system call. The script ( <code>gensyscalls.sh</code>) parses this file and generates the required assembly stubs, making the system calls automatically recognizable and executable by the kernel.</p></li></ol><blockquote><ol start="13"><li>What is the MIPS instruction that actually triggers a system call?</li></ol></blockquote><p>The instruction that actually triggers a system call is:<code>syscall</code></p><blockquote><ol start="14"><li><p>After reading syscalls-mips.S and syscall.c, you should be prepared to answer the following question:</p><p>OS/161 supports 64-bit values; <code>lseek()</code> takes and returns a 64-bit offset value. Thus, lseek() takes a 32-bit file handle (arg0), a 64-bit offset (arg1), a 32-bit whence (arg2), and needs to return a 64-bit offset value. In <code>void syscall(struct trapframe *tf)</code> where will you find each of the three arguments (in which registers) and how will you return the 64-bit offset?</p></li></ol></blockquote><ul><li><strong>arg0</strong> (file handle, 32-bit) is found in the <strong><code>a0</code></strong> register.</li><li><strong>arg1</strong> (offset, 64-bit):<ul><li>Lower 32 bits are stored in <strong><code>a2</code></strong>.</li><li>Upper 32 bits are stored in <strong><code>a3</code></strong>.</li><li>If registers are insufficient, additional arguments can be fetched from the user stack, starting at <strong><code>sp+16</code></strong> for the lower 32 bits and <strong><code>sp+20</code></strong> for the upper 32 bits.</li></ul></li><li><strong>arg2</strong> (whence, 32-bit) is found on the user stack at <strong><code>sp+16</code></strong>.</li></ul><p>To return the 64-bit offset value:</p><ul><li><strong><code>v0</code></strong> holds the lower 32 bits of the return value.</li><li><strong><code>v1</code></strong> holds the upper 32 bits of the return value.</li></ul><blockquote><ol start="15"><li>As you were reading the code in <code>runprogram.c</code> and <code>loadelf.c</code>, you probably noticed how the kernel manipulates the files. Which kernel function is called to open a file? Which macro is called to read the file? What about to write a file? Which data structure is used in the kernel to represent an open file?</li></ol></blockquote><p><strong>Kernel function to open a file</strong>:The kernel function to open a file is <code>vfs_open()</code>. In <code>runprogram()</code>, the file is opened with the call <code>vfs_open(progname, O_RDONLY, 0, &amp;v);</code>, where <code>O_RDONLY</code> specifies read-only mode.</p><p><strong>Macro to read a file</strong>:The macro to read a file is <code>VOP_READ()</code>. In <code>loadelf.c</code>, it is used in <code>load_segment()</code> with the call <code>VOP_READ(v, &amp;u);</code> to read data from the file.</p><p><strong>Macro to write a file</strong>:Although not explicitly used in the provided code, the macro to write a file is <code>VOP_WRITE()</code>, which functions similarly to <code>VOP_READ()</code> but for writing.</p><p><strong>Data structure representing an open file in the kernel</strong>:The kernel uses the <code>struct vnode</code> data structure to represent an open file. In <code>runprogram.c</code>, a <code>vnode</code> represents the opened program file, stored in the variable <code>v</code>.</p><blockquote><ol start="16"><li>What is the purpose of VOP_INCREF and VOP_DECREF?</li></ol></blockquote><p><strong>VOP_INCREF</strong>: Increases the reference count of a file (or <code>vnode</code>) to indicate that it is in use. This prevents the file from being released while it is still being accessed.</p><p><strong>VOP_DECREF</strong>: Decreases the reference count of a file. When the count reaches zero, it indicates that the file is no longer in use, allowing the kernel to safely release its resources.</p><h2 id="design-and-implementation"><a class="markdownIt-Anchor" href="#design-and-implementation"></a> Design and implementation</h2><blockquote><p>The system calls you need to implement in this assignment are:</p><p><code>open(), read(), write(), lseek(), close(), dup2(), chdir(), and __getcwd()</code></p></blockquote><blockquote><p><strong>How to begin:</strong></p><ol><li>Take a look at <code>kern/test/fstest.c</code> to learn about the functions available in the kernel for manipulating files. Another place to look for useful function is in the <code>kern/vfs</code> directory. These functions will be very helpful to you when implementing the solution to this assignment.</li><li>Carefully study <code>kern/arch/mips/syscall/syscall.c</code>. Look at the existing system calls as well as the comments at the top of this file. They will tell you exactly how to pass the arguments in and out of the system calls.</li></ol></blockquote><blockquote><p>Things become even more complicated in Assignment 5, where you'll need to implement <code>fork()</code>, which dictates that <strong>the file objects be shared between the parent and child processes</strong>; since these can run concurrently, you will need some careful synchronization! Though you don't need to worry about this for the current assignment, designing your file-tracking system with Assignment 5 in mind might make your life easier later.</p></blockquote><div class="note note-success">            <p>That is to say, different processes that run concurrently may share the same file handle. Besides, although in this assignment we assume each process only has one thread, it is strongly recommended that we take multi-threaded processes into account in order to make our code more robust.</p>          </div><blockquote><p><strong>Important:</strong> Before sitting down to write code, get together with your partner and write down the following <strong>for every system call</strong>:</p><ul><li>the arguments it takes</li><li>the return values it might return</li><li>the errors it must check for</li><li>the information it needs to access and update inside the file table</li><li>the functions and macros available in os161 that you can use for its implementation</li><li>the potential race conditions and how they must be prevented (assume no user-level threads for this assignment).</li></ul></blockquote><blockquote><p>For now, make the menu thread go away by having it block on some semaphore or run an infinite while loop after it launches the user program.</p></blockquote><h2 id="my-solution"><a class="markdownIt-Anchor" href="#my-solution"></a> My Solution</h2><blockquote><p>Task: Implement <code>open(), read(), write(), lseek(), close(), dup2(), chdir(), and __getcwd()</code> system calls.</p></blockquote><h3 id="kernel-structure-for-open-files"><a class="markdownIt-Anchor" href="#kernel-structure-for-open-files"></a> Kernel structure for open files</h3><p>All the system calls that we implemented here are interact with files. So we first need to implement the OS/161 <strong>kernel structure for managing open files</strong>, including the <strong>file descriptor table</strong> and <strong>file handles</strong>.</p><p>Details of OS/161 kernel structure for open files are shown below:</p><div class="note note-primary">            <p><strong>Kernel three-table data structure for open files</strong>:</p><img src="../imgs/202410111635355.png" alt="" style="zoom: 67%;" /><ul><li>Table1: <strong>Process table</strong></li></ul><p>Each process entry in the <strong>process table</strong> contains a <strong>file description table</strong>(a table of open file descriptors).</p><ul><li>Table2: <strong>Open file table</strong></li></ul><p>The file descriptors index the entries in the file description table. Each entry contains a <strong>pointer</strong> to an entry in the <strong>open files table</strong>(a table that the kernel maintains for all open files).</p><p>Each entry in this open files table contains the <strong>file status flags</strong> (read, write, append, etc.), the current <strong>file offset</strong>, and a <strong>pointer</strong> to the entry for this file in the so-called <strong>v-node table</strong>.</p><ul><li>Table3: <strong>V-node table</strong></li></ul><p>The v-node table (or part of it) is stored on the physical device. For now, you can think of its entries as the &quot;real'' file contents on a disk, with associated informations like file location on disk, size, name, owner, etc.</p><blockquote><p>What if two processes want to independently open the same physical file, i.e. with each process maintaining its own access mode (read, write or append) and file offset as well?</p></blockquote><p>Here the <strong>open files table has two independent entries for the same file</strong>, each associated to one of the processes.</p><img src="../imgs/202410252054616.png" alt="" style="zoom:60%;" /><blockquote><p>What if we need to have in one process <em>two</em> file descriptors opened for the same file?</p></blockquote><p>Duplication of file descriptors:</p><img src="../imgs/202410111701382.png" alt="" style="zoom:67%;" /><blockquote><p>How we achieve this?</p></blockquote><p>The <code>dup()</code> and <code>dup2()</code> system calls do this job.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* duplicate the passed file descriptor, returning the smallest available one. */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes)</span>;<br><span class="hljs-comment">/* specify in what file descriptor you want the copy */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">int</span> fildes2)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>Why we need the duplication of file descriptors?</p></blockquote><p>Example:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>    <span class="hljs-keyword">if</span> (fork()==<span class="hljs-number">0</span>)<br>    &#123;<br>        close(STDIN_FILENO); <br>        dup(datafd); <span class="hljs-comment">/* datafd duplicated in stdin */</span><br>        execlp(<span class="hljs-string">&quot;sed&quot;</span>, <span class="hljs-string">&quot;sed&quot;</span>, (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>);<br>        perror(<span class="hljs-string">&quot;sed&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>By duplicating <code>datafd</code> to <code>stdin</code>, we ensure <code>sed</code> can read from our desired file.</p><blockquote><p>What is the problem of <code>dup()</code>? How we solve this?</p></blockquote><p>The close-and-duplicate sequence above is not atomic. We can fix this with <code>dup2</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-keyword">if</span> (fork()==<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-comment">/* atomic operation */</span><br>    dup2(datafd, STDIN_FILENO);<br>    execlp(<span class="hljs-string">&quot;sed&quot;</span>, <span class="hljs-string">&quot;sed&quot;</span>, (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>);<br>    perror(<span class="hljs-string">&quot;sed&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>          </div><p>Take time to fully understand the contents above before implementing your <strong>file descriptor table</strong> and <strong>file handle</strong> structures.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* File handle structure */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vnode</span> *<span class="hljs-title">vn</span>;</span>       <span class="hljs-comment">// Pointer to the v-node</span><br>    <span class="hljs-type">off_t</span> offset;           <span class="hljs-comment">// Current file offset</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> refcount;  <span class="hljs-comment">// Reference count</span><br>    <span class="hljs-type">int</span> flags;              <span class="hljs-comment">// file status flags</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> *<span class="hljs-title">fh_lock</span>;</span>   <span class="hljs-comment">// Lock for the file handle</span><br>&#125;;<br><br><span class="hljs-comment">/* Per-process file descriptor table */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filetable</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">file_handles</span>[<span class="hljs-title">OPEN_MAX</span>];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> *<span class="hljs-title">ft_lock</span>;</span>  <span class="hljs-comment">// Lock for the file descriptor table</span><br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>Notice that although in this lab we assume each process only has one thread, adding a lock to the file descriptor table makes our code more robust.</p>          </div><p>Besides implementing the actual file table and file handle structure, we also need to implement some functions with which the system calls can perform operations on the file system.</p><blockquote><p>Think about what those functions are needed? Also within those functions, what kinds of synchronization do we need?</p></blockquote><p>You can first write some functions that come to mind after you finish implementing the file table and file handle structure, and gradually add more functions while trying to implement the file-related system calls.</p><p>Here I show all the functions I need to operate on the file tables and file handles:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* File descriptor table functions */</span><br><span class="hljs-keyword">struct</span> filetable *<span class="hljs-title function_">filetable_create</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">filetable_stdio_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *ft)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">filetable_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *ft)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">filetable_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *ft, <span class="hljs-keyword">struct</span> filehandle *fh)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">filetable_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *ft, <span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-keyword">struct</span> filetable *<span class="hljs-title function_">filetable_copy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *old_ft)</span>;<br><br><span class="hljs-comment">/* File handle functions */</span><br><span class="hljs-keyword">struct</span> filehandle *<span class="hljs-title function_">create_stdio_handle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *device, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-keyword">struct</span> filehandle *<span class="hljs-title function_">filehandle_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vnode *vn, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">filehandle_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filehandle *fh)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">filehandle_incref</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filehandle *fh)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">filehandle_decref</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filehandle *fh)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// File descriptor table functions</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Create a new file descriptor table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function allocates memory for a new file descriptor table and initializes it by creating a lock</span><br><span class="hljs-comment"> * for synchronization. It also initializes the file handles array with standard I/O.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return A pointer to the newly created file descriptor table, </span><br><span class="hljs-comment"> * or NULL if memory allocation fails or if the lock creation fails.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> filetable *<br><span class="hljs-title function_">filetable_create</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filetable</span> *<span class="hljs-title">ft</span> =</span> kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> filetable));<br>    <span class="hljs-keyword">if</span> (ft == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    ft-&gt;ft_lock = lock_create(<span class="hljs-string">&quot;filetable_lock&quot;</span>);<br>    <span class="hljs-keyword">if</span> (ft-&gt;ft_lock == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(ft);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; OPEN_MAX; i++)<br>    &#123;<br>        ft-&gt;file_handles[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ft;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">filetable_stdio_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *ft)</span> &#123;<br>    <span class="hljs-comment">// Initialize standard I/O</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">stdin_handle</span> =</span> create_stdio_handle(<span class="hljs-string">&quot;con:&quot;</span>, O_RDONLY);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">stdout_handle</span> =</span> create_stdio_handle(<span class="hljs-string">&quot;con:&quot;</span>, O_WRONLY);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">stderr_handle</span> =</span> create_stdio_handle(<span class="hljs-string">&quot;con:&quot;</span>, O_WRONLY);<br><br>    KASSERT(stdin_handle != <span class="hljs-literal">NULL</span>);<br>    KASSERT(stdout_handle != <span class="hljs-literal">NULL</span>);<br>    KASSERT(stderr_handle != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">int</span> fd0 = filetable_add(ft, stdin_handle);<br>    <span class="hljs-type">int</span> fd1 = filetable_add(ft, stdout_handle);<br>    <span class="hljs-type">int</span> fd2 = filetable_add(ft, stderr_handle);<br><br>    KASSERT(fd0 == <span class="hljs-number">0</span>);<br>    KASSERT(fd1 == <span class="hljs-number">1</span>);<br>    KASSERT(fd2 == <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Destroy the file descriptor table.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * This function releases all file handles in the file descriptor table by decrementing their reference counts</span><br><span class="hljs-comment"> * and setting them to NULL. It also destroys the lock associated with the file descriptor table and frees the memory.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param ft The file descriptor table to be destroyed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">filetable_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *ft)</span><br>&#123;<br>    KASSERT(ft != <span class="hljs-literal">NULL</span>);<br><br>    lock_acquire(ft-&gt;ft_lock);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; OPEN_MAX; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ft-&gt;file_handles[i] != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            filehandle_decref(ft-&gt;file_handles[i]);<br>            ft-&gt;file_handles[i] = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    lock_release(ft-&gt;ft_lock);<br><br>    lock_destroy(ft-&gt;ft_lock);<br>    kfree(ft);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Add an entry to the process&#x27;s file descriptor table that </span><br><span class="hljs-comment"> * maps a new file descriptor to this file handle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param ft The file descriptor table to add the file handle to.</span><br><span class="hljs-comment"> * @param fh The file handle to add.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return The assigned file descriptor for the file handle, </span><br><span class="hljs-comment"> * or -1 if the file descriptor table is full.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">filetable_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *ft, <span class="hljs-keyword">struct</span> filehandle *fh)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br>    lock_acquire(ft-&gt;ft_lock);<br><br>    <span class="hljs-comment">// Find the first available file descriptor</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; OPEN_MAX; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ft-&gt;file_handles[i] == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ft-&gt;file_handles[i] = fh;<br>            filehandle_incref(fh);<br>            fd = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    lock_release(ft-&gt;ft_lock);<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Remove a file handle from the file descriptor table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function removes the file handle associated with the specified</span><br><span class="hljs-comment"> * file descriptor from the file descriptor table by decrementing its</span><br><span class="hljs-comment"> * reference count and setting the entry to NULL. The operation is</span><br><span class="hljs-comment"> * protected by a lock to ensure thread safety.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param ft The file descriptor table to remove the file handle from.</span><br><span class="hljs-comment"> * @param fd The file descriptor whose associated file handle is to be removed.</span><br><span class="hljs-comment"> * @return 0 on success, or EBADF if the file descriptor is not valid.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">filetable_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *ft, <span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span> || fd &gt;= OPEN_MAX)<br>    &#123;<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    lock_acquire(ft-&gt;ft_lock);<br>    <span class="hljs-keyword">if</span> (ft-&gt;file_handles[fd] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        filehandle_decref(ft-&gt;file_handles[fd]);<br>        ft-&gt;file_handles[fd] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        lock_release(ft-&gt;ft_lock);<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br>    lock_release(ft-&gt;ft_lock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a copy of an existing file table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function is typically used during process forking. It allocates</span><br><span class="hljs-comment"> * memory for a new file table structure, copies all entries from the old</span><br><span class="hljs-comment"> * file table to the new one, increments the reference count for each file</span><br><span class="hljs-comment"> * handle in the new table, and creates new synchronization primitives for</span><br><span class="hljs-comment"> * the new table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param old_ft Pointer to the file table to be copied.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return A pointer to the newly created copy of the file table on success,</span><br><span class="hljs-comment"> *         or NULL if memory allocation fails.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @note This function creates a shallow copy of the file handles, meaning</span><br><span class="hljs-comment"> *       the actual file state is shared between the original and the copy.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> filetable *<br><span class="hljs-title function_">filetable_copy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filetable *old_ft)</span><br>&#123;<br>    KASSERT(old_ft != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filetable</span> *<span class="hljs-title">new_ft</span> =</span> filetable_create();<br>    <span class="hljs-keyword">if</span> (new_ft == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    lock_acquire(old_ft-&gt;ft_lock);<br>    lock_acquire(new_ft-&gt;ft_lock);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; OPEN_MAX; i++) &#123;<br>        <span class="hljs-keyword">if</span> (old_ft-&gt;file_handles[i] != <span class="hljs-literal">NULL</span>) &#123;<br>            new_ft-&gt;file_handles[i] = old_ft-&gt;file_handles[i];<br>            new_ft-&gt;file_handles[i]-&gt;refcount++;<br>        &#125;<br>    &#125;<br><br>    lock_release(new_ft-&gt;ft_lock);<br>    lock_release(old_ft-&gt;ft_lock);<br><br>    <span class="hljs-keyword">return</span> new_ft;<br>&#125;<br><br><br><span class="hljs-comment">//////////////////////////////////////////////////</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// File handle functions</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Create a file handle for standard I/O.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param device The device name (e.g., &quot;con:&quot;)</span><br><span class="hljs-comment"> * @param flags The flags for opening the device</span><br><span class="hljs-comment"> * @return The newly-create file handle</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> filehandle *<br><span class="hljs-title function_">create_stdio_handle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *device, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vnode</span> *<span class="hljs-title">vn</span>;</span><br>    <span class="hljs-type">int</span> result = vfs_open(kstrdup(device), flags, <span class="hljs-number">0</span>, &amp;vn);<br>    KASSERT(result == <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">fh</span> =</span> kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> filehandle));<br>    KASSERT(fh != <span class="hljs-literal">NULL</span>);<br>    <br>    fh-&gt;vn = vn;<br>    fh-&gt;offset = <span class="hljs-number">0</span>;<br>    fh-&gt;refcount = <span class="hljs-number">0</span>;<br>    fh-&gt;flags = flags;<br>    fh-&gt;fh_lock = lock_create(<span class="hljs-string">&quot;file_handle_lock&quot;</span>);<br>    KASSERT(fh-&gt;fh_lock != <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-keyword">return</span> fh;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Create a new file handle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function allocates memory for a new file handle and initializes it with the provided vnode</span><br><span class="hljs-comment"> * and flags. It also initializes the file handle&#x27;s offset, reference count, and file status flags. </span><br><span class="hljs-comment"> * Additionally, it creates a lock for the file handle for synchronization purposes.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param vn The vnode associated with the file handle.</span><br><span class="hljs-comment"> * @param flags The file status flags for the file handle.</span><br><span class="hljs-comment"> * @return A pointer to the newly created file handle.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> filehandle *<br><span class="hljs-title function_">filehandle_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vnode *vn, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">fh</span> =</span> kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> filehandle));<br>    KASSERT(fh != <span class="hljs-literal">NULL</span>);<br><br>    fh-&gt;vn = vn;<br>    fh-&gt;offset = <span class="hljs-number">0</span>;<br>    fh-&gt;refcount = <span class="hljs-number">0</span>;<br>    fh-&gt;flags = flags;<br>    fh-&gt;fh_lock = lock_create(<span class="hljs-string">&quot;file_handle_lock&quot;</span>);<br>    KASSERT(fh-&gt;fh_lock != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> fh;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Destroy a file handle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function closes the vnode associated with the file handle, destroys the lock associated with the file handle, and</span><br><span class="hljs-comment"> * frees the memory allocated for the file handle.</span><br><span class="hljs-comment"> * It is called when the reference count of a file handle reaches 0 and the lock for the file handle is locked.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param fh The file handle to be destroyed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">filehandle_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filehandle *fh)</span><br>&#123;<br>    KASSERT(fh != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock_do_i_hold(fh-&gt;fh_lock));<br><br>    vfs_close(fh-&gt;vn);<br>    lock_release(fh-&gt;fh_lock);<br>    lock_destroy(fh-&gt;fh_lock);<br>    kfree(fh);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Increment the reference count of a file handle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function increments the reference count of a file handle, which is used to determine when a file handle can be</span><br><span class="hljs-comment"> * safely destroyed. The reference count is incremented atomically to ensure the integrity of the file handle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param fh The file handle whose reference count to increment.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">filehandle_incref</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filehandle *fh)</span><br>&#123;<br>    KASSERT(fh != <span class="hljs-literal">NULL</span>);<br><br>    lock_acquire(fh-&gt;fh_lock);<br>    fh-&gt;refcount++;<br>    lock_release(fh-&gt;fh_lock);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Decrement the reference count of a file handle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function decreases the reference count of the provided file handle.</span><br><span class="hljs-comment"> * If the reference count reaches zero, the file handle is destroyed, </span><br><span class="hljs-comment"> * releasing any resources associated with it. The function is protected</span><br><span class="hljs-comment"> * by a lock to ensure thread safety during the operation.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param fh The file handle whose reference count is to be decremented.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">filehandle_decref</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> filehandle *fh)</span><br>&#123;<br>    KASSERT(fh != <span class="hljs-literal">NULL</span>);<br><br>    lock_acquire(fh-&gt;fh_lock);<br>    fh-&gt;refcount--;<br>    <span class="hljs-keyword">if</span> (fh-&gt;refcount == <span class="hljs-number">0</span>)<br>    &#123;<br>        filehandle_destroy(fh);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    lock_release(fh-&gt;fh_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>After implementing the file descriptor table and functions to operate on it, we need to add the <code>filetable</code> to the <code>proc</code> structure, create the file descriptor table during process creation and clean the file descriptor table during process destruction.</p><div class="note note-primary">            <p>Notice that in OS/161, there are two ways to create a process:</p><ol><li><p>By <code>fork</code> system call</p><p>we will implement the <code>proc_create_fork</code> function in the next assignment. Since the child process share the same file descriptor table with the parent process, we just need to copy the entire <code>filetable</code> to the new process. That is why we need a <code>filetable_copy</code> function.</p></li><li><p>By <code>proc_create_runprogram</code></p><p>This function is used to create the first user process for the new program to run in. Since this is the first user process created, we need to initialize the standard I/O in its file descriptor table. Therefore, we need to call <code>filetable_stdio_init</code> in <code>proc_create_runprogram</code>.</p></li></ol><p>Notice that in either way, we first need to call the <code>proc_create</code> function to create a initial <code>proc</code> structure.</p>          </div><h3 id="system-calls-from-system-call-api-to-disk"><a class="markdownIt-Anchor" href="#system-calls-from-system-call-api-to-disk"></a> System calls (From system call API to Disk)</h3><p>Have the kernel structure for managing open files at hand, now it's time to write some file-related system calls!</p><p>Things to think about before coding:</p><blockquote><p>What functions can we use to help us implementing those system calls?</p></blockquote><p>Focus on functions that are responsible for VOP operations(operate on <code>vnode</code>) and VFS layer operations(translate operations on abstract on-disk files to operations on specific filesystems).</p><blockquote><p>What kind of synchronizations do we need to implement in the kernel for those system calls?</p></blockquote><p>Notice that for this assignment, we assume each process has only one thread. However, different processes may share the same file handle and can run concurrently.</p><blockquote><p>What kinds of errors should each system call return?</p></blockquote><p>Read the OS/161 system calls man page carefully and look up the error types in <code>errno.h</code>.</p><h4 id="sys_open"><a class="markdownIt-Anchor" href="#sys_open"></a> sys_open</h4><blockquote><p>How to copy the <code>filename</code> string from user space into kernel space.</p></blockquote><p>Use the <code>copyinstr</code> function to copy the <code>filename</code> from user space to kernel space.</p><blockquote><p>What function is used to actually open the file?</p></blockquote><p>We need to use the <code>vfs</code> functions to interact with <code>vnode</code>. Once we have the <code>vnode</code>, we can create the file handle that points to the <code>vnode</code> and add the file handle to the current process's file descriptor table.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">const_userptr_t</span> filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode, <span class="hljs-type">int32_t</span> *retval)</span><br>&#123;<br>    <span class="hljs-type">char</span> kfilename[PATH_MAX];<br>    <span class="hljs-type">size_t</span> actual_len;<br>    <span class="hljs-type">int</span> result;<br><br>    <span class="hljs-comment">/* Copy the filename from user space to kernel space */</span><br>    result = copyinstr(filename, kfilename, PATH_MAX, &amp;actual_len);<br>    <span class="hljs-keyword">if</span> (result)<br>    &#123;<br>        <span class="hljs-keyword">return</span> result;      <span class="hljs-comment">// Indicate failure</span><br>    &#125;<br><br>    <span class="hljs-comment">/* Open the file */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vnode</span> *<span class="hljs-title">vn</span>;</span><br>    result = vfs_open(kfilename, flags, mode, &amp;vn);<br>    <span class="hljs-keyword">if</span> (result)<br>    &#123;<br>        <span class="hljs-keyword">return</span> result;      <span class="hljs-comment">// Indicate failure</span><br>    &#125;<br><br>    <span class="hljs-comment">/* Create the file handle */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">fh</span>;</span><br>    fh = filehandle_create(vn, flags);<br>    KASSERT(fh != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">/* Add the file handle to the file descriptor table */</span><br>    <span class="hljs-type">int</span> fd = filetable_add(curproc-&gt;p_ft, fh);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        filehandle_decref(fh);<br>        <span class="hljs-keyword">return</span> EMFILE;      <span class="hljs-comment">// Indicate failure</span><br>    &#125;<br><br>    *retval = fd;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sys_close"><a class="markdownIt-Anchor" href="#sys_close"></a> sys_close</h4><blockquote><p>What functions in <code>filetable</code> can we use to close a file? How can we implement that function in <code>filetable</code>?</p></blockquote><p>We need to use the <code>vfs_close</code> to decrement the <code>refcount</code> in <code>vnode</code>.</p><p>We also need to decrease the <code>refcount</code> of <code>filehandle</code> and remove <code>filehandle</code> from <code>filetable</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;   <br>    <span class="hljs-comment">/* Check if the file descriptor is valid */</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span> || fd &gt;= OPEN_MAX) &#123;<br>        <span class="hljs-keyword">return</span> EBADF;       <span class="hljs-comment">// Indicate failure</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/* Get the current process&#x27;s file descriptor table */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filetable</span> *<span class="hljs-title">ft</span> =</span> curproc-&gt;p_ft;<br>    KASSERT(ft != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">/* Remove the file handle from the file descriptor table */</span><br>    <span class="hljs-type">int</span> result = filetable_remove(ft, fd);<br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-keyword">return</span> result;      <span class="hljs-comment">// Indicate failure</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sys_read-and-sys_write"><a class="markdownIt-Anchor" href="#sys_read-and-sys_write"></a> sys_read and sys_write</h4><p>Those two system calls' implementations are very similar.</p><blockquote><p>What synchronization problems can we face in the <code>read</code>/<code>write</code> system calls?</p></blockquote><p>Imagine two processes using the same file handle reading/writing from/to the same file concurrently. Therefore, we need to lock the file handle while reading as well as writing.</p><p>To mention it again, although in this lab we assume each process only has one thread, it is strongly recommended that we lock the file descriptor table while we are trying to get the file handle to make our code more robust.</p><blockquote><p>What structures and functions should we use to actually read/write from/to a file.</p></blockquote><p>We read/write from/to a <code>vnode</code>, so we should use <code>VOP</code> operation to read/write from/to a <code>vnode</code>.</p><p>Since <code>vnode</code> is the abstract representation of the file on disk, we also need some kind of I/O structure to describe the I/O operation(read/write).</p><p>That is the <code>uio</code> structure! Just to clarify, the <code>uio</code> structure is used just to describe the I/O operation, not to hold the actual data to be transferred. The VOP I/O operation use this information to transfer data directly from/to the disk.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">userptr_t</span> buf_ptr, <span class="hljs-type">size_t</span> nbytes, <span class="hljs-type">int32_t</span> *retval)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filetable</span> *<span class="hljs-title">ft</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">fh</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uio</span> <span class="hljs-title">u</span>;</span><br>    <span class="hljs-type">int</span> result;<br><br>    <span class="hljs-comment">// Check if file descriptor is valid</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span> || fd &gt;= OPEN_MAX)<br>    &#123;<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// Get the file descriptor table of the current process</span><br>    ft = curproc-&gt;p_ft;<br>    KASSERT(ft != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Get the file handle from the file descriptor table</span><br>    lock_acquire(ft-&gt;ft_lock);<br>    fh = ft-&gt;file_handles[fd];<br>    <span class="hljs-keyword">if</span> (fh == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        lock_release(ft-&gt;ft_lock);<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// Acquire the lock for the file handle</span><br>    lock_acquire(fh-&gt;fh_lock);<br>    lock_release(ft-&gt;ft_lock);<br><br>    <span class="hljs-comment">// Check if the file is opened for reading</span><br>    <span class="hljs-keyword">if</span> ((fh-&gt;flags &amp; O_ACCMODE) == O_WRONLY)<br>    &#123;<br>        lock_release(fh-&gt;fh_lock);<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// Set up the uio structure</span><br>    uio_kinit(&amp;iov, &amp;u, (<span class="hljs-type">void</span> *)buf_ptr, nbytes, fh-&gt;offset, UIO_READ);<br>    u.uio_segflg = UIO_USERSPACE;<br>    u.uio_space = curproc-&gt;p_addrspace;<br><br>    <span class="hljs-comment">// Perform the read operation</span><br>    result = VOP_READ(fh-&gt;vn, &amp;u);<br><br>    <span class="hljs-keyword">if</span> (result)<br>    &#123;<br>        lock_release(fh-&gt;fh_lock);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// Update the file offset</span><br>    fh-&gt;offset = u.uio_offset;<br><br>    <span class="hljs-comment">// Calculate the number of bytes actually read</span><br>    *retval = nbytes - u.uio_resid;<br><br>    <span class="hljs-comment">// Release the lock for the file handle</span><br>    lock_release(fh-&gt;fh_lock);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const_userptr_t</span> buf_ptr, <span class="hljs-type">size_t</span> nbytes, <span class="hljs-type">int32_t</span> *retval)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filetable</span> *<span class="hljs-title">ft</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">fh</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uio</span> <span class="hljs-title">u</span>;</span><br>    <span class="hljs-type">int</span> result;<br><br>    <span class="hljs-comment">// Check if file descriptor is valid</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span> || fd &gt;= OPEN_MAX)<br>    &#123;<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// Get the file descriptor table of the current process</span><br>    ft = curproc-&gt;p_ft;<br>    KASSERT(ft != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Get the file handle from the file descriptor table</span><br>    lock_acquire(ft-&gt;ft_lock);<br>    fh = ft-&gt;file_handles[fd];<br>    <span class="hljs-keyword">if</span> (fh == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        lock_release(ft-&gt;ft_lock);<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// lock the file handle</span><br>    lock_acquire(fh-&gt;fh_lock);<br>    lock_release(ft-&gt;ft_lock);<br><br>    <span class="hljs-comment">// Check if the file is opened for writing</span><br>    <span class="hljs-keyword">if</span> ((fh-&gt;flags &amp; O_ACCMODE) == O_RDONLY)<br>    &#123;<br>        lock_release(fh-&gt;fh_lock);<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// Set up the uio structure</span><br>    uio_kinit(&amp;iov, &amp;u, (<span class="hljs-type">void</span> *)buf_ptr, nbytes, fh-&gt;offset, UIO_WRITE);<br>    u.uio_segflg = UIO_USERSPACE;<br>    u.uio_space = curproc-&gt;p_addrspace;<br><br>    <span class="hljs-comment">// Perform the write operation</span><br>    result = VOP_WRITE(fh-&gt;vn, &amp;u);<br><br>    <span class="hljs-keyword">if</span> (result)<br>    &#123;<br>        lock_release(fh-&gt;fh_lock);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// Update the file offset</span><br>    fh-&gt;offset = u.uio_offset;<br>    *retval = nbytes - u.uio_resid;<br><br>    <span class="hljs-comment">// Release the lock for the file handle</span><br>    lock_release(fh-&gt;fh_lock);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sys_lseek"><a class="markdownIt-Anchor" href="#sys_lseek"></a> sys_lseek</h4><p>Check the man page to understand how to calculate the new file offset given the parameter <code>whence</code>.</p><blockquote><p>What synchronization problems can we face in the <code>lseek</code> system call?</p></blockquote><p>Like read/write, imagine two processes using the same file handle seeking to different locations. We need to lock the file handle while seeking. Like mentioned before, it is strongly recommended that we also lock the file descriptor table while trying to get the file handle to support multi-threaded processes, making our code more robust.</p><blockquote><p>How to check if the file supports seeking and how to know the size of the file?</p></blockquote><p>Those all interact with <code>vnode</code>, so we need to use VOP operations.</p><div class="note note-primary">            <p>When implementing <code>sys_lseek</code>, pay close attention to where you can find its parameters and how to pass its return value. If you are confused, review the coding reading exercises Q14.</p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> pos, <span class="hljs-type">int</span> whence, <span class="hljs-type">off_t</span> *retval)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filetable</span> *<span class="hljs-title">ft</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">fh</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-type">off_t</span> new_pos;<br>    <span class="hljs-type">int</span> result;<br><br>    <span class="hljs-comment">// Check if file descriptor is valid</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span> || fd &gt;= OPEN_MAX) &#123;<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// Get the file descriptor table of the current process</span><br>    ft = curproc-&gt;p_ft;<br>    KASSERT(ft != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Get the file handle from the file descriptor table</span><br>    lock_acquire(ft-&gt;ft_lock);<br>    fh = ft-&gt;file_handles[fd];<br>    <span class="hljs-keyword">if</span> (fh == <span class="hljs-literal">NULL</span>) &#123;<br>        lock_release(ft-&gt;ft_lock);<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// Acquire the lock for the file handle</span><br>    lock_acquire(fh-&gt;fh_lock);<br>    lock_release(ft-&gt;ft_lock);<br><br>    <span class="hljs-comment">// Check if the file supports seeking</span><br>    <span class="hljs-keyword">if</span> (!VOP_ISSEEKABLE(fh-&gt;vn)) &#123;<br>        lock_release(fh-&gt;fh_lock);<br>        <span class="hljs-keyword">return</span> ESPIPE;<br>    &#125;<br><br>    <span class="hljs-comment">// Calculate the new position based on whence</span><br>    <span class="hljs-keyword">switch</span> (whence) &#123;<br>        <span class="hljs-keyword">case</span> SEEK_SET:<br>            new_pos = pos;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SEEK_CUR:<br>            new_pos = fh-&gt;offset + pos;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SEEK_END:<br>            <span class="hljs-comment">// Get the file size</span><br>            result = VOP_STAT(fh-&gt;vn, &amp;st);<br>            <span class="hljs-keyword">if</span> (result) &#123;<br>                lock_release(fh-&gt;fh_lock);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            new_pos = st.st_size + pos;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            lock_release(fh-&gt;fh_lock);<br>            <span class="hljs-keyword">return</span> EINVAL;<br>    &#125;<br><br>    <span class="hljs-comment">// Check if the new position is valid</span><br>    <span class="hljs-keyword">if</span> (new_pos &lt; <span class="hljs-number">0</span>) &#123;<br>        lock_release(fh-&gt;fh_lock);<br>        <span class="hljs-keyword">return</span> EINVAL;<br>    &#125;<br><br>    <span class="hljs-comment">// Update the file offset</span><br>    fh-&gt;offset = new_pos;<br><br>    <span class="hljs-comment">// Release the lock for the file handle</span><br>    lock_release(fh-&gt;fh_lock);<br><br>    <span class="hljs-comment">// Set the return value</span><br>    *retval = new_pos;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sys_dup2"><a class="markdownIt-Anchor" href="#sys_dup2"></a> sys_dup2</h4><p>The <code>dup</code> process is really simple. We just make the <code>newfd</code> point to the same file handle as the <code>oldfd</code> and increase the <code>filehandle refcount</code>.</p><blockquote><p>What synchronization problems can we face in the <code>dup2</code> system call?</p></blockquote><p><code>dup2</code> operates on file descriptors. Since each process has its own file descriptor table, we won't need to worry about synchronization problems between processes. However, to make our code more robust, it is strongly recommended that we take multi-threaded processes into account.</p><p>Imagine two threads within the same process use <code>dup2</code> to operate on the same file descriptor at the same time. We need to lock the file descriptor table during the <code>dup</code> process.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd, <span class="hljs-type">int32_t</span> *retval)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filetable</span> *<span class="hljs-title">ft</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filehandle</span> *<span class="hljs-title">old_fh</span>, *<span class="hljs-title">new_fh</span>;</span><br><br>    <span class="hljs-comment">// Check validity of file descriptors</span><br>    <span class="hljs-keyword">if</span> (oldfd &lt; <span class="hljs-number">0</span> || oldfd &gt;= OPEN_MAX || newfd &lt; <span class="hljs-number">0</span> || newfd &gt;= OPEN_MAX)<br>    &#123;<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// Get the current process&#x27;s file descriptor table</span><br>    ft = curproc-&gt;p_ft;<br>    KASSERT(ft != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// If oldfd and newfd are the same, return success immediately</span><br>    <span class="hljs-keyword">if</span> (oldfd == newfd)<br>    &#123;<br>        *retval = newfd;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Acquire the lock for the file descriptor table</span><br>    lock_acquire(ft-&gt;ft_lock);<br><br>    <span class="hljs-comment">// Get the file handle for oldfd</span><br>    old_fh = ft-&gt;file_handles[oldfd];<br>    <span class="hljs-keyword">if</span> (old_fh == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        lock_release(ft-&gt;ft_lock);<br>        <span class="hljs-keyword">return</span> EBADF;<br>    &#125;<br><br>    <span class="hljs-comment">// Get the file handle for newfd</span><br>    new_fh = ft-&gt;file_handles[newfd];<br><br>    <span class="hljs-comment">// Check if newfd is already open, if so, close it</span><br>    <span class="hljs-keyword">if</span> (new_fh != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        filehandle_decref(new_fh);<br>        ft-&gt;file_handles[newfd] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Add old_fh to newfd</span><br>    ft-&gt;file_handles[newfd] = old_fh;<br>    filehandle_incref(old_fh);<br><br>    <span class="hljs-comment">// Release the lock for the file decriptor table</span><br>    lock_release(ft-&gt;ft_lock);<br><br>    <span class="hljs-comment">// Set the return value</span><br>    *retval = newfd;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sys___getcwd-and-sys_chdir"><a class="markdownIt-Anchor" href="#sys___getcwd-and-sys_chdir"></a> sys___getcwd and sys_chdir</h4><blockquote><p>What function should we use to get the current working directory?</p></blockquote><p>Getting the current working directory is like reading from a file. Changing the working directory is like writing to a file. Therefore, we still need the <code>uio</code> structure describe the I/O operation. The working directory of the process is associated with specific file systems. Therefore, we need to use <code>vfs</code> layer functions to interact with the file system.</p><p>To get the current working directory(<code>cwd</code>):</p><p>Take a look at <code>uio_kinit</code>, the <code>uio</code> structure is initiated with a kernel buffer. Therefore, we need to first read the <code>cwd</code> into a kernel buffer and then use <code>copyout</code> to copy the data to user buffer.</p><p>To change the current working directory(<code>cwd</code>):</p><p>We first need to use <code>copyinstr</code> to copy the pathname into a kernel buffer <code>kpath</code> and use <code>kpath</code> to do the work.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys___getcwd</span><span class="hljs-params">(<span class="hljs-type">userptr_t</span> buf, <span class="hljs-type">size_t</span> buflen, <span class="hljs-type">int32_t</span> *retval)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uio</span> <span class="hljs-title">u</span>;</span><br>    <span class="hljs-type">void</span> *kbuf;<br>    <span class="hljs-type">int</span> result;<br><br>    <span class="hljs-comment">// Handle zero-length buffer</span><br>    <span class="hljs-keyword">if</span> (buflen == <span class="hljs-number">0</span>) &#123;<br>        *retval = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Allocate kernel buffer</span><br>    kbuf = kmalloc(buflen);<br>    KASSERT(kbuf != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Set up the uio structure</span><br>    uio_kinit(&amp;iov, &amp;u, kbuf, buflen, <span class="hljs-number">0</span>, UIO_READ);<br><br>    <span class="hljs-comment">// Perform the getcwd operation</span><br>    result = vfs_getcwd(&amp;u);<br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        kfree(kbuf);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// Calculate the number of bytes actually read</span><br>    *retval = buflen - u.uio_resid;<br><br>    <span class="hljs-comment">// Copy data from kernel space to user space</span><br>    result = copyout(kbuf, buf, *retval);<br><br>    <span class="hljs-comment">// Free the kernel buffer</span><br>    kfree(kbuf);<br><br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_chdir</span><span class="hljs-params">(<span class="hljs-type">const_userptr_t</span> pathname)</span><br>&#123;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-type">char</span> *kpath;<br><br>    <span class="hljs-comment">// Allocate kernel buffer for the pathname</span><br>    kpath = kmalloc(PATH_MAX);<br>    KASSERT(kpath != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Copy the pathname from user space to kernel space</span><br>    result = copyinstr(pathname, kpath, PATH_MAX, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        kfree(kpath);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// Do the actual directory change</span><br>    result = vfs_chdir(kpath);<br><br>    <span class="hljs-comment">// Free the kernel buffer</span><br>    kfree(kpath);<br><br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="syscallc"><a class="markdownIt-Anchor" href="#syscallc"></a> <code>syscall.c</code></h4><p>The parameters for those system calls lie mainly in the <code>trapframe</code>. The special case is <code>lseek</code>, whose last parameter lies on user stack.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// In `syscall` function</span><br>...<br><span class="hljs-keyword">case</span> SYS_open:<br>err = sys_open((<span class="hljs-type">const_userptr_t</span>)tf-&gt;tf_a0, tf-&gt;tf_a1, tf-&gt;tf_a2, &amp;retval);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SYS_close:<br>err = sys_close(tf-&gt;tf_a0);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SYS_write:<br>err = sys_write(tf-&gt;tf_a0, (<span class="hljs-type">const_userptr_t</span>)tf-&gt;tf_a1, tf-&gt;tf_a2, &amp;retval);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SYS_read:<br>err = sys_read(tf-&gt;tf_a0, (<span class="hljs-type">userptr_t</span>)tf-&gt;tf_a1, tf-&gt;tf_a2, &amp;retval);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SYS_lseek:<br>&#123;<br><span class="hljs-type">int</span> whence;<br>err = copyin((<span class="hljs-type">const_userptr_t</span>)(tf-&gt;tf_sp + <span class="hljs-number">16</span>), &amp;whence, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-keyword">if</span> (err)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>err = sys_lseek(tf-&gt;tf_a0, ((<span class="hljs-type">off_t</span>)tf-&gt;tf_a2 &lt;&lt; <span class="hljs-number">32</span>) | (<span class="hljs-type">off_t</span>)tf-&gt;tf_a3, whence, &amp;retval64);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">case</span> SYS_dup2:<br>err = sys_dup2(tf-&gt;tf_a0, tf-&gt;tf_a1, &amp;retval);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SYS_chdir:<br>err = sys_chdir((<span class="hljs-type">const_userptr_t</span>)tf-&gt;tf_a0);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> SYS___getcwd:<br>err = sys___getcwd((<span class="hljs-type">userptr_t</span>)tf-&gt;tf_a0, tf-&gt;tf_a1, &amp;retval);<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>The return values of those system calls are 32 bits long, with the exception of <code>lseek</code>, whose return value is 64 bits long.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// In `syscall` function</span><br>...<br><span class="hljs-keyword">if</span> (err)<br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Return the error code. This gets converted at</span><br><span class="hljs-comment"> * userlevel to a return value of -1 and the error</span><br><span class="hljs-comment"> * code in errno.</span><br><span class="hljs-comment"> */</span><br>tf-&gt;tf_v0 = err;<br>tf-&gt;tf_a3 = <span class="hljs-number">1</span>; <span class="hljs-comment">/* signal an error */</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">/* Success. */</span><br>tf-&gt;tf_v0 = retval;<br>tf-&gt;tf_a3 = <span class="hljs-number">0</span>; <span class="hljs-comment">/* signal no error */</span><br><span class="hljs-keyword">if</span> (callno == SYS_lseek)<br>&#123;<br>tf-&gt;tf_v0 = retval64 &gt;&gt; <span class="hljs-number">32</span>;<br>tf-&gt;tf_v1 = retval64;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>To sum up, we need to carefully pass the parameters to <code>sys_*</code> functions from the <code>trapframe</code> and pass the return values of those system calls to the <code>trapframe</code> where the user process can get them from when going back to user mode.</p><h4 id="confkern"><a class="markdownIt-Anchor" href="#confkern"></a> <code>conf.kern</code></h4><p><code>~/src/kern/conf/conf.kern</code>:</p><p>Whenever creating a new file, include it in <code>conf.kern</code> and recompile the kernel.</p><p><img src="../imgs/202410171249246.png" alt="conf.kern" /></p><h2 id="finish"><a class="markdownIt-Anchor" href="#finish"></a> Finish!</h2><p>Those are the files I have modified/created. Do not get here unless you are stuck in coding!</p><p><img src="../imgs/202502151617124.png" alt="Files modified/created" /></p><p>We have passed all tests in Assignment4!</p><img src="../imgs/202410252151787.png" alt="" style="zoom:67%;" /><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">OS/<span class="hljs-number">161</span> kernel [? <span class="hljs-keyword">for</span> menu]: p /testbin/badcall<br>Operation took <span class="hljs-number">0.002373840</span> seconds<br>[a-|, <span class="hljs-number">1</span><span class="hljs-number">-4</span>, *, ?=menu, !=quit]<br>[a] execv                   [b] waitpid                 <br>[c] <span class="hljs-keyword">open</span>                    [d] <span class="hljs-keyword">read</span>                    <br>[e] <span class="hljs-keyword">write</span>                   [f] <span class="hljs-keyword">close</span>                   <br>[g] reboot                  [h] sbrk                    <br>[i] ioctl                   [j] lseek                   <br>[k] fsync                   [l] ftruncate               <br>[m] fstat                   [n] remove                  <br>[o] <span class="hljs-keyword">rename</span>                  [p] link                    <br>[q] mkdir                   [r] rmdir                   <br>[s] chdir                   [t] getdirentry             <br>[u] symlink                 [v] readlink                <br>[w] dup2                    [x] pipe                    <br>[y] __time                  [z] __getcwd                <br>[&#123;] stat                    [|] lstat                   <br>[<span class="hljs-number">1</span>] asst1                   [<span class="hljs-number">2</span>] asst2                   <br>[<span class="hljs-number">3</span>] asst3                   [<span class="hljs-number">4</span>] asst4                   <br>[*] <span class="hljs-keyword">all</span>                     [!] quit                    <br>Choose: c<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">open</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">NULL</span> path<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">open</span> <span class="hljs-keyword">with</span> invalid-pointer path<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">open</span> <span class="hljs-keyword">with</span> kernel-pointer path<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">open</span> <span class="hljs-keyword">null</span>: <span class="hljs-keyword">with</span> bad flags<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">open</span> empty string<br>Choose: d<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">read</span> <span class="hljs-keyword">using</span> fd <span class="hljs-number">-1</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">read</span> <span class="hljs-keyword">using</span> fd <span class="hljs-number">-5</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">read</span> <span class="hljs-keyword">using</span> closed fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">read</span> <span class="hljs-keyword">using</span> impossible fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">read</span> <span class="hljs-keyword">using</span> fd OPEN_MAX<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">read</span> <span class="hljs-keyword">using</span> fd opened <span class="hljs-keyword">write</span>-<span class="hljs-keyword">only</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">read</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">NULL</span> buffer<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">68</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">read</span> <span class="hljs-keyword">with</span> invalid buffer<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">68</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">read</span> <span class="hljs-keyword">with</span> kernel-space buffer<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">68</span><br>Choose: e<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">write</span> <span class="hljs-keyword">using</span> fd <span class="hljs-number">-1</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">write</span> <span class="hljs-keyword">using</span> fd <span class="hljs-number">-5</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">write</span> <span class="hljs-keyword">using</span> closed fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">write</span> <span class="hljs-keyword">using</span> impossible fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">write</span> <span class="hljs-keyword">using</span> fd OPEN_MAX<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">write</span> <span class="hljs-keyword">using</span> fd opened <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">write</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">NULL</span> buffer<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">68</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">write</span> <span class="hljs-keyword">with</span> invalid buffer<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">68</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">write</span> <span class="hljs-keyword">with</span> kernel-space buffer<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">68</span><br>Choose: f<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">close</span> <span class="hljs-keyword">using</span> fd <span class="hljs-number">-1</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">close</span> <span class="hljs-keyword">using</span> fd <span class="hljs-number">-5</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">close</span> <span class="hljs-keyword">using</span> closed fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">close</span> <span class="hljs-keyword">using</span> impossible fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: <span class="hljs-keyword">close</span> <span class="hljs-keyword">using</span> fd OPEN_MAX<br>Choose: s<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: chdir <span class="hljs-keyword">with</span> <span class="hljs-keyword">NULL</span> path<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: chdir <span class="hljs-keyword">with</span> invalid-pointer path<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: chdir <span class="hljs-keyword">with</span> kernel-pointer path<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: chdir <span class="hljs-keyword">to</span> empty string<br>Choose: w<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">using</span> fd <span class="hljs-number">-1</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">using</span> fd <span class="hljs-number">-5</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">using</span> closed fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">using</span> impossible fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">using</span> fd OPEN_MAX<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">to</span> <span class="hljs-number">-1</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">to</span> <span class="hljs-number">-5</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">to</span> impossible fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">to</span> OPEN_MAX<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: dup2 <span class="hljs-keyword">to</span> same fd<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">82</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: lseek fd <span class="hljs-keyword">after</span> dup2 <span class="hljs-keyword">to</span> itself<br>Choose: z<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: getcwd <span class="hljs-keyword">with</span> <span class="hljs-keyword">NULL</span> buffer<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: getcwd <span class="hljs-keyword">with</span> invalid buffer<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: getcwd <span class="hljs-keyword">with</span> kernel-space buffer<br>Choose: j<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: lseek <span class="hljs-keyword">using</span> fd <span class="hljs-number">-1</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: lseek <span class="hljs-keyword">using</span> fd <span class="hljs-number">-5</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: lseek <span class="hljs-keyword">using</span> closed fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: lseek <span class="hljs-keyword">using</span> impossible fd<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: lseek <span class="hljs-keyword">using</span> fd OPEN_MAX<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: lseek <span class="hljs-keyword">on</span> device<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">0</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): UH-OH: fork failed: <span class="hljs-keyword">Function</span> <span class="hljs-keyword">not</span> implemented<br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: lseek <span class="hljs-keyword">to</span> negative <span class="hljs-keyword">offset</span><br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">68</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: seek past/<span class="hljs-keyword">to</span> EOF<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">68</span><br>(program <span class="hljs-type">name</span> <span class="hljs-type">unknown</span>): passed: lseek <span class="hljs-keyword">with</span> invalid whence code<br><span class="hljs-type">Unknown</span> syscall <span class="hljs-number">68</span><br></code></pre></td></tr></table></figure><p><img src="../imgs/202410252152964-1740031159640-118.png" alt="bigseek test" /></p><p>We have finished Assignment4!😊</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>OS161</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>OS161</tag>
      
      <tag>File Descriptor</tag>
      
      <tag>System Calls</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scheduling</title>
    <link href="/2024/10/10/Scheduling/"/>
    <url>/2024/10/10/Scheduling/</url>
    
    <content type="html"><![CDATA[<p>In this part, we will talk about the topics of Job Scheduling in OS. We will cover different scheduling algorithm and real-life schedulers. Prepare for the journey of Scheduling!</p><h1 id="scheduling"><a class="markdownIt-Anchor" href="#scheduling"></a> Scheduling</h1><blockquote><p><strong>Learning Materials</strong></p><p>Videos:</p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/architecture.mp4">Computer Architecture Primer</a></p><p>Lecture Slides:</p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/Scheduling.pptx">Scheduling</a></p><p><a href="https://people.ece.ubc.ca/~os161/LECTURE-SLIDES/AdvancedScheduling.pptx"> Advanced scheduling</a></p><p>Readings:</p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf">OSTEP] Scheduling</a></p><p>[<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-mlfq.pdf">OSTEP] The multi-level feedback queue</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-lottery.pdf">OSTEP] Lottery scheduling and Linux CFS</a></p><p>[<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-multi.pdf">OSTEP] Multiprocessor scheduling</a></p><p><a href="http://people.ece.ubc.ca/~sasha/papers/eurosys16-final29.pdf">A Decade of Wasted Cores (Paper)</a></p></blockquote><h2 id="architecture-overview"><a class="markdownIt-Anchor" href="#architecture-overview"></a> Architecture Overview</h2><p>Basic Processor:</p><img src="../imgs/202410011046870.png" alt="" style="zoom: 67%;" /><p>Multicore:</p><img src="../imgs/202410011049694.png" alt="" style="zoom:67%;" /><p>Modern Multiprocessor:</p><img src="../imgs/202410011052076.png" alt="" style="zoom: 80%;" /><p><code>sys/161</code>:</p><p>Not multithreaded: Each core/processor has only one thread</p><p>Do not distinguish cores from processors; N-way <strong>single-core multiprocessors</strong></p><h2 id="scheduling-introduction"><a class="markdownIt-Anchor" href="#scheduling-introduction"></a> Scheduling: Introduction</h2><blockquote><p>How to build an optimal scheduler if we only consider <code>turnaround</code> time?</p></blockquote><ul><li><p>FIFO(First in First out)</p></li><li><p>SJF(Shortest Job First)</p></li><li><p>STCF(Shortest Time-to-Completion First)</p></li></ul><p>Optimal, if we know job lengths and our only metric is <code>turnaround</code> time.</p><blockquote><p>How can we build a scheduler that is sensitive to response time?</p></blockquote><ul><li>RR(Round Robin)</li></ul><p>A tradeoff between turnaround time and response time</p><blockquote><p>How to take I/O into account?</p></blockquote><p>The answer is <strong>Overlap</strong>!: Treat each CPU burst as a job.</p><img src="../imgs/202410031046437.png" alt="" style="zoom: 80%;" /><blockquote><p>How to determine the <code>timeslice</code>?</p></blockquote><p><code>timeslice</code> should be short, maximizing multitasking, but shouldn't be too short, otherwise context switch time would be long</p><p><strong>context switch</strong>:</p><ul><li>save the register of the old thread</li><li>find the new thread from the <code>runqueue</code></li><li>restore the new thread's register</li></ul><img src="../imgs/202410011150498.png" alt="" style="zoom:80%;" /><blockquote><p>How do we pick the next thread from the <code>runqueue</code>?</p></blockquote><p><strong>Scheduling Algorithm</strong>:</p><p>Multiple queues with different priority and <code>timeslice</code></p><p>Short <code>timeslice</code> thread has higher priority.</p><p>If a lower priority thread hasn't run for a long time, it will be moved to upper priority.</p><img src="../imgs/202410011218661.png" alt=""  /><h2 id="the-multi-level-feedback-queue"><a class="markdownIt-Anchor" href="#the-multi-level-feedback-queue"></a> The multi-level feedback queue</h2><p>MLFQ observes the execution of a job and prioritizes it accordingly.</p><ul><li>Rule 1: If Priority(A) &gt; Priority(B), A runs (B doesn’t).</li><li>Rule 2: If Priority(A) = Priority(B), A &amp; B run in <strong>Round-Robin</strong> fashion using the <strong>time slice</strong> (quantum length) of the given queue.</li><li>Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue).</li><li>Rule 4: Once a job uses up its time allotment at a given level (<strong>regardless of how many times it has given up the CPU</strong>), its priority is reduced (i.e., it moves down one queue).</li><li>Rule 5: After some time period S, move all the jobs in the system to the topmost queue.</li></ul><p><strong>MLFQ Problem</strong>:</p><blockquote><p>Simulate the Multi-Level Feedback Queue Algorithm discussed in the book. Assume the final version of the algorithm presented in the book, but no tuning. You have the following parameters and constraints:</p><ol><li>Time starts at 0ms.</li><li>There are three queues: highest-priority, middle-priority and low-priority.</li><li><code>Timeslice</code> equals to 10ms.</li><li>Allotment equals to 20ms.</li><li><em>S</em> equals to 100ms.</li><li>All jobs use up their entire timeslice every time they are scheduled.</li><li>Job J1 arrives at 0ms.</li><li>Job J2 arrives at 20ms.</li><li>J1 requires 60ms of CPU time to complete.</li><li>J2 requires 70ms of CPU time to complete.</li></ol></blockquote><p>bright color: J1;    light color: J2</p><img src="../imgs/202410031119223.png" alt="" style="zoom:120%;" /><img src="../imgs/202410040048866.jpg" alt="" style="zoom: 40%;" /><h2 id="scheduling-proportional-share"><a class="markdownIt-Anchor" href="#scheduling-proportional-share"></a> Scheduling: Proportional Share</h2><p>Guarantee that each job obtains a certain percentage of CPU time.</p><p>Use <strong>tickets</strong> to represent a process's share of the CPU</p><hr /><h3 id="lottery-scheduling-decision-code"><a class="markdownIt-Anchor" href="#lottery-scheduling-decision-code"></a> Lottery Scheduling Decision Code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// counter: used to track if we’ve found the winner yet</span><br><span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// winner: call some random number generator to</span><br><span class="hljs-comment">// get a value &gt;= 0 and &lt;= (totaltickets - 1)</span><br><span class="hljs-type">int</span> winner = getrandom(<span class="hljs-number">0</span>, totaltickets);<br><br><span class="hljs-comment">// current: use this to walk through the list of jobs</span><br><span class="hljs-type">node_t</span> *current = head;<br><span class="hljs-keyword">while</span> (current) &#123;<br>    counter = counter + current-&gt;tickets;<br>    <span class="hljs-keyword">if</span> (counter &gt; winner)<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// found the winner</span><br>    current = current-&gt;next;<br>&#125;<br><span class="hljs-comment">// ’current’ is the winner: schedule it...</span><br></code></pre></td></tr></table></figure><hr /><h3 id="stride-scheduling"><a class="markdownIt-Anchor" href="#stride-scheduling"></a> Stride Scheduling</h3><p>Deterministic fair-share scheduler</p><p><strong>Stride</strong> is inverse in proportion to the number of tickets it has, computed by dividing some large number by the number of tickets each process has been assigned.</p><p>Every time a process runs, we will <strong>increment a counter</strong> for it (called its pass value) <strong>by its stride</strong> to track its global progress. At any given time, the scheduler picks the process to run that has the lowest pass value so far.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">curr = remove_min(<span class="hljs-built_in">queue</span>); <span class="hljs-comment">// pick client with min pass</span><br>schedule(curr); <span class="hljs-comment">// run for quantum</span><br>curr-&gt;pass += curr-&gt;stride; <span class="hljs-comment">// update pass using stride</span><br>insert(<span class="hljs-built_in">queue</span>, curr); <span class="hljs-comment">// return curr to queue</span><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>Lottery scheduling makes more sense than stride scheduling when incorporating new processes.</p>          </div><hr /><h3 id="linux-completely-fair-scheduler-cfs"><a class="markdownIt-Anchor" href="#linux-completely-fair-scheduler-cfs"></a> Linux Completely Fair Scheduler (CFS)</h3><p>As each process runs, it accumulates <code>vruntime</code> at the same rate in proportion with real time.</p><p>When a scheduling decision occurs, CFS will pick the process with the lowest <code>vruntime</code> to run next.</p><p>CFS uses <code>sched_latency</code> to determine how long one process should run before considering a switch, determining its time slice but in a dynamic fashion.</p><p>CFS will never set the time slice to less than <code>min_granularity</code>.</p><ul><li><strong>Weighting (Niceness)</strong></li></ul><p>CFS gives each process a <strong>nice value</strong> indicating its priority.</p><p>CFS maps the <strong>nice value</strong> of each process to a <strong>weight</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> prio_to_weight[<span class="hljs-number">40</span>] = &#123;<br><span class="hljs-comment">/* -20 */</span> <span class="hljs-number">88761</span>, <span class="hljs-number">71755</span>, <span class="hljs-number">56483</span>, <span class="hljs-number">46273</span>, <span class="hljs-number">36291</span>,<br><span class="hljs-comment">/* -15 */</span> <span class="hljs-number">29154</span>, <span class="hljs-number">23254</span>, <span class="hljs-number">18705</span>, <span class="hljs-number">14949</span>, <span class="hljs-number">11916</span>,<br><span class="hljs-comment">/* -10 */</span> <span class="hljs-number">9548</span>, <span class="hljs-number">7620</span>, <span class="hljs-number">6100</span>, <span class="hljs-number">4904</span>, <span class="hljs-number">3906</span>,<br><span class="hljs-comment">/* -5 */</span> <span class="hljs-number">3121</span>, <span class="hljs-number">2501</span>, <span class="hljs-number">1991</span>, <span class="hljs-number">1586</span>, <span class="hljs-number">1277</span>,<br><span class="hljs-comment">/* 0 */</span> <span class="hljs-number">1024</span>, <span class="hljs-number">820</span>, <span class="hljs-number">655</span>, <span class="hljs-number">526</span>, <span class="hljs-number">423</span>,<br><span class="hljs-comment">/* 5 */</span> <span class="hljs-number">335</span>, <span class="hljs-number">272</span>, <span class="hljs-number">215</span>, <span class="hljs-number">172</span>, <span class="hljs-number">137</span>,<br><span class="hljs-comment">/* 10 */</span> <span class="hljs-number">110</span>, <span class="hljs-number">87</span>, <span class="hljs-number">70</span>, <span class="hljs-number">56</span>, <span class="hljs-number">45</span>,<br><span class="hljs-comment">/* 15 */</span> <span class="hljs-number">36</span>, <span class="hljs-number">29</span>, <span class="hljs-number">23</span>, <span class="hljs-number">18</span>, <span class="hljs-number">15</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>Then calculate each process's time slice:</p><img src="../imgs/202410042248052.png" alt="" style="zoom:50%;" /><p>Change the way CFS calculates <code>vruntime</code>:</p><img src="../imgs/202410042249814.png" alt="" style="zoom:50%;" /><p>That is to say, a process has higher priority will dominate CPU for a longer time but its <code>vruntime</code> increases slower.</p><ul><li><strong>CFS Red Black Tree</strong></li></ul><p>CFS uses a red black tree to keep the runnable processes by their <code>vruntime</code>.</p><img src="../imgs/202410042238024.png" alt="" style="zoom: 40%;" /><p>CFS handles sleeping processes by setting the <code>vruntime</code> of a job to the minimum value found in the tree when it wakes up.</p><hr /><h3 id="problems-of-fair-share-schedulers"><a class="markdownIt-Anchor" href="#problems-of-fair-share-schedulers"></a> Problems of fair-share schedulers</h3><ul><li><p>Do not particularly mesh well with I/O.</p></li><li><p>leave open the hard problem of ticket or priority assignment (How to assign tickets? How to set nice values?)</p></li></ul><h2 id="multiprocessor-scheduling"><a class="markdownIt-Anchor" href="#multiprocessor-scheduling"></a> Multiprocessor scheduling</h2><blockquote><p>How should the OS schedule jobs on multiple CPUs?</p></blockquote><h3 id="cache-affinity"><a class="markdownIt-Anchor" href="#cache-affinity"></a> Cache Affinity</h3><p>A process, when run on a particular CPU, builds up a fair bit of state in the caches (and TLBs) of the CPU. Therefore, a multiprocessor scheduler should consider <strong>keeping a process on the same CPU if at all possible</strong>.</p><hr /><h3 id="single-queue-scheduling"><a class="markdownIt-Anchor" href="#single-queue-scheduling"></a> Single-Queue Scheduling</h3><p>It does not scale well (due to <strong>synchronization overheads</strong>), and it does not readily preserve <strong>cache affinity</strong>.</p><hr /><h3 id="multi-queue-scheduling"><a class="markdownIt-Anchor" href="#multi-queue-scheduling"></a> Multi-Queue Scheduling</h3><blockquote><p>How to deal with load imbalance?</p></blockquote><p><strong>work stealing</strong>: A (source) queue that is low on jobs will occasionally peek at another (target) queue, to see how full it is. If the target queue is (notably) more full than the source queue, the source will “steal” one or more jobs from the target to help balance load.</p><h2 id="advanced-scheduling"><a class="markdownIt-Anchor" href="#advanced-scheduling"></a> Advanced Scheduling</h2><p>Avoid scheduling memory-intensive threads on the same shared cache to prevent <strong>cache contention</strong>.</p><img src="../imgs/202410081154427.png" alt="" style="zoom: 67%;" /><blockquote><p>Why  did performance suck on a NUMA system?</p><img src="../imgs/202410081159768.png" alt="" /></blockquote><p>We didn't take account where the data lives in memory, resulting in <strong>remote latency</strong>.</p><p><strong>Our algorithm:</strong></p><p>Continuously measure traffic(memory requests) of the thread.</p><blockquote><p>Why placing on random node?</p></blockquote><p>Balance the nodes and memory controllers.</p><img src="../imgs/image-20250222160917877.png" alt="" style="zoom:80%;" /><h2 id="linuxs-completely-fair-scheduling-cfs"><a class="markdownIt-Anchor" href="#linuxs-completely-fair-scheduling-cfs"></a> Linux’s Completely Fair Scheduling (CFS)</h2><div class="note note-danger">            <p>Bugs in the Linux Scheduler: Cores may stay idle for seconds while ready threads are waiting in <code>runqueue</code>s.</p>          </div><ul><li><strong>On a single-CPU system, CFS is very simple</strong></li></ul><p>The scheduler defines a fixed time interval(<code>sched_latency</code>) during which each thread in the system must run at least once. The interval is divided among threads proportionally to their weights. The resulting interval (after division) is what we call the <code>timeslice</code>.</p><p>Threads are organized in a <code>runqueue</code>, implemented as a red-black tree.</p><ul><li><strong>On multi-core systems, CFS becomes quite complex</strong></li></ul><p>Periodically run a <strong>load-balancing algorithm</strong> that will keep the queues roughly balanced.</p><p>The scheduler also invokes <strong>“emergency” load balancing when a core becomes idle</strong>.</p><ul><li><strong>The (Hierarchical) load balancing algorithm</strong></li></ul><p>CFS balances <code>runqueues</code> based on a metric called <strong>load</strong>, which is the <strong>combination of the thread’s weight and its average CPU utilization</strong>. If a thread does not use much of a CPU, its load will be decreased accordingly.</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>a</mi><mi>d</mi><mo>=</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>c</mi><mi>p</mi><mi>u</mi><mi>U</mi><mi>s</mi><mi>e</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">load = weight * (cpuUse)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><img src="../imgs/202410081357697.png" alt="" style="zoom:67%;" /><p>Function running on each cpu cur_cpu:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">/* iterate through each scheduling domain */<br>for all sd in sched domains of cur_cpu do<br><br>  /* At each level, either the first idle core of the scheduling domain or the first core of the scheduling<br>domain is reponsible for balancing the load. */<br>  if sd has idle cores then<br>     first cpu = 1st idle CPU of sd<br>  else<br>     first cpu = 1st CPU of sd<br>  end if<br>  if cur_cpu != first cpu then<br>     continue<br>  end if<br>  <br>  /* Compute the average load of each scheduling group of the scheduling domain and pick the busiest group. */<br>  for all sched group sg in sd do<br>    sg.load = average loads of CPUs in sg<br>  end for<br>  busiest = overloaded sg with the highest load<br>    (or, if nonexistent) imbalanced sg with highest load<br>    (or, if nonexistent) sg with highest load<br>  <br>  /* If the busiest group’s load is lower than the local group’s load, the load is considered balanced at this level. */<br>  local = sg containing cur_cpu<br>  if busiest.load ≤ local.load then<br>     continue<br>  end if<br>  <br>  /*  Otherwise, the load is balanced between the local CPU and the busiest CPU of the group. */<br>  busiest cpu = pick busiest cpu of sg<br>  try to balance load between busiest cpu and cur_cpu<br>  if load cannot be balanced due to tasksets then<br>     exclude busiest cpu, goto line 29<br>  end if<br>  <br>end for<br></code></pre></td></tr></table></figure><ul><li><strong>Special case</strong></li></ul><p>When a thread <strong>wakes up</strong>, after sleeping or waiting for a resource (e.g., locks, I/O), the scheduler tries to place it on the <strong>idlest core</strong>.</p><p>When the thread is awoken by another thread (<code>waker</code> thread). In that case the scheduler will favor cores <strong>sharing a cache with the <code>waker</code> thread</strong> to improve cache reuse.</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Scheduling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS161 Assignment 3</title>
    <link href="/2024/10/07/OS161-A3/"/>
    <url>/2024/10/07/OS161-A3/</url>
    
    <content type="html"><![CDATA[<h1 id="assignment3"><a class="markdownIt-Anchor" href="#assignment3"></a> Assignment3</h1><blockquote><p>In this assignment you will solve a synchronization problem using the synchronization primitives in OS161, two of which you have implemented in the previous assignment. You will also learn about having multiple remotes configured for your git clone, and about branching and merging with git.</p></blockquote><h2 id="step-1-prepare"><a class="markdownIt-Anchor" href="#step-1-prepare"></a> <strong>Step 1. Prepare</strong></h2><p>Pull some new code required for this assignment:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add instructor http://dev.ece.ubc.ca/git/OS161<br>git fetch instructor<br>git merge --allow-unrelated-histories instructor/synchprobs<br></code></pre></td></tr></table></figure><p>At this point, git will probably complain about merge conflicts. Follow <a href="https://people.ece.ubc.ca/~os161/os161-site/git-merge.html">this tutorial</a> to resolve them before proceeding.</p><p>Now, push the new code into your master repository and tag your tree to indicate that you are beginning to work on Assignment 3:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push<br>git tag asst3-start<br>git push --tags<br></code></pre></td></tr></table></figure><h2 id="step-2-understand-the-problem"><a class="markdownIt-Anchor" href="#step-2-understand-the-problem"></a> <strong>Step 2. Understand the problem</strong></h2><blockquote><p>Why we need to solve this synchronization problem?</p></blockquote><p>As you will realize in the future programming assignments, which all directly involve <strong>programming kernel services</strong>, proper synchronization among threads is essential. You will not get far if you are unable to properly synchronize the code in the scheduler, virtual memory system and the file system. This exercise lets you practice concurrent programming and the use of synchronization primitives in a less challenging environment.</p><blockquote><p>Here is the synchronization problem you will have to solve. This is a well-known and a very serious known as <code>AirBalloon</code>.</p><p>After a war erupts in their kingdom, Princess Marigold must help Prince Dandelion (her younger brother) escape from danger. Marigold places Dandelion in a hot air balloon, which is connected to the ground by NROPES ropes -- each rope is connected to a hook on the balloon as well as a stake in the ground. Marigold and Dandelion must work together to sever all of these ropes so that Dandelion can escape. Marigold unties the ropes from the ground stakes while Dandelion unhooks the ropes from the balloon. To free a rope it must be either severed from the ground or unhooked from the balloon: not both.</p><p>Unfortunately, one of Princess Marigold and Prince Dandelion's enemy, Lord <code>FlowerKiller</code>, is also at work. <code>FlowerKiller</code> is rearranging the ropes to thwart Princess Marigold and Prince Dandelion. He will randomly switch ropes attached to two different stakes. This leads to chaos!</p><p>Without Lord <code>FlowerKiller's</code> dastardly behavior, there would be a simple 1:1 correspondence between balloon hooks and ground stakes (each hook corresponds to exactly one stake, and each stake corresponds to exactly one hoop). However, while Lord <code>FlowerKiller</code> may break this symmetry. Say, Lord <code>FlowerKiller</code> decides to switch ropes connected to Stake 1 and Stake 5. Before the switch, the rope connected to Stake 1 on the ground is also connected to Hook 1 on the balloon, and the rope connected to Stake 5 on the ground is also connected to Hook 5 on the balloon. After the switch, however, one rope is connected to Stake 1 on the ground and to Hook 5 on the balloon, and vice versa.</p><p>As Marigold and Dandelion cut ropes, they must <strong>delete mappings</strong>, so that they remove all the ropes as efficiently as possible. <strong>Each character is represented by a thread</strong>. Dandelion selects ropes to sever by generating a random balloon hook index, and Marigold selects ropes by generating a random ground stake index.</p><p>Marigold and Dandelion must work as efficiently as possible, so one should not try to disconnect a rope that has already been disconnected. For example, if Dandelion already unhooked a rope, Marigold should see that the rope is hanging loose and not try to unook it from the stake. Similarly, Dandelion should not try to unook a rope that Marigold disconnected on the ground.</p><p>Lord <code>FlowerKiller</code> is on the ground, so like Marigold, he selects ropes by their ground stake index.</p><p>Due to recent advances in genetic technology, there is another unfortunate circumstance: Lord <code>FlowerKiller</code> figured out how to clone himself, so now there are <code>N_LORD_FLOWERKILLER</code> copies of of him at work (each is a separate thread)!</p></blockquote><div class="note note-danger">            <p><strong>problems to avoid in your implementation</strong>:</p><p>Marigold randomly selects Stake 7, sees that the rope is still attached. She marks the rope as severed. Suppose that the hook corresponding to the severed rope is Hook 11. If Dandelion now randomly selects Hook 11, he must see that the rope is severed and not try to sever it again. <strong>What data structures might you use to avoid a race condition in this situation? What would you need to lock to make sure that Marigold and Dandelion don't sever the same rope twice?</strong></p><p>Worse yet, Lord <code>FlowerKiller</code> might be wreaking havoc with the same ropes. For example, imagine that he decides to swap the rope attached to Stake 7 with the rope attached to Stake 4, and vice versa. <strong>How do you make sure to avoid race conditions that this situation creates?</strong></p><p>Now consider how Lord <code>FlowerKillers</code> might step on each other toes. Suppose Lord FlowerKiller1 grabs Stake1 and Stake4 to swap the corresponding ropes, and Lord FlowerKiller2 grabs Stake4 and Stake1. <strong>How might this cause deadlock? What would you do to prevent it?</strong></p>          </div><p>In addition to our character threads, there is also a <strong>Balloon thread</strong> that does not do much. It gets started in the beginning of the program, at the same time as the other threads, and just sits there and <strong>waits until all the ropes have been severed</strong>. Then it announces that Prince Dandelion escaped and exits.</p><h2 id="step-3-understand-the-requirements"><a class="markdownIt-Anchor" href="#step-3-understand-the-requirements"></a> <strong>Step 3. Understand the requirements</strong></h2><p>Your solution must satisfy these conditions:</p><ul><li>Avoid deadlocks and race conditions</li><li>You may use <strong>semaphores, locks and condition variables</strong> available in OS161, but <strong>do not use spinlocks, <code>wchans</code>, or atomic primitives</strong> directly, and <strong>don't turn on/off the interrupts</strong>.</li><li>Permit Marigold, Dandelion and Lord <code>FlowerKiller</code> threads to operate concurrently (<strong>no &quot;big lock&quot; solutions</strong>)</li><li>The Balloon thread exits after all ropes have been severed</li><li>The Main thread (the one that starts all other threads) exits after all threads are done.</li><li>You must <strong>deallocate all the memory</strong> allocated by your code <strong>before all threads exit</strong>. If you don't, there will be a memory leak! We will run your program multiple times to make sure your kernel does not leak.</li><li>Marigold must access the ropes via stakes. She does not have access to hooks. Programmatically, this means that you need to have some kind of data structure representing stakes, which Marigold indexes. Marigold can update stakes and ropes (that are connected to stakes), but she may not update hooks. Similarly, <code>LordFlowerkillers</code> may access ropes via stakes only. Dandelion, on the other hand, may access ropes only via hooks. He cannot see or access stakes.</li></ul><blockquote><p>What your code should print?</p></blockquote><ul><li><p>Every time Marigold severs the rope, the Marigold thread prints: &quot;<strong>Marigold severed rope N from stake K</strong>&quot;, where N is the index of the severed rope, which can range from 0 to NROPES - 1, and K is the index of the stake to which the rope was attached. K also ranges from 0 to NROPES-1. Be sure to print the statement exactly as shown, with no extra characters. The print statement must appear on its own line.</p></li><li><p>Every time Dandelion severs the rope, the Dandelion thread prints: &quot;<strong>Dandelion severed rope N</strong>&quot;, where N is the index of the severed rope, which can range from 0 to NROPES - 1. Be sure to print the statement exactly as shown, with no extra characters. The print statement must appear on its own line.</p></li><li><p>Lord <code>FlowerKiller</code> prints the following statement every time he switches a rope: &quot;<strong>Lord <code>FlowerKiller</code> switched rope N from stake K to stake P</strong>&quot;. N, K and P are corresponding rope and stake indices. If he switches two ropes, which is exactly what he will do every time, <strong>he must print two statements: one for each rope.</strong></p></li><li><p>There must be a print statement for every rope indicating that it was severed by either Dandelion or Marigold.</p></li><li><p>Each rope must be severed exactly one: only one &quot;severed&quot; print statement for each rope.</p></li><li><p>To randomly select a stake to unhook (or two stakes to swap) or a hook, use <strong><code>random()</code></strong> function in OS161.</p></li><li><p>Every time a character succeeded unhooking one rope or switching one pair of ropes, the corresponding thread must yield (<strong>call thread_yield()</strong>).</p></li><li><p>Marigold's print statements must indicate that she is severing the ropes from correct stakes. For example, if there is a print statement from Lord <code>FlowerKiller</code> saying &quot;Lord <code>FlowerKiller</code> switched rope 4 from stake 4 to stake 2&quot;, then Marigold's statement about severing rope 2 must say: &quot;Marigold severed rope 4 from stake 2&quot;. (Dandelion's print statements do print the stake index corresponding to the severed rope, because Dandelion cannot access stakes.)</p></li><li><p>When all ropes have been severed (after the &quot;severed&quot; print statements for all NROPES ropes were displayed), the Balloon thread must print &quot;<strong>Balloon freed and Prince Dandelion escapes!</strong>&quot; and exit.</p></li><li><p>Each thread, except the main one, must print the &quot;thread starting&quot; message just as it begins running. I.e.:</p><blockquote><p>&quot;Dandelion thread starting&quot;</p><p>&quot;Marigold thread starting&quot;</p><p>&quot;Lord <code>FlowerKiller</code> thread starting&quot;</p><p>&quot;Balloon thread starting&quot;</p></blockquote></li><li><p>Each thread, including the main one, must print the &quot;thread done&quot; message just before it exits. I.e.:</p><blockquote><p>&quot;Dandelion thread done&quot;</p><p>&quot;Marigold thread done&quot;</p><p>&quot;Lord <code>FlowerKiller</code> thread done&quot;</p><p>&quot;Balloon thread done&quot;</p><p>&quot;Main thread done&quot;</p></blockquote></li><li><p>The main thread must print only after all other threads have printed their departing statements. That is, the &quot;Main thread done&quot; statement must be the last one to appear before your kernel returns to the main menu.</p></li><li><p>The print statements must be atomic: characters from one print statement must not interleave with another.</p></li><li><p>The print statements from different actors must interleave: for instance you can't have all Dandelion print statements appear together first, and then all Marigold statements appear together. You will accomplish it by <strong>using fine-grained locks</strong> (no one big lock) and by calling <strong><code>thread_yield()</code></strong> every time after Dandelion or Marigold sever the rope or after Lord <code>FlowerKiller</code> switches the ropes.</p></li></ul><h2 id="step-4-write-test-and-debug-the-code"><a class="markdownIt-Anchor" href="#step-4-write-test-and-debug-the-code"></a> <strong>Step 4. Write, test and debug the code</strong></h2><p>configure the kernel:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd kern/conf<br>./config SYNCHPROBS<br>cd ../compile/SYNCHPROBS<br>bmake depend<br>bmake<br>bmake install<br></code></pre></td></tr></table></figure><p>Test your code by <strong>invoking <code>sp1</code></strong> from the kernel menu.</p><p><strong>Debugging tips:</strong></p><ol><li>Get one type of thread working first, e.g., Marigold or Dandelion. Make sure it does not deadlock with itself and otherwise works as you expect. Then add other thread types.</li><li>Deadlocks are easier to debug than race conditions. If you are struggling, <strong>put one big lock around the critical sections that are causing you trouble</strong>. Make sure your code is working. Then gradually reduce the size of the critical section, making your big lock cover a smaller and smaller area of the code, until your code breaks. This way you will narrow down the few lines of code where the error is occurring.</li><li>If you encounter <strong>assertions in the VM system</strong> (e.g., in the kmalloc.c file), chances are you are freeing a pointer that you did not allocate or are doing something else funky with the memory. If your kernel panics on a <strong>TLB fault</strong>, you are probably accessing a pointer that you did not allocate or a null pointer.</li><li>If you need to figure out where a thread is stuck, <strong>print the address of the thread struct</strong> in your code: <code>kprintf(&quot;%p\n&quot;, curthread)</code>;. We will call the pointer that is printed <code>threadaddr</code>. Then you can print the contents of the thread struct in GDB: <code>print *(struct thread) &lt;threadaddr&gt;</code>. You can also figure out which thread holds the lock by printing the lock struct in gdb, for example: <code>print stake-&gt;lk_stake</code>;. If you are keeping track of the lock holder inside the lock structure, that field will show the <code>threadaddr</code> or the holder thread.</li><li>If your code is stuck in a deadlock, you should be able to attach to it with the debugger using the <code>os161-gdb</code> command and following the instructions linked in A1. <em>This should work even if you did not launch your sys161 with -w flag.</em></li></ol><h2 id="my-solution"><a class="markdownIt-Anchor" href="#my-solution"></a> <strong>My Solution</strong></h2><div class="note note-info">            <p>Use the synchronization primitives(lock, CV, semaphore) implemented in A2 to solve this synchronization problem. Specifically, I choose to use a lock for each object in the problem(stake, rope, hook) and use condition variables for some threads to wait for other threads to exit.</p>          </div><blockquote><p>Why and How I represent each object(stake, rope, hook) in the problem?</p></blockquote><p>Object-oriented programming makes this problem easier. Plus, there needs to be some kind of separation between stakes and hooks as they can only operate on their own side of the rope. Use a lock for each object to avoid big lock.</p><p>Also, we need to protect shared global variables if they exist.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Data structures for rope mappings */</span><br><br><span class="hljs-comment">/* rope structure */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">bool</span> is_cut;<br>    <span class="hljs-type">int</span> rope_number;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> *<span class="hljs-title">lock</span>;</span><br>&#125; rope;<br><br><span class="hljs-comment">/* stake structure, containing the connected rope */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    rope *connected_rope;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> *<span class="hljs-title">lock</span>;</span><br>&#125; stake;<br><br><span class="hljs-comment">/* hook structure, containing the connected rope */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    rope *connected_rope;<br>&#125; hook;<br><br><span class="hljs-comment">/* represent each rope, stake and hook */</span><br><span class="hljs-type">static</span> rope ropes[NROPES];<br><span class="hljs-type">static</span> stake stakes[NROPES];<br><span class="hljs-type">static</span> hook hooks[NROPES];<br><br><span class="hljs-comment">/* Synchronization primitives */</span><br><span class="hljs-comment">// protect global variable ropes_left</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> *<span class="hljs-title">ropes_left_lock</span>;</span> <br></code></pre></td></tr></table></figure><blockquote><p>How to have some threads to wait for other threads to exit?</p></blockquote><p>Specifically, I use a condition variable for balloon thread waiting for all dandelion, marigold and flowerkiller threads to exit. I use another cv for main thread waiting for balloon thread to exit.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* CV for balloon thread waiting for all dandelion, marigold and flowerkiller threads done */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cv</span> *<span class="hljs-title">all_threads_done_cv</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> *<span class="hljs-title">threads_exit_lock</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> threads_exited = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* CV for main thread waiting for balloon thread finished. */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cv</span> *<span class="hljs-title">balloon_thread_done_cv</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> *<span class="hljs-title">balloon_exit_lock</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> balloon_finished = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><blockquote><p>Let's go into the core of the problem. What is my design and locking protocols that must be maintained? How do all threads know when they are done?</p></blockquote><p>Use three structures: rope, stake and hook.</p><p>Each rope and stake has its own lock. Actually we don't need a lock for hooks as they always maintain 1:1 correspondence to the ropes. Dandelion accesses each rope only from its hook, required to lock the rope before severing it. Marigold should lock the stake first before accessing the rope from its stake, and lock the rope before severing it. Flowerkiller should lock both stakes first before accessing the ropes from them, and lock the corresponding ropes(in particular order) before swaping them.</p><p>Dandelion and marigold threads should exit when global variable <code>ropes_left = 0</code>.  Flowerkiller threads should exit when global variable <code>ropes_left &lt; 2</code>. Balloon thread should wait for all dandelion, marigold and flowerkillers threads to exit before exiting. Airballoon(main) thread should wait for balloon thread to exit before exiting.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Threads</span><br><br><span class="hljs-comment">/* Dandelion severs ropes from hooks. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dandelion</span><span class="hljs-params">(<span class="hljs-type">void</span> *p, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br>(<span class="hljs-type">void</span>)p;<br>(<span class="hljs-type">void</span>)arg;<br><br>kprintf(<span class="hljs-string">&quot;Dandelion thread starting\n&quot;</span>);<br><br><span class="hljs-comment">/* Implement this function */</span><br><br><span class="hljs-comment">/* Loop until all the ropes have been severed. */</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">/* Check if all the ropes are severed. If so, break and exit. */</span><br>lock_acquire(ropes_left_lock);<br><span class="hljs-keyword">if</span> (ropes_left == <span class="hljs-number">0</span>)<br>&#123;<br>lock_release(ropes_left_lock);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>lock_release(ropes_left_lock);<br><br><span class="hljs-comment">/* Randomly select a hook and get its connected rope. */</span><br><span class="hljs-type">int</span> hook = random() % NROPES;<br>rope *current_rope = hooks[hook].connected_rope;<br><br><span class="hljs-comment">/* If the rope has already been severed by himself, abort. */</span><br><span class="hljs-keyword">if</span> (current_rope == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">/* lock the rope before trying to sever it */</span><br>lock_acquire(current_rope-&gt;lock);<br><span class="hljs-comment">/* If the rope is not severed, sever it from the hook. */</span><br><span class="hljs-keyword">if</span> (!current_rope-&gt;is_cut)<br>&#123;<br>current_rope-&gt;is_cut = <span class="hljs-literal">true</span>;<br>hooks[hook].connected_rope = <span class="hljs-literal">NULL</span>;<br><br>lock_acquire(ropes_left_lock);<br>ropes_left--;<br>kprintf(<span class="hljs-string">&quot;Dandelion severed rope %d\n&quot;</span>, hook);<br>lock_release(ropes_left_lock);<br>&#125;<br>lock_release(current_rope-&gt;lock);<br><span class="hljs-comment">/* give up the cpu and switch to another thread. */</span><br>thread_yield();<br>&#125;<br><br>kprintf(<span class="hljs-string">&quot;Dandelion thread done\n&quot;</span>);<br>notify_thread_exit();<br>thread_exit();<br>&#125;<br><br><span class="hljs-comment">/* Marigold severs ropes from stakes. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">marigold</span><span class="hljs-params">(<span class="hljs-type">void</span> *p, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br>(<span class="hljs-type">void</span>)p;<br>(<span class="hljs-type">void</span>)arg;<br><br>kprintf(<span class="hljs-string">&quot;Marigold thread starting\n&quot;</span>);<br><br><span class="hljs-comment">/* Implement this function */</span><br><br><span class="hljs-comment">/* Loop until all the ropes have been severed. */</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">/* Check if all the ropes are severed. If so, break and exit. */</span><br>lock_acquire(ropes_left_lock);<br><span class="hljs-keyword">if</span> (ropes_left == <span class="hljs-number">0</span>)<br>&#123;<br>lock_release(ropes_left_lock);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>lock_release(ropes_left_lock);<br><br><span class="hljs-comment">/* Randomly select a stake and get its connected rope, protected by its lock. */</span><br><span class="hljs-type">int</span> stake = random() % NROPES;<br>lock_acquire(stakes[stake].lock);<br>rope *current_rope = stakes[stake].connected_rope;<br><br><span class="hljs-comment">/* If the rope has already been severed by herself, abort. */</span><br><span class="hljs-keyword">if</span> (current_rope == <span class="hljs-literal">NULL</span>)<br>&#123;<br>lock_release(stakes[stake].lock);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">/* lock the rope before trying to sever it */</span><br>lock_acquire(current_rope-&gt;lock);<br><span class="hljs-comment">/* If the rope is not severed, sever it from the stake. */</span><br><span class="hljs-keyword">if</span> (!current_rope-&gt;is_cut)<br>&#123;<br>current_rope-&gt;is_cut = <span class="hljs-literal">true</span>;<br>stakes[stake].connected_rope = <span class="hljs-literal">NULL</span>;<br><br>lock_acquire(ropes_left_lock);<br>ropes_left--;<br>kprintf(<span class="hljs-string">&quot;Marigold severed rope %d from stake %d\n&quot;</span>, current_rope-&gt;rope_number, stake);<br>lock_release(ropes_left_lock);<br>&#125;<br><span class="hljs-comment">/* release the lock in reverse order, avoiding deadlock */</span><br>lock_release(current_rope-&gt;lock);<br>lock_release(stakes[stake].lock);<br><span class="hljs-comment">/* give up the cpu and switch to another thread. */</span><br>thread_yield();<br>&#125;<br><br>kprintf(<span class="hljs-string">&quot;Marigold thread done\n&quot;</span>);<br>notify_thread_exit();<br>thread_exit();<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">flowerkiller</span><span class="hljs-params">(<span class="hljs-type">void</span> *p, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br>(<span class="hljs-type">void</span>)p;<br>(<span class="hljs-type">void</span>)arg;<br><br>kprintf(<span class="hljs-string">&quot;Lord FlowerKiller thread starting\n&quot;</span>);<br><br><span class="hljs-comment">/* Implement this function */</span><br><br><span class="hljs-comment">/* Loop until all the ropes have been severed. */</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">/* Check if there are at least two ropes left. If not, break and exit. */</span><br>lock_acquire(ropes_left_lock);<br><span class="hljs-keyword">if</span> (ropes_left &lt; <span class="hljs-number">2</span>)<br>&#123;<br>lock_release(ropes_left_lock);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>lock_release(ropes_left_lock);<br><br><span class="hljs-comment">/* Randomly select two different stakes to swap. */</span><br><span class="hljs-type">int</span> stake1, stake2;<br><span class="hljs-keyword">do</span><br>&#123;<br>stake1 = random() % NROPES;<br>stake2 = random() % NROPES;<br>&#125; <span class="hljs-keyword">while</span> (stake1 == stake2);<br><br><span class="hljs-comment">/* get the smaller stake and bigger stake by their number */</span><br><span class="hljs-type">int</span> first_stake = (stake1 &lt; stake2) ? stake1 : stake2;<br><span class="hljs-type">int</span> second_stake = (stake1 &lt; stake2) ? stake2 : stake1;<br><br><span class="hljs-comment">/* lock the smaller stake first, then lock the bigger stake, avoiding deadlock, before getting the connected ropes */</span><br>lock_acquire(stakes[first_stake].lock);<br>lock_acquire(stakes[second_stake].lock);<br>rope *rope1 = stakes[stake1].connected_rope;<br>rope *rope2 = stakes[stake2].connected_rope;<br><br><span class="hljs-comment">/* If either rope has already been severed from its stake, abort. */</span><br><span class="hljs-keyword">if</span> (rope1 == <span class="hljs-literal">NULL</span> || rope2 == <span class="hljs-literal">NULL</span>)<br>&#123;<br>lock_release(stakes[second_stake].lock);<br>lock_release(stakes[first_stake].lock);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <br><span class="hljs-comment">/* get the smaller rope and bigger rope by their number */</span><br>rope *first_rope = (rope1-&gt;rope_number &lt; rope2-&gt;rope_number) ? rope1 : rope2;<br>rope *second_rope = (rope1-&gt;rope_number &lt; rope2-&gt;rope_number) ? rope2 : rope1;<br><br>        <span class="hljs-comment">/* lock the smaller rope first, then lock the bigger rope, avoiding deadlock, before trying to swap them. */</span><br>lock_acquire(first_rope-&gt;lock);<br>lock_acquire(second_rope-&gt;lock);<br><span class="hljs-comment">/* If neither rope is severed, swap them from their stakes */</span><br><span class="hljs-keyword">if</span> (!rope1-&gt;is_cut &amp;&amp; !rope2-&gt;is_cut)<br>&#123;<br>stakes[stake1].connected_rope = rope2;<br>stakes[stake2].connected_rope = rope1;<br><br>kprintf(<span class="hljs-string">&quot;Lord FlowerKiller switched rope %d from stake %d to stake %d\n&quot;</span>, rope1-&gt;rope_number, stake1, stake2);<br>kprintf(<span class="hljs-string">&quot;Lord FlowerKiller switched rope %d from stake %d to stake %d\n&quot;</span>, rope2-&gt;rope_number, stake2, stake1);<br>&#125;<br><span class="hljs-comment">/* release the lock in reverse order, avoiding deadlock */</span><br>lock_release(second_rope-&gt;lock);<br>lock_release(first_rope-&gt;lock);<br>lock_release(stakes[second_stake].lock);<br>lock_release(stakes[first_stake].lock);<br><span class="hljs-comment">/* give up the cpu and switch to another thread. */</span><br>thread_yield();<br>&#125;<br><br>kprintf(<span class="hljs-string">&quot;Lord FlowerKiller thread done\n&quot;</span>);<br>notify_thread_exit();<br>thread_exit();<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">balloon</span><span class="hljs-params">(<span class="hljs-type">void</span> *p, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br>(<span class="hljs-type">void</span>)p;<br>(<span class="hljs-type">void</span>)arg;<br><br>kprintf(<span class="hljs-string">&quot;Balloon thread starting\n&quot;</span>);<br><br><span class="hljs-comment">/* Implement this function */</span><br><br>    <span class="hljs-comment">/* wait until all dandelion, marigold and flowerkiller threads are done */</span><br>lock_acquire(threads_exit_lock);<br><span class="hljs-keyword">while</span> (threads_exited != N_LORD_FLOWERKILLER + <span class="hljs-number">2</span>)<br>&#123;<br>cv_wait(all_threads_done_cv, threads_exit_lock);<br>&#125;<br>lock_release(threads_exit_lock);<br><br>    <span class="hljs-comment">/* print the messages */</span><br>kprintf(<span class="hljs-string">&quot;Balloon freed and Prince Dandelion escapes!\n&quot;</span>);<br>kprintf(<span class="hljs-string">&quot;Balloon thread done\n&quot;</span>);<br><br><span class="hljs-comment">/* wake up the airballoon(main) thread */</span><br>lock_acquire(balloon_exit_lock);<br>balloon_finished = <span class="hljs-literal">true</span>;<br>cv_signal(balloon_thread_done_cv, balloon_exit_lock);<br>lock_release(balloon_exit_lock);<br><br><span class="hljs-comment">/* then exit */</span><br>thread_exit();<br>&#125;<br><br><span class="hljs-comment">// Change this function as necessary</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">airballoon</span><span class="hljs-params">(<span class="hljs-type">int</span> nargs, <span class="hljs-type">char</span> **args)</span><br>&#123;<br><span class="hljs-type">int</span> err = <span class="hljs-number">0</span>, i;<br><br>(<span class="hljs-type">void</span>)nargs;<br>(<span class="hljs-type">void</span>)args;<br>(<span class="hljs-type">void</span>)ropes_left;<br>    <br>    <span class="hljs-comment">/* Initialize global variables. */</span><br>main_thread_init();<br><br>    <span class="hljs-comment">/* Initialize rope mappings and synchronization primitives. */</span><br>initialize_mappings();<br>initialize_synchronization();<br><br>err = thread_fork(<span class="hljs-string">&quot;Marigold Thread&quot;</span>,<br>  <span class="hljs-literal">NULL</span>, marigold, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> panic;<br><br>err = thread_fork(<span class="hljs-string">&quot;Dandelion Thread&quot;</span>,<br>  <span class="hljs-literal">NULL</span>, dandelion, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> panic;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_LORD_FLOWERKILLER; i++)<br>&#123;<br>err = thread_fork(<span class="hljs-string">&quot;Lord FlowerKiller Thread&quot;</span>,<br>  <span class="hljs-literal">NULL</span>, flowerkiller, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> panic;<br>&#125;<br><br>err = thread_fork(<span class="hljs-string">&quot;Air Balloon&quot;</span>,<br>  <span class="hljs-literal">NULL</span>, balloon, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> panic;<br><br><span class="hljs-keyword">goto</span> done;<br>panic:<br>panic(<span class="hljs-string">&quot;airballoon: thread_fork failed: %s)\n&quot;</span>,<br>  strerror(err));<br><br>done:<br>    <span class="hljs-comment">/* wait until balloon thread is done */</span><br>wait_for_balloon();<br>kprintf(<span class="hljs-string">&quot;Main thread done\n&quot;</span>);<br>cleanup_synchronization();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>As shown in the code, I encapsulate some operations into helper functions in order to clarify the main logic.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Helper functions</span><br><br><span class="hljs-comment">/* This function initializes the main thread global variables. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">main_thread_init</span><span class="hljs-params">()</span> &#123;<br>ropes_left = NROPES;<br>threads_exited = <span class="hljs-number">0</span>;<br>    balloon_finished = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">/* Initialize rope mappings. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">initialize_mappings</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NROPES; ++i)<br>&#123;<br>ropes[i].is_cut = <span class="hljs-literal">false</span>;<br>ropes[i].rope_number = i;<br>ropes[i].lock = lock_create(<span class="hljs-string">&quot;rope lock&quot;</span>);<br><br>stakes[i].connected_rope = &amp;ropes[i];<br>stakes[i].lock = lock_create(<span class="hljs-string">&quot;stake lock&quot;</span>);<br><br>hooks[i].connected_rope = &amp;ropes[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* Initialize sychronization primitives */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">initialize_synchronization</span><span class="hljs-params">()</span><br>&#123;<br>ropes_left_lock = lock_create(<span class="hljs-string">&quot;ropes_left lock&quot;</span>);<br>all_threads_done_cv = cv_create(<span class="hljs-string">&quot;all threads done cv&quot;</span>);<br>threads_exit_lock = lock_create(<span class="hljs-string">&quot;threads exit lock&quot;</span>);<br>balloon_thread_done_cv = cv_create(<span class="hljs-string">&quot;balloon thread done cv&quot;</span>);<br>balloon_exit_lock = lock_create(<span class="hljs-string">&quot;balloon exit lock&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* Clean up synchronization primitives */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">cleanup_synchronization</span><span class="hljs-params">()</span><br>&#123;<br>lock_destroy(ropes_left_lock);<br>cv_destroy(all_threads_done_cv);<br>lock_destroy(threads_exit_lock);<br>cv_destroy(balloon_thread_done_cv);<br>lock_destroy(balloon_exit_lock);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NROPES; ++i)<br>&#123;<br>lock_destroy(ropes[i].lock);<br>lock_destroy(stakes[i].lock);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Dandelion, marigold and all flowerkiller threads should call this right before exiting,</span><br><span class="hljs-comment"> * notifying their exit and waking up balloon thread when all of them have exited.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">notify_thread_exit</span><span class="hljs-params">()</span><br>&#123;<br>lock_acquire(threads_exit_lock);<br>threads_exited++;<br><span class="hljs-keyword">if</span> (threads_exited == N_LORD_FLOWERKILLER + <span class="hljs-number">2</span>)<br>&#123;<br>cv_signal(all_threads_done_cv, threads_exit_lock);<br>&#125;<br>lock_release(threads_exit_lock);<br>&#125;<br><br><span class="hljs-comment">/* Airballoon(main) thread should call this before exiting, waiting for balloon thread to exit. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">wait_for_balloon</span><span class="hljs-params">()</span><br>&#123;<br>lock_acquire(balloon_exit_lock);<br><span class="hljs-keyword">while</span> (!balloon_finished)<br>&#123;<br>cv_wait(balloon_thread_done_cv, balloon_exit_lock);<br>&#125;<br>lock_release(balloon_exit_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>Test sp1 passes!</p><p><img src="../imgs/202410100947774.png" alt="sp1" /></p><p>We have finished Assignment3!😊</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>OS161</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>OS161</tag>
      
      <tag>Synchronization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS161 Assignment 2</title>
    <link href="/2024/09/27/OS161-A2/"/>
    <url>/2024/09/27/OS161-A2/</url>
    
    <content type="html"><![CDATA[<h1 id="assignment2"><a class="markdownIt-Anchor" href="#assignment2"></a> Assignment2</h1><blockquote><p>Use <a href="https://www.gnu.org/prep/standards/html_node/Writing-C.html">this document</a> as a guideline for writing high-quality code.</p></blockquote><blockquote><p>In this assignment you finally get to write your own code in OS161! By the end of this assignment you will:</p><ul><li>Have a good understanding of the implementation of <strong>spinlocks</strong> and <strong>semaphores</strong> in OS161</li><li>Implement locks</li><li>Implement condition variables.</li></ul></blockquote><h2 id="step-1-prepare"><a class="markdownIt-Anchor" href="#step-1-prepare"></a> Step 1. Prepare</h2><p>Make sure you don't have any uncommitted updates in your repo. Now, tag your repository as shown here:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">asst2-start</span><br></code></pre></td></tr></table></figure><p>Now push that new tag:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git push <span class="hljs-comment">--tags</span><br></code></pre></td></tr></table></figure><p>Make a directory submit/asst2 in your os161 tree. You will put your file with the answers to code reading questions in that directory.</p><ul><li><strong>Physical memory and CPUs</strong></li></ul><p>Change <code>sys161.conf</code> file in <code>~/os161/root</code>:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">31 </span>mainboard ramsize=<span class="hljs-number">2097152</span> cpus=<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ul><li><strong>Built-in thread tests</strong></li></ul><p>The thread test code uses the <strong>semaphore synchronization primitive</strong></p><p>You should trace the execution of one of these thread tests in GDB to see <strong>how the scheduler acts</strong>, <strong>how threads are created</strong>, and what exactly happens in a <strong>context switch</strong>. You should be able to step through a call to <code>thread_switch()</code> and see exactly <strong>where</strong> the current thread changes.</p><ul><li><strong>Debugging concurrent programs</strong></li></ul><p><code>thread_yield()</code> is automatically called for you at intervals that vary randomly.</p><p>Change <code>sys161.conf</code> file in <code>~/os161/root</code>:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">28random <span class="hljs-attribute">seed</span>=1<br></code></pre></td></tr></table></figure><p>Once you are done with initial debugging/testing, remember to set the random device back to <code>autoseed</code>.</p><p>This should allow you to <strong>test your solutions under varying conditions</strong> and may expose scenarios that you had not anticipated, which is central to effective testing.</p><h2 id="step-2-code-reading-exercises"><a class="markdownIt-Anchor" href="#step-2-code-reading-exercises"></a> Step 2. Code reading exercises</h2><blockquote><ol><li>What happens to a thread when it exits (i.e., calls thread_exit())? What about when it sleeps?</li></ol></blockquote><p><code>thread_exit()</code> detaches the thread from the process, checks the stack guard band, turns interrupts off on this processor and performs a thread switch(find another thread to run).</p><p><code>thread.c</code> 777:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Cause the current thread to exit.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The parts of the thread structure we don&#x27;t actually need to run</span><br><span class="hljs-comment"> * should be cleaned up right away. The rest has to wait until</span><br><span class="hljs-comment"> * thread_destroy is called from exorcise().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Does not return.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">thread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">cur</span>;</span><br><br>    cur = curthread;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Detach from our process. You might need to move this action</span><br><span class="hljs-comment"> * around, depending on how your wait/exit works.</span><br><span class="hljs-comment"> */</span><br>    proc_remthread(cur);<br><br>    <span class="hljs-comment">/* Make sure we *are* detached (move this only if you&#x27;re sure!) */</span><br>    KASSERT(cur-&gt;t_proc == <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">/* Check the stack guard band. */</span><br>    thread_checkstack(cur);<br><br>    <span class="hljs-comment">/* Interrupts off on this processor */</span><br>    splhigh();<br>    thread_switch(S_ZOMBIE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    panic(<span class="hljs-string">&quot;braaaaaaaiiiiiiiiiiinssssss\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>First, <code>wchan_sleep</code> makes sure that we are not in an interrupt handler, hold the specific  spinlock associated with the wait channel WC and no others. Then, it performs a thread switch, and puts the thread go to sleep on the specified wait channel WC before finding another thread to run. Lastly, when being woken up, it locks the spinlock again before returning.</p><p><code>thread.c</code> 1026:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Yield the cpu to another process, and go to sleep, on the specified</span><br><span class="hljs-comment"> * wait channel WC, whose associated spinlock is LK. Calling wakeup on</span><br><span class="hljs-comment"> * the channel will make the thread runnable again. The spinlock must</span><br><span class="hljs-comment"> * be locked. The call to thread_switch unlocks it; we relock it</span><br><span class="hljs-comment"> * before returning.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">wchan_sleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> wchan *wc, <span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>    <span class="hljs-comment">/* may not sleep in an interrupt handler */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt);<br><br>    <span class="hljs-comment">/* must hold the spinlock */</span><br>    KASSERT(spinlock_do_i_hold(lk));<br><br>    <span class="hljs-comment">/* must not hold other spinlocks */</span><br>    KASSERT(curcpu-&gt;c_spinlocks == <span class="hljs-number">1</span>);<br><br>    thread_switch(S_SLEEP, wc, lk);<br>    spinlock_acquire(lk);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>What function(s) handle(s) a context switch?</li></ol></blockquote><p><code>thread.c</code> 560:</p><p><code>thread_switch()</code></p><p>Machine-dependent functions for working on switchframes:</p><p>During context switch, switch what is saved on the kernel stack.</p><p><code>switchframe_switch()</code></p><blockquote><ol start="3"><li>What does it mean for a thread to be in each of the possible thread states?</li></ol></blockquote><p>During context switching, we need to put the thread in the right place according to its <code>newstate</code>.</p><ul><li><p><strong>S_RUN</strong>:</p><p>For <code>S_RUN</code>, it means the thread is currently running. A thread should never be put into the <code>S_RUN</code> state within <code>thread_switch</code>. But if it does, call panic.</p></li><li><p><strong>S_READY</strong>:A thread in the <code>S_READY</code> state is ready to run but is not currently running. <code>thread_make_runnable</code> is called to add it to the run queue so that the scheduler can pick it up for execution later.</p></li><li><p><strong>S_SLEEP</strong>:A thread in the <code>S_SLEEP</code> state is blocked, waiting to be woken up. The thread is added to the wait channel <code>wc</code>, and it will remain in this state until a wakeup call (like <code>wchan_wake</code>) signals it. After putting the thread on the list, we release the spinlock associated with the wait channel <code>wc</code>.</p></li><li><p><strong>S_ZOMBIE</strong>:A thread in the <code>S_ZOMBIE</code> state has finished its execution but has not yet been fully cleaned up. The thread is added to the CPU's zombie list <code>c_zombies</code>, where it waits to be freed.</p></li></ul><p><code>thread.c</code>: <code>thread_switch()</code>: 595:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Put the thread in the right place. */</span><br><span class="hljs-keyword">switch</span> (newstate) &#123;<br>    <span class="hljs-keyword">case</span> S_RUN:<br>        panic(<span class="hljs-string">&quot;Illegal S_RUN in thread_switch\n&quot;</span>);<br>    <span class="hljs-keyword">case</span> S_READY:<br>        thread_make_runnable(cur, <span class="hljs-literal">true</span> <span class="hljs-comment">/*have lock*/</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> S_SLEEP:<br>        cur-&gt;t_wchan_name = wc-&gt;wc_name;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Add the thread to the list in the wait channel, and</span><br><span class="hljs-comment"> * unlock same. To avoid a race with someone else</span><br><span class="hljs-comment"> * calling wchan_wake*, we must keep the wchan&#x27;s</span><br><span class="hljs-comment"> * associated spinlock locked from the point the</span><br><span class="hljs-comment"> * caller of wchan_sleep locked it until the thread is</span><br><span class="hljs-comment"> * on the list.</span><br><span class="hljs-comment"> */</span><br>        threadlist_addtail(&amp;wc-&gt;wc_threads, cur);<br>        spinlock_release(lk);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> S_ZOMBIE:<br>        cur-&gt;t_wchan_name = <span class="hljs-string">&quot;ZOMBIE&quot;</span>;<br>        threadlist_addtail(&amp;curcpu-&gt;c_zombies, cur);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br>cur-&gt;t_state = newstate;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>What does it mean to turn interrupts off? How is this accomplished? Why is it important to turn off interrupts in the thread subsystem code?</li></ol></blockquote><p>Turning interrupts off means that the current processor is temporarily prevented from responding to hardware interrupts, meaning that the current CPU cannot perform a context switch.</p><p>In os161, turning interrupts off is accomplished by changing the processor's interrupt priority level(IPL). The function <code>splhigh()</code> is used to set the IPL to its highest level to disable all interrupts.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Explicitly disable interrupts on this processor */</span><br>spl = splhigh();<br></code></pre></td></tr></table></figure><p>It is important to turn off interrupts in the thread subsystem code. When we perform operations on threads such as context switching, blocking threads, exit threads, we don't want to be interrupted. If we are interrupted during those operations, we may lose important information of the thread. For example, if we are interrupted during context switching when we are saving the thread's state, we may lose the state during interrupts. Turning off interrupts also helps avoid deadlock and improve performance.</p><blockquote><ol start="5"><li>What happens when a thread wakes up another thread? How does a sleeping thread get to run again?</li></ol></blockquote><p>When a thread wants to wake up another thread, it calls the function <code>wchan_wakeone</code>, the function grabs a thread from the wait channel and then calls <code>thread_make_runnable</code> to make the target thread runnable.</p><p>In <code>thread_make_runnable</code>, the target thread should lock the run queue of the CPU, ensuring only one thread in the run queue can modify the CPU. Then it puts the target thread on the run queue of the CPU.</p><blockquote><ol start="6"><li>What function(s) choose(s) the next thread to run?</li></ol></blockquote><p><code>thread_switch</code></p><blockquote><ol start="7"><li>How does it (do they) pick the next thread?</li></ol></blockquote><p><code>schedule</code> and <code>thread_switch</code> both use <code>threadlist_remhead</code> function, which removes and returns the <strong>first thread</strong> from the run queue of the current CPU, which is the next thread to run.</p><blockquote><ol start="8"><li>What role does the hardware timer play in scheduling? What hardware independent function is called on a timer interrupt?</li></ol></blockquote><p>The hardware timer generates periodic interrupts to allow the operating system to regain control of the CPU at regular intervals, ensuring that it can check the status of threads and make scheduling decisions.</p><p><code>hardclock</code> is the hardware independent function called on a timer interrupt.</p><blockquote><ol start="9"><li>Describe how <code>wchan_sleep()</code> and <code>wchan_wakeone()</code> are used to implement semaphores.</li></ol></blockquote><p>For function <code>V</code>, <code>wchan_wakeone()</code> is called after it increments <code>sem_count</code> and wants to wake up another thread.</p><p>For function <code>P</code>, <code>wchan_sleep</code> is called when <code>sem_count = 0</code> and wants to put the thread to sleep waiting to be awakened. It should be called after we lock the wait channel(using semaphore spinlock) so that we can put the thread to sleep while also release the wait channel lock afterwards. After being woken up, it locks the wait channel again before returning.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-type">char</span> *sem_name;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wchan</span> *<span class="hljs-title">sem_wchan</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">sem_lock</span>;</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> sem_count;<br>&#125;<br><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">V</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span><br>&#123;<br>    KASSERT(sem != <span class="hljs-literal">NULL</span>);<br><br>    spinlock_acquire(&amp;sem-&gt;sem_lock);<br><br>    sem-&gt;sem_count++;<br>    KASSERT(sem-&gt;sem_count &gt; <span class="hljs-number">0</span>);<br>    wchan_wakeone(sem-&gt;sem_wchan, &amp;sem-&gt;sem_lock);<br><br>    spinlock_release(&amp;sem-&gt;sem_lock);<br>&#125;<br><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span><br>&#123;<br>    KASSERT(sem != <span class="hljs-literal">NULL</span>);<br>    KASSERT(curthread-&gt;t_in_interrupt == <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">/* Use the semaphore spinlock to protect the wchan as well. */</span><br>    spinlock_acquire(&amp;sem-&gt;sem_lock);<br>    <span class="hljs-keyword">while</span> (sem-&gt;sem_count == <span class="hljs-number">0</span>) &#123;<br>        wchan_sleep(sem-&gt;sem_wchan, &amp;sem-&gt;sem_lock);<br>        <span class="hljs-comment">// sem_lock is also the wait channel lock.</span><br>        <span class="hljs-comment">// Before returning from sleep, we should relock.</span><br>    &#125;<br>    KASSERT(sem-&gt;sem_count &gt; <span class="hljs-number">0</span>);<br>    sem-&gt;sem_count--;<br>    spinlock_release(&amp;sem-&gt;sem_lock);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="10"><li>How does the implementation of <code>wchan</code> ensure that a thread never misses a wakeup signal: that another thread cannot attempt to awaken the first thread just as it is preparing to sleep, but before it is actually placed into the sleep queue?</li></ol></blockquote><p>In <code>P</code>, <code>wchan_sleep</code> is called after we acquire the semaphore spinlock(<code>spinlock_acquire(&amp;sem-&gt;sem_lock)</code>), which also serves as locking the wait channel. In this way, when we call <code>wchan_sleep</code> to put the current thread to sleep, no other threads can manipulate the wait channel(i.e. by calling <code>wchan_wakeone</code>). That is to say, no threads can sneak in and try to awaken the thread during its &quot;sleep&quot; process.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Use the semaphore spinlock to protect the wchan as well. */</span><br>spinlock_acquire(&amp;sem-&gt;sem_lock);<br><span class="hljs-keyword">while</span> (sem-&gt;sem_count == <span class="hljs-number">0</span>) &#123;<br>    wchan_sleep(sem-&gt;sem_wchan, &amp;sem-&gt;sem_lock);<br>    <span class="hljs-comment">// sem_lock is also the wait channel lock.</span><br>    <span class="hljs-comment">// Before returning from sleep, we should relock.</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="step-3-implement-locks-for-os161"><a class="markdownIt-Anchor" href="#step-3-implement-locks-for-os161"></a> Step 3. Implement locks for OS161</h2><p>The interface for the lock struct is defined in <code>kern/include/synch.h</code>. Stub code is provided in <code>kern/thread/synch.c</code>.</p><p><strong>Requirements:</strong></p><ol><li><strong>Comply to the interface.</strong> Take a look at the stub code provided in <code>kern/thread/synch.c</code>. Your implementation must conform to this API. Please don't change it, as this will break the tests that we will use to test your assignment.</li><li><strong>Mutual exclusion.</strong> It's probably a no-brainer that your locks must provide mutual exclusion. You are going to implement the simplest semantics of locks: only one thread can hold a lock at any given time.</li><li><strong>No busy-waiting.</strong> If you carefully read the OS161 code, you noticed that there is an implementation of spinlocks. Spinlocks derive their name from the method that they use to wait until the lock becomes available: they spin, or busy-wait, hogging the CPU and checking if the lock became available. While this is perfectly fine for short critical section and only on a multiprocessor system (why?), a general implementation of locks must be more universal. We must be able to use them on a system with a single CPU and for long critical sections, e.g., those involving I/O operations, where it makes no sense to busy-wait on the CPU. Therefore, your locks implementation must not busy-wait on a taken lock. It must give up the CPU until the lock becomes available.</li></ol><h3 id="implementation"><a class="markdownIt-Anchor" href="#implementation"></a> Implementation</h3><h4 id="faqs"><a class="markdownIt-Anchor" href="#faqs"></a> FAQs</h4><blockquote><p>How to avoid busy-waiting?</p></blockquote><p>When a thread tries to <strong>acquire</strong> the lock, if the lock is not avaiable, we puts the thread to sleep. After the thread holding the lock <strong>releases</strong> the lock, it wakes up another thread waiting on the wait channel.</p><blockquote><p>How to protect the lock and the wait channel?</p></blockquote><p>We use the spinlock provided by the os161 stub code to protect both the lock and the wait channel.</p><h4 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h4><p>lock structure:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *lk_name;<br>    <span class="hljs-comment">// add what you need here</span><br>    <span class="hljs-comment">// (don&#x27;t forget to mark things volatile as needed)</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lk_hold;        <span class="hljs-comment">/* 0 means the lock is free, while 1 means the lock is held */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wchan</span> *<span class="hljs-title">lk_wchan</span>;</span>      <span class="hljs-comment">/* wait channel, lists of threads waiting to get the lock */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lk_spinlock</span>;</span> <span class="hljs-comment">/* protect the lock and the wait channel */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">lk_holder</span>;</span>    <span class="hljs-comment">/* thread that holds the lock */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>lock methods:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> lock *<span class="hljs-title function_">lock_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">lock_do_i_hold</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *)</span>;<br></code></pre></td></tr></table></figure><p>Methods Implementation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create the lock. */</span><br><span class="hljs-keyword">struct</span> lock *<br>    <span class="hljs-title function_">lock_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> *<span class="hljs-title">lock</span>;</span><br><br>    lock = kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> lock));<br>    <span class="hljs-keyword">if</span> (lock == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    lock-&gt;lk_name = kstrdup(name);<br>    <span class="hljs-keyword">if</span> (lock-&gt;lk_name == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// add stuff here as needed</span><br><br>    spinlock_init(&amp;lock-&gt;lk_spinlock);            <span class="hljs-comment">/* initialize spinlock */</span><br>    lock-&gt;lk_wchan = wchan_create(lock-&gt;lk_name); <span class="hljs-comment">/* create wait channel */</span><br>    <span class="hljs-comment">/* if failing to create wait channel, free the lock */</span><br>    <span class="hljs-keyword">if</span> (lock-&gt;lk_wchan == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(lock-&gt;lk_name);<br>        kfree(lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">/* initially no thread is holding the lock */</span><br>    lock-&gt;lk_holder = <span class="hljs-literal">NULL</span>;<br>    lock-&gt;lk_hold = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> lock;<br>&#125;<br><br><span class="hljs-comment">/* Clean up the lock. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// add stuff here as needed</span><br><br>    <span class="hljs-comment">/* acquire the spinlock making sure no other threads can modify the lock */</span><br>    spinlock_acquire(&amp;lock-&gt;lk_spinlock);<br><br>    KASSERT(!lock-&gt;lk_hold);                                    <span class="hljs-comment">/* make sure the lock is not used */</span><br>    KASSERT(lock-&gt;lk_holder == <span class="hljs-literal">NULL</span>);                           <span class="hljs-comment">/* make sure no thread is holding the lock */</span><br>    KASSERT(wchan_isempty(lock-&gt;lk_wchan, &amp;lock-&gt;lk_spinlock)); <span class="hljs-comment">/* make sure wait channel is empty */</span><br><br>    spinlock_release(&amp;lock-&gt;lk_spinlock);<br><br>    wchan_destroy(lock-&gt;lk_wchan);        <span class="hljs-comment">/* destroy the wait channel */</span><br>    spinlock_cleanup(&amp;lock-&gt;lk_spinlock); <span class="hljs-comment">/* clean up the spinlock */</span><br><br>    <span class="hljs-comment">/* clean up the lock structure */</span><br>    kfree(lock-&gt;lk_name);<br>    kfree(lock);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get the lock. Only one thread can hold the lock at the same time.</span><br><span class="hljs-comment"> * If the lock is held by another thread, put the current thread to sleep.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">/* must not acquire the lock in an interrupt handler */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt);<br><br>    <span class="hljs-comment">/* acquire the spinlock, protecting the lock and the wait channel */</span><br>    spinlock_acquire(&amp;lock-&gt;lk_spinlock);<br><br>    <span class="hljs-comment">/* if the lock is held by other threads, put the current thread to sleep */</span><br>    <span class="hljs-keyword">while</span> (lock-&gt;lk_hold)<br>    &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * wchan_sleep would unlocks the spinlock before sleeping, and</span><br><span class="hljs-comment">                 * acquire the spinlock again before returning.</span><br><span class="hljs-comment">                 */</span><br>        wchan_sleep(lock-&gt;lk_wchan, &amp;lock-&gt;lk_spinlock);<br>    &#125;<br><br>    <span class="hljs-comment">/* acquire the lock for the current thread */</span><br>    lock-&gt;lk_hold = <span class="hljs-number">1</span>;<br>    lock-&gt;lk_holder = curthread;<br><br>    spinlock_release(&amp;lock-&gt;lk_spinlock);<br>&#125;<br><br><span class="hljs-comment">/* Free the lock. Only the thread holding the lock can do this. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">/* make sure the current thread is holding the lock */</span><br>    KASSERT(lock_do_i_hold(lock));<br><br>    <span class="hljs-comment">/* acquire the spinlock, protecting the lock and the wait channel */</span><br>    spinlock_acquire(&amp;lock-&gt;lk_spinlock);<br><br>    <span class="hljs-comment">/* free the lock */</span><br>    lock-&gt;lk_hold = <span class="hljs-number">0</span>;<br>    lock-&gt;lk_holder = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">/* wake up a thread waiting on the wait channel */</span><br>    wchan_wakeone(lock-&gt;lk_wchan, &amp;lock-&gt;lk_spinlock);<br><br>    spinlock_release(&amp;lock-&gt;lk_spinlock);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Returns true if the current thread is holding the lock.</span><br><span class="hljs-comment"> * Otherwise, return false.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">lock_do_i_hold</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">/* if there is no current thread, nobody is holding the lock */</span><br>    <span class="hljs-keyword">if</span> (curthread == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* acquire the spinlock before checking whether the current threads holds the lock */</span><br>    spinlock_acquire(&amp;lock-&gt;lk_spinlock);<br>    <span class="hljs-type">bool</span> do_i_hold = (lock-&gt;lk_holder == curthread);<br>    spinlock_release(&amp;lock-&gt;lk_spinlock);<br><br>    <span class="hljs-keyword">return</span> do_i_hold;<br>&#125;<br></code></pre></td></tr></table></figure><p>test <code>sy2</code> passes!</p><img src="../imgs/202409251839431.png" alt="" style="zoom: 80%;" /><h2 id="step-4-implement-condition-variables-for-os161"><a class="markdownIt-Anchor" href="#step-4-implement-condition-variables-for-os161"></a> Step 4. Implement condition variables for OS161</h2><p><strong>Requirements:</strong></p><p>Just like with locks, your solution must:</p><ol><li>Comply to the existing interface.</li><li>Implement proper cv semantics as explained <a href="https://sites.google.com/view/cpen331fall2024/assignments/assignment-2">here</a>.</li><li>Not use busy-waiting to wait on cv.</li></ol><h3 id="implementation-2"><a class="markdownIt-Anchor" href="#implementation-2"></a> Implementation</h3><h4 id="faqs-2"><a class="markdownIt-Anchor" href="#faqs-2"></a> FAQs</h4><blockquote><p>How to protect the wait channel?</p></blockquote><p>Again, we use the spinlock provided by the os161 stub code to protect the wait channel.</p><blockquote><p>What do we do in <code>wait()</code>?</p></blockquote><p>First, we check that we hold the lock.</p><p>Then, release the lock and go to sleep, protected by the spinlock.</p><p>The <code>sleep()</code> function releases the spinlock and atomatically re-acquires the spinlock before returning.</p><p>Therefore, after <code>sleep</code> returns, we need to release the spinlock explicitly and re-acquire the lock before returning.</p><blockquote><p>Do we need to release the lock in <code>signal()</code> after we wake up another thread.</p></blockquote><p>No. Users who use the cv should explicitly releases the lock after they call <code>signal</code>. It is not <code>signal()</code>'s responsibility to do so. So is the <code>broadcast()</code> function.</p><h4 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> Code</h4><p>CV structure:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cv</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *cv_name;<br>    <span class="hljs-comment">// add what you need here</span><br>    <span class="hljs-comment">// (don&#x27;t forget to mark things volatile as needed)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wchan</span> *<span class="hljs-title">cv_wchan</span>;</span>     <span class="hljs-comment">/* lists of threads waiting on the cv */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">cv_lock</span>;</span>    <span class="hljs-comment">/* protect the wait channel */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>CV methods:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> cv *<span class="hljs-title function_">cv_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_signal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_broadcast</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span>;<br></code></pre></td></tr></table></figure><p>Methods Implementation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create the cv. */</span><br><span class="hljs-keyword">struct</span> cv *<br>    <span class="hljs-title function_">cv_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cv</span> *<span class="hljs-title">cv</span>;</span><br><br>    cv = kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> cv));<br>    <span class="hljs-keyword">if</span> (cv == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    cv-&gt;cv_name = kstrdup(name);<br>    <span class="hljs-keyword">if</span> (cv-&gt;cv_name == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(cv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// add stuff here as needed</span><br><br>    cv-&gt;cv_wchan = wchan_create(cv-&gt;cv_name); <span class="hljs-comment">/* create the wait channel */</span><br>    <span class="hljs-comment">/* if failing to create wait channel, free the cv */</span><br>    <span class="hljs-keyword">if</span> (cv-&gt;cv_wchan == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(cv-&gt;cv_name);<br>        kfree(cv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    spinlock_init(&amp;cv-&gt;cv_lock); <span class="hljs-comment">/* initialize the spinlock */</span><br><br>    <span class="hljs-keyword">return</span> cv;<br>&#125;<br><br><span class="hljs-comment">/* Clean up the cv. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv)</span><br>&#123;<br>    KASSERT(cv != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// add stuff here as needed</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * acquire the spinlock making sure no other threads can modify the cv</span><br><span class="hljs-comment">         * when we check the wait channel is empty.</span><br><span class="hljs-comment">         */</span><br>    spinlock_acquire(&amp;cv-&gt;cv_lock);<br>    KASSERT(wchan_isempty(cv-&gt;cv_wchan, &amp;cv-&gt;cv_lock));<br>    spinlock_release(&amp;cv-&gt;cv_lock);<br><br>    wchan_destroy(cv-&gt;cv_wchan);    <span class="hljs-comment">/* destroy the wait channel */</span><br>    spinlock_cleanup(&amp;cv-&gt;cv_lock); <span class="hljs-comment">/* clean up the spinlock */</span><br><br>    kfree(cv-&gt;cv_name);<br>    kfree(cv);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Release the supplied lock, go to sleep, and, after</span><br><span class="hljs-comment"> * waking up again, re-acquire the lock.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(cv != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock_do_i_hold(lock));       <span class="hljs-comment">/* check the current thread is holding the lock passed in */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt); <span class="hljs-comment">/* make sure we are not in an interrupt handler */</span><br><br>    <span class="hljs-comment">/* acquire the spinlock, protecting the wait channel */</span><br>    spinlock_acquire(&amp;cv-&gt;cv_lock);<br><br>    <span class="hljs-comment">/* release the lock passed in */</span><br>    lock_release(lock);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Before wchan_sleep puts the current thread to sleep, it releases the spinlock.</span><br><span class="hljs-comment">         * Before returning from wchan_sleep, it relocks the spinlock.</span><br><span class="hljs-comment">         */</span><br>    wchan_sleep(cv-&gt;cv_wchan, &amp;cv-&gt;cv_lock);<br><br>    spinlock_release(&amp;cv-&gt;cv_lock);<br><br>    <span class="hljs-comment">/* After waking up, re-acquire the lock passed in again before returning. */</span><br>    lock_acquire(lock);<br>&#125;<br><br><span class="hljs-comment">/* Wake up one thread that&#x27;s sleeping on the cv. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_signal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(cv != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock_do_i_hold(lock));       <span class="hljs-comment">/* check the current thread is holding the lock passed in */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt); <span class="hljs-comment">/* make sure we are not in an interrupt handler */</span><br><br>    <span class="hljs-comment">/* acquire the spinlock before manipulating the wait channel */</span><br>    spinlock_acquire(&amp;cv-&gt;cv_lock);<br><br>    <span class="hljs-comment">/* wake up one thread waiting on the cv */</span><br>    wchan_wakeone(cv-&gt;cv_wchan, &amp;cv-&gt;cv_lock);<br><br>    spinlock_release(&amp;cv-&gt;cv_lock);<br>&#125;<br><br><span class="hljs-comment">/* Wake up all threads sleeping on the cv. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_broadcast</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(cv != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock_do_i_hold(lock));       <span class="hljs-comment">/* check the current thread is holding the lock passed in */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt); <span class="hljs-comment">/* make sure we are not in an interrupt handler */</span><br><br>    <span class="hljs-comment">/* acquire the spinlock before manipulating the wait channel */</span><br>    spinlock_acquire(&amp;cv-&gt;cv_lock);<br><br>    <span class="hljs-comment">/* wake up all threads waiting on the cv */</span><br>    wchan_wakeall(cv-&gt;cv_wchan, &amp;cv-&gt;cv_lock);<br><br>    spinlock_release(&amp;cv-&gt;cv_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>Test <code>sy3</code> and <code>sy4</code> pass!</p><center class="half">    <img src="../imgs/202409252300462.png" width="400"/>    <img src="../imgs/202409252301416.png" width="400"/> </center><p>We have finished Assignment2!😊</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>OS161</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>OS161</tag>
      
      <tag>Synchronization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synchronization</title>
    <link href="/2024/09/26/Synchronization/"/>
    <url>/2024/09/26/Synchronization/</url>
    
    <content type="html"><![CDATA[<p>In this part, we will introduce the concepts of synchronization, some hardware support for synchronization, and some synchronization primitives/objects. This part is crucial for you to implementing OS161 Assignment 2&amp;3 correctly!</p><h1 id="synchronization"><a class="markdownIt-Anchor" href="#synchronization"></a> Synchronization</h1><blockquote><p><strong>Learning Materials</strong></p><p>Videos:</p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/synch-overview.mp4">Overview of synchronization</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/cs161-video-materials/www.eecs.harvard.edu/~margo/cs161/videos/synch-types.mp4">Synchronization types</a></p><p>Lecture Slides:</p><p><a href="https://people.ece.ubc.ca/os161/LECTURE-SLIDES/TAS-lock-pitfalls.pptx">Test-and-set locks in-depth</a></p><p><a href="https://people.ece.ubc.ca/os161/LECTURE-SLIDES/Synch-patterns.pptx">Synchronization patterns</a></p><p><a href="https://people.ece.ubc.ca/os161/LECTURE-SLIDES/Synchronization.pptx">Synchronization</a></p><p>Readings:</p><p><a href="https://people.ece.ubc.ca/~os161/download/synchronization.c">Semaphore implementation exercise</a></p><p><a href="https://cs.brown.edu/courses/csci0300/2024/index.html">Brown csci0300</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf">OSTEP] Concurrency: An Introduction</a></p><p><a href="http://www.barrgroup.com/Embedded-Systems/How-To/C-Volatile-Keyword">The volatile keyword explained</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/#ConditionVariables">Condition variables</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/protected/spinlock-chapter.pdf">spinlock-chapter.pdf (9.2 - 9.5.1)</a></p><p><a href="https://people.ece.ubc.ca/~os161/class-site/mesa-semantics.html">Mesa semantics</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks-usage.pdf">OSTEP] Concurrent data structures</a></p><p>[<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf">OSTEP] Condition variables and bounded buffer problem</a></p><p><a href="https://medium.com/@sasha_f/treacherous-shared-counters-2307d3df2cc8">Treacherous shared counters</a></p><p><a href="http://queue.acm.org/detail.cfm?id=2088916">You don't know jack about shared variables or memory models -- Data races are evil.</a></p><p>Supplementary:</p><p><a href="https://cs.brown.edu/courses/csci0300/2024/notes/l24.html">Bounded Buffer (Brown csci0300 LEC24)</a></p><p><a href="https://cs.brown.edu/courses/csci0300/2024/notes/l25.html">Condition Variables, Distributed Systems, and <code>Sharding</code> (Brown csci0300 LEC25)</a></p></blockquote><h2 id="key-concepts"><a class="markdownIt-Anchor" href="#key-concepts"></a> Key Concepts</h2><ul><li>Threads</li></ul><p>All threads within the same process <strong>share the same virtual address space</strong> and <strong>file descriptor table</strong>, but each thread has its <strong>own set of registers and stack</strong>.</p><img src="../imgs/202409261810347.png" alt="" style="zoom:60%;" /><img src="../imgs/202409162207497-1740397021871-1.png" alt="" style="zoom:80%;" /><ul><li>Synchronization</li></ul><p>Sometimes multiple threads need to access and operate on shared resources. Synchronization provides mutual exclusion between threads.</p><blockquote><p>Why we do we need synchronization?</p></blockquote><p>If two or more threads concurrently access an object, and at least one of the accesses is a write, a <strong>race condition</strong> can occur and synchronization is required.</p><ul><li>Mutual Exclusion</li></ul><p><strong>mutex</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::mutex mutex;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">threadfunc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span>* x)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10000000</span>; ++i) &#123;<br>        mutex.lock();<br>        *x += <span class="hljs-number">1</span>;<br>        mutex.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>spinlock</strong>:</p><p><code>spinlock.swap()</code> is one atomic step stores the specified value to the atomic <code>spinlock</code> variable and returns the old value of the variable.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::atomic spinlock;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (spinlock.swap(<span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        spinlock.store(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Critical Section</li></ul><p>The mutual exclusion policy is enforced in the code region between the <code>lock()</code> and <code>unlock()</code> invocations. We call this region the <em><strong>critical section</strong></em>.</p><ul><li>Deadlock</li></ul><img src="../imgs/202409182316777.png" style="zoom: 25%;" /><img src="../imgs/202409261214362.png" alt="" style="zoom: 67%;" /><h2 id="hardware-support"><a class="markdownIt-Anchor" href="#hardware-support"></a> Hardware Support</h2><h3 id="hardware-primitives"><a class="markdownIt-Anchor" href="#hardware-primitives"></a> Hardware Primitives</h3><blockquote><p>In this part, we will introduce some hardware primitives that use atomic instructions to achieve mutual exclusion. Atomic instructions are the hardware basis for implementing synchronization.</p></blockquote><h4 id="cascompare-and-swap"><a class="markdownIt-Anchor" href="#cascompare-and-swap"></a> CAS(Compare and Swap)</h4><p><code>old</code> is the value we assume <code>*p</code> would be. If they are not the same, it means someone else sneak in and change the <code>*p</code>, so we need to abort and try again</p><img src="../imgs/202409241220158.png" alt="" style="zoom:67%;" /><p>Hardware implementation: Compare the contents of a memory location with a value; If they are the same, modify the memory location to a new value.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Set Compare Value Application Register to 0<br>cpmxchg loc, 1<br>if ZF == 1    //The compare was true and you have the lock!<br></code></pre></td></tr></table></figure><p><strong>example:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(account, amount)</span> <br>&#123;<br>    <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(!success)<br>    &#123;<br>        balance = get_balance(account);<br>        new_balance = balance - amount;<br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">         * If balance has been changed by another thread,</span><br><span class="hljs-comment">         * just try again.</span><br><span class="hljs-comment">         */</span><br>        success = CAS(balance, &amp;account-&gt;balance,<br>                      new_balance);<br>    &#125; <br>    <span class="hljs-keyword">return</span> balance;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>typical use of CAS:</strong></p><ol><li>implement locks</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> lockObtained = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> locked;<br><br>retry:<br><span class="hljs-comment">/* Spin while the lock looks taken */</span><br><span class="hljs-keyword">while</span>(lock-&gt;locked) ;         <br><br><span class="hljs-comment">/* Read the state of the lock */</span><br>locked = lock-&gt;locked;<br><span class="hljs-comment">/* If it is locked, try again */</span><br><span class="hljs-keyword">if</span>(locked)  <br>    <span class="hljs-keyword">goto</span> retry;<br><br><span class="hljs-comment">/* Try to get the lock */</span><br>lockObtained = CAS(locked, &amp;lock-&gt;locked, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/* If we could not get the lock, try again */</span><br><span class="hljs-keyword">if</span>(! lockObtained)<br>    <span class="hljs-keyword">goto</span> retry;<br></code></pre></td></tr></table></figure><ol start="2"><li>update shared counters</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">while</span>(!success) &#123;<br>    <span class="hljs-type">int</span> old_val = counter;<br><br>    success = CAS(old_val, &amp;counter, old_val + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><img src="../imgs/202409261208607.png" alt="" style="zoom:60%;" /><blockquote><p>Why performance drop using non-synchronized counters?</p></blockquote><p><strong>coherency protocol</strong> (Hardware does synchronization anyway!):</p><p>Every core has its own private cache. If a copy of the same memory location happens to live in caches of other cores, the hardware will make sure that these copies have consistent values. So it will <strong>send messages</strong> to other caches to either <strong>invalidate</strong> the old copy or to <strong>forward</strong> the new value.</p><p>Writes to the shared counter cause invalidations in hardware caches. Invalidations clog the system bus and delay instructions. Hardware synchronization is very expensive!</p><hr /><h4 id="test-and-settas"><a class="markdownIt-Anchor" href="#test-and-settas"></a> Test-and-set(TAS)</h4><p>TAS on Intel:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">src = <span class="hljs-number">1</span><br>xchg lock_var, src    <span class="hljs-comment">//exchange the value</span><br><span class="hljs-keyword">if</span> (src == <span class="hljs-number">0</span>)    <span class="hljs-comment">//You got the lock!</span><br></code></pre></td></tr></table></figure><p>We will talk more about TAS when we learn the implementation of spinlock.</p><hr /><h4 id="llscload-link-store-conditional"><a class="markdownIt-Anchor" href="#llscload-link-store-conditional"></a> LL/SC(load link &amp; store conditional)</h4><p>SC only succeeds if the location hasn't changed since the last LL.</p><p>LL/SC on MIPS:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">//r1 contains address of the spinlock<br>LL r2, (r1)    //Load value referenced by r1 into r2<br>if r2 is 0 (unlocked)<br>        SC r3, (r1)    //Store &quot;locked&quot; into location referenced by r1<br>        //r3 contains 0 on failure<br>if (r2 != 0 || r3 is 0) <br>        goto retry<br></code></pre></td></tr></table></figure><h3 id="volatile-keyword"><a class="markdownIt-Anchor" href="#volatile-keyword"></a> <code>Volatile</code> keyword</h3><p>A variable should be declared volatile whenever its value could change <strong>unexpectedly</strong>:</p><ol><li>Memory-mapped peripheral <strong>registers</strong></li><li>Global variables modified by an <strong>interrupt service routine</strong></li><li>Global variables accessed by multiple tasks within a <strong>multi-threaded</strong> application</li></ol><img src="../imgs/202409171219021.png" alt="" style="zoom:60%;" /><h3 id="cache"><a class="markdownIt-Anchor" href="#cache"></a> Cache</h3><h4 id="multiprocessor"><a class="markdownIt-Anchor" href="#multiprocessor"></a> Multiprocessor</h4><p>Each core has its own cache:</p><img src="../imgs/202409241119699.png" alt="" style="zoom:60%;" /><hr /><h4 id="cache-miss"><a class="markdownIt-Anchor" href="#cache-miss"></a> cache miss</h4><p>Every core has its own private cache.</p><p>When a processor reads from an address in memory, it first checks whether that address and its contents are present in its cache. If so, then the processor has a <strong>cache hit</strong>. If not, then it has a <strong>cache miss</strong>.</p><p><strong>cache miss</strong>: When a cache got the data, but was invalidated by another cache.</p><p>Exercise:</p><img src="../imgs/202410011125421.png" alt=""  /><p>Solution:</p><img src="../imgs/202410011134578.png" alt="" /><hr /><h4 id="data-race"><a class="markdownIt-Anchor" href="#data-race"></a> Data Race</h4><blockquote><p>Why hardware optimization (cache) may cause problems?</p></blockquote><p>Real machines and compilers sometimes result in non-sequentially-consistent executions:</p><p>The blue thread's write to <code>done</code> may be saved in its cache first.</p><p>In some architectures, the blue thread’s write to <code>done</code> may become visible to the red thread, running on another core, <strong>before</strong> the blue thread’s write to x.</p><img src="../imgs/202409281726294.png" alt="" style="zoom:50%;" /><p>For more information, see <a href="http://queue.acm.org/detail.cfm?id=2088916">You don't know jack about shared variables or memory models -- Data races are evil.</a></p><h2 id="synchronization-primitives"><a class="markdownIt-Anchor" href="#synchronization-primitives"></a> Synchronization Primitives</h2><h3 id="synchronization-variables"><a class="markdownIt-Anchor" href="#synchronization-variables"></a> Synchronization Variables</h3><p>Synchronization Variables avoid locking overhead, which is expensive.</p><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counter</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// atomic counter</span><br><br><span class="hljs-comment">// Multiple threads can operate on counter safely</span><br>counter++;  <span class="hljs-comment">// atomic operation</span><br>counter += <span class="hljs-number">5</span>;  <span class="hljs-comment">// atomic operation</span><br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>Synchronization variables are difficult to use for <strong>complex data structures</strong>, since there is no easy way to make multiple updates to a data structure in one atomic operation</p>          </div><h3 id="wait-channels"><a class="markdownIt-Anchor" href="#wait-channels"></a> Wait Channels</h3><p>An abstraction that lets a thread wait on a certain event.</p><p>Includes a lock and a queue.</p><h2 id="synchronization-objects"><a class="markdownIt-Anchor" href="#synchronization-objects"></a> Synchronization Objects</h2><blockquote><p>Synchronization objects are types whose methods can be used to achieve synchronization and atomicity on normal (non-<code>std::atomic</code>-wrapped) objects.</p></blockquote><h3 id="lock"><a class="markdownIt-Anchor" href="#lock"></a> Lock</h3><p>A regular lock puts a thread to sleep and triggers context switch when someone else has already acquired the lock.</p><p>mutex:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mutex;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadfunc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span>* x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10000000</span>; ++i) &#123;<br>        mutex.<span class="hljs-built_in">lock</span>();<br>        *x += <span class="hljs-number">1</span>;<br>        mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><h4 id="lock-based-concurrent-data-structures"><a class="markdownIt-Anchor" href="#lock-based-concurrent-data-structures"></a> Lock-based Concurrent Data Structures</h4><blockquote><p>How to add to locks to data structures?</p></blockquote><h5 id="concurrent-counters"><a class="markdownIt-Anchor" href="#concurrent-counters"></a> Concurrent Counters</h5><ul><li>Basic Counting</li></ul><p>Simply add a lock for the counter structure.</p><ul><li>Scalable Counting</li></ul><p>Each CPU has its own local counter and there is a global counter.</p><p>Once a local counter reaches threshold S, it updates the global counter.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">counter_t</span> &#123;</span><br>    <span class="hljs-type">int</span> global; <span class="hljs-comment">// global counter</span><br>    <span class="hljs-type">pthread_mutex_t</span> glock; <span class="hljs-comment">// global lock</span><br>    <span class="hljs-type">int</span> local[NUMCPUS]; <span class="hljs-comment">// per-CPU local counter</span><br>    <span class="hljs-type">pthread_mutex_t</span> llock[NUMCPUS]; <span class="hljs-comment">// local locks</span><br>    <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// threshold</span><br>&#125; <span class="hljs-type">counter_t</span>;<br><br><span class="hljs-comment">// init: record threshold, init locks, init values</span><br><span class="hljs-comment">// of all local counts and global count</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">counter_t</span> *c, <span class="hljs-type">int</span> threshold)</span> &#123;<br>    c-&gt;threshold = threshold;<br>    c-&gt;global = <span class="hljs-number">0</span>;<br>    pthread_mutex_init(&amp;c-&gt;glock, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUMCPUS; i++) &#123;<br>        c-&gt;local[i] = <span class="hljs-number">0</span>;<br>        pthread_mutex_init(&amp;c-&gt;llock[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// update: usually, just grab local lock and update</span><br><span class="hljs-comment">// local amount; once it has risen ’threshold’,</span><br><span class="hljs-comment">// grab global lock and transfer local values to it</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">counter_t</span> *c, <span class="hljs-type">int</span> threadID, <span class="hljs-type">int</span> amt)</span> &#123;<br>    <span class="hljs-comment">//which cpu is the thread on is determined by its thread ID</span><br>    <span class="hljs-type">int</span> cpu = threadID % NUMCPUS;<br>    <span class="hljs-comment">//acquire the local lock</span><br>    pthread_mutex_lock(&amp;c-&gt;llock[cpu]);<br>    c-&gt;local[cpu] += amt;<br>    <span class="hljs-keyword">if</span> (c-&gt;local[cpu] &gt;= c-&gt;threshold) &#123;<br>        <span class="hljs-comment">// transfer to global (assumes amt&gt;0)</span><br>        pthread_mutex_lock(&amp;c-&gt;glock);<br>        c-&gt;global += c-&gt;local[cpu];<br>        pthread_mutex_unlock(&amp;c-&gt;glock);<br>        c-&gt;local[cpu] = <span class="hljs-number">0</span>;<br>    &#125;<br>    pthread_mutex_unlock(&amp;c-&gt;llock[cpu]);<br>&#125;s<br><br><span class="hljs-comment">// get: just return global amount (approximate)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">counter_t</span> *c)</span> &#123;<br>    pthread_mutex_lock(&amp;c-&gt;glock);<br>    <span class="hljs-type">int</span> val = c-&gt;global;<br>    pthread_mutex_unlock(&amp;c-&gt;glock);<br>    <span class="hljs-keyword">return</span> val; <span class="hljs-comment">// only approximate!</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>More concurrency(more locks) isn't necessarily faster!</p>          </div><h5 id="concurrent-linked-list"><a class="markdownIt-Anchor" href="#concurrent-linked-list"></a> Concurrent Linked List</h5><ul><li>Basic Concurrent Linked List</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">List_Init</span><span class="hljs-params">(<span class="hljs-type">list_t</span> *L)</span> &#123;<br>    L-&gt;head = <span class="hljs-literal">NULL</span>;<br>    pthread_mutex_init(&amp;L-&gt;lock, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">List_Insert</span><span class="hljs-params">(<span class="hljs-type">list_t</span> *L, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-comment">// synchronization not needed</span><br>    <span class="hljs-type">node_t</span> *new = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<br>    <span class="hljs-keyword">if</span> (new == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;malloc&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    new-&gt;key = key;<br>    <span class="hljs-comment">// just lock critical section</span><br>    pthread_mutex_lock(&amp;L-&gt;lock);<br>    new-&gt;next = L-&gt;head;<br>    L-&gt;head = new;<br>    pthread_mutex_unlock(&amp;L-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// success</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">List_Lookup</span><span class="hljs-params">(<span class="hljs-type">list_t</span> *L, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-type">int</span> rv = <span class="hljs-number">-1</span>;<br>    pthread_mutex_lock(&amp;L-&gt;lock);<br>    <span class="hljs-type">node_t</span> *curr = L-&gt;head;<br>    <span class="hljs-keyword">while</span> (curr) &#123;<br>        <span class="hljs-keyword">if</span> (curr-&gt;key == key) &#123;<br>            rv = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        curr = curr-&gt;next;<br>    &#125;<br>    pthread_mutex_unlock(&amp;L-&gt;lock);<br>    <span class="hljs-keyword">return</span> rv; <span class="hljs-comment">// now both success and failure</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Scaling Linked List</li></ul><p>Add a lock per node of the list.</p><p>However, the performance is not better than using a single lock.</p><h5 id="concurrent-queues"><a class="markdownIt-Anchor" href="#concurrent-queues"></a> Concurrent Queues</h5><p>A tail lock for enqueue and a head lock for dequeue.</p><p>Add a dummy node to the queue separate enqueue and dequeue operations, enables better concurrency.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">node_t</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">node_t</span> *<span class="hljs-title">next</span>;</span><br>&#125; <span class="hljs-type">node_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">queue_t</span> &#123;</span><br>    <span class="hljs-type">node_t</span> *head;<br>    <span class="hljs-type">node_t</span> *tail;<br>    <span class="hljs-type">pthread_mutex_t</span> head_lock, tail_lock;<br>&#125; <span class="hljs-type">queue_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Queue_Init</span><span class="hljs-params">(<span class="hljs-type">queue_t</span> *q)</span> &#123;<br>    <span class="hljs-type">node_t</span> *tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<br>    tmp-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//Add a dummy node to the queue.</span><br>    q-&gt;head = q-&gt;tail = tmp;<br>    pthread_mutex_init(&amp;q-&gt;head_lock, <span class="hljs-literal">NULL</span>);<br>    pthread_mutex_init(&amp;q-&gt;tail_lock, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Queue_Enqueue</span><span class="hljs-params">(<span class="hljs-type">queue_t</span> *q, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-type">node_t</span> *tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<br>    assert(tmp != <span class="hljs-literal">NULL</span>);<br>    tmp-&gt;value = value;<br>    tmp-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    pthread_mutex_lock(&amp;q-&gt;tail_lock);<br>    q-&gt;tail-&gt;next = tmp;<br>    q-&gt;tail = tmp;<br>    pthread_mutex_unlock(&amp;q-&gt;tail_lock);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Queue_Dequeue</span><span class="hljs-params">(<span class="hljs-type">queue_t</span> *q, <span class="hljs-type">int</span> *value)</span> &#123;<br>    pthread_mutex_lock(&amp;q-&gt;head_lock);<br>    <span class="hljs-type">node_t</span> *tmp = q-&gt;head;<br>    <span class="hljs-type">node_t</span> *new_head = tmp-&gt;next;<br>    <span class="hljs-keyword">if</span> (new_head == <span class="hljs-literal">NULL</span>) &#123;<br>        pthread_mutex_unlock(&amp;q-&gt;head_lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// queue was empty</span><br>    &#125;<br>    *value = new_head-&gt;value;<br>    q-&gt;head = new_head;<br>    pthread_mutex_unlock(&amp;q-&gt;head_lock);<br>    <span class="hljs-built_in">free</span>(tmp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="concurrent-hash-table"><a class="markdownIt-Anchor" href="#concurrent-hash-table"></a> Concurrent Hash Table</h5><p>Use the list we built above as a bucket.</p><p>That is to say, we use a lock per hash bucket, each of which is represented by a list.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUCKETS (101)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">hash_t</span> &#123;</span><br>    <span class="hljs-type">list_t</span> lists[BUCKETS];<br>&#125; <span class="hljs-type">hash_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Hash_Init</span><span class="hljs-params">(<span class="hljs-type">hash_t</span> *H)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BUCKETS; i++)<br>        List_Init(&amp;H-&gt;lists[i]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Hash_Insert</span><span class="hljs-params">(<span class="hljs-type">hash_t</span> *H, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">return</span> List_Insert(&amp;H-&gt;lists[key % BUCKETS], key);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Hash_Lookup</span><span class="hljs-params">(<span class="hljs-type">hash_t</span> *H, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">return</span> List_Lookup(&amp;H-&gt;lists[key % BUCKETS], key);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>Hash table has far better performance than simply a linked list!</p>          </div><h3 id="spinlock"><a class="markdownIt-Anchor" href="#spinlock"></a> Spinlock</h3><p>A regular lock puts a thread to sleep and triggers context switch when someone else has already acquired the lock. While a spinlock avoids context switch by keeping the CPU busy testing if the lock becomes available continuously.</p><blockquote><p>Why spinlock implementation in os161 does both disabling interrupts and spinning</p></blockquote><p>Disabling interrupts when acquiring the spinlock prevents the CPU from switching to another thread which may tries to acquire the same spinlock, potentially causing a deadlock.</p><p>That is to say, when a CPU is holding the spinlock, we don't want it to switch to another thread. When the current thread releases the spinlock, we can re-enable interrupts.</p><p>Therefore, we can say spinlock is held by CPU.</p><hr /><h4 id="test-and-set-locks-in-depth"><a class="markdownIt-Anchor" href="#test-and-set-locks-in-depth"></a> Test-and-Set locks in-depth</h4><blockquote><p>How can we improve the performance of spinlock?</p></blockquote><h5 id="tastest-and-set"><a class="markdownIt-Anchor" href="#tastest-and-set"></a> TAS(test-and-set)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TASLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (state.getAndSet(<span class="hljs-literal">true</span>)) &#123;&#125; <span class="hljs-comment">// spin while true</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123; <br>        state.set(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ttastest-test-and-set"><a class="markdownIt-Anchor" href="#ttastest-test-and-set"></a> TTAS(test-test-and-set)</h5><blockquote><p>Can we further optimize spinning?</p></blockquote><img src="../imgs/202409191125150-1740397057572-4.png" alt="" style="zoom:60%;" /><p>Yes, since test-and-set is expensive, we can test-and-test-and-set!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(lock)</span> <br>&#123; <br>    retry:<br>    <span class="hljs-keyword">while</span>(lock-&gt;held)    <span class="hljs-comment">//test first</span><br>        ; <span class="hljs-comment">//spin</span><br>    <span class="hljs-keyword">if</span>(test_and_set(&amp;lock-&gt;held))    <span class="hljs-comment">//test and set</span><br>        <span class="hljs-keyword">goto</span> retry; <span class="hljs-comment">//lock not acquired</span><br>&#125; <br></code></pre></td></tr></table></figure><img src="../imgs/202409241145650.png" alt="" /><p>When someone releases the lock, that core will send the invalidation message, and other threads will know the lock is freed and try to acquire it.</p><p>Performance:</p><img src="../imgs/202409241146785.png" alt="" style="zoom:60%;" /><blockquote><p>Why still not ideal?</p></blockquote><p>When a lock is released, everyone tries to acquire it. Everyone is trying to load the data from the cache, although only one thread can actually acquire the lock. i.e. invalidation message will be sent to multiple threads.</p><blockquote><p>How can we avoid this waste?</p></blockquote><h5 id="a-solution-ttas-lock-with-backoff"><a class="markdownIt-Anchor" href="#a-solution-ttas-lock-with-backoff"></a> A solution: TTAS Lock with Backoff</h5><p>For a specific thread,</p><p>If I fail to get the lock there must be contention</p><p>So I should back off before trying again(no need to try again immediately)</p><p>Introduce a <strong>random “sleep” delay</strong> before trying to acquire the lock again</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ttas_lock</span><span class="hljs-params">(TTASLock *lock)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// First test: wait until lock seems available (flag is clear)</span><br>        <span class="hljs-keyword">while</span> (lock-&gt;flag) &#123;<br>            <span class="hljs-comment">// Lock is busy. Wait and retry.</span><br>        &#125;<br>        <span class="hljs-comment">// Second test: Try to set the flag</span><br>        <span class="hljs-keyword">if</span> (!atomic_flag_test_and_set(&amp;lock-&gt;flag)) &#123;<br>            <span class="hljs-comment">// Acquired the lock</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Contention occurred, </span><br>            <span class="hljs-comment">// back off before trying again</span><br>            backoff();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><h4 id="anderson-queue-lock"><a class="markdownIt-Anchor" href="#anderson-queue-lock"></a> Anderson Queue Lock</h4><p>Each thread spins on its own location.</p><p>We only need to send invalidation message to the next thread.</p><p>T: &quot;Ture&quot; means the lock is available.</p><img src="../imgs/202409241159164.png" alt="" style="zoom:50%;" /><p>Array-Based queue lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ALock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-comment">// thread−local variable, each thread has its own mySlot</span><br>    ThreadLocal&lt;Integer&gt; mySlot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Integer&gt; ()&#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Integer <span class="hljs-title function_">initialValue</span> <span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;;<br>    AtomicInteger tail;<br>    <span class="hljs-type">boolean</span>[] flag;<br>    <span class="hljs-type">int</span> size ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ALock</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        size = capacity;<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>        flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[capacity];<br>        flag [<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slot</span> <span class="hljs-operator">=</span> tail.getAndIncrement() % size;<br>        mySlot.set(slot);<br>        <span class="hljs-comment">//Each thread spins on its own location</span><br>        <span class="hljs-keyword">while</span> (!flag[mySlot.get()]) &#123;&#125;; <span class="hljs-comment">// spin</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        flag [mySlot.get ()] = <span class="hljs-literal">false</span>;<br>        flag [(mySlot.get() + <span class="hljs-number">1</span>) % size] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>Contention can still occur because of <strong>false sharing</strong>:</p><img src="../imgs/202410011943446.png" alt="" style="zoom: 80%;" /><blockquote><p>How to solve it?</p></blockquote><p><strong>Padding</strong>: Map distinct elements to distinct cache lines.</p><img src="../imgs/202410011944559.png" alt="" style="zoom:80%;" />          </div><p>Performance:</p><p>Nearly ideal!</p><img src="../imgs/202409241209739.png" alt="" style="zoom: 67%;" /><h3 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h3><p>Uniprocessor Semaphores using SPL:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> count;<br>&#125;<br><br>P (<span class="hljs-keyword">struct</span> semaphore *sem) &#123;<br>    <span class="hljs-type">int</span> spl;<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        spl = splhigh();    <span class="hljs-comment">//disable interrupts, save current priority level</span><br>        <span class="hljs-keyword">if</span> (sem-&gt;count &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        thread_sleep(sem);<br>        splx(spl);    <span class="hljs-comment">//restore the interrupt priority level before sleeping</span><br>    &#125;<br>    <br>    sem-&gt;count--;<br>    splx(spl);    <span class="hljs-comment">//restore priority interrupt level</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br>V(<span class="hljs-keyword">struct</span> semaphore *sem) &#123;<br>    <span class="hljs-type">int</span> spl;<br>    <br>    spl = splhigh();<br>    sem-&gt;count++;<br>    thread_wakeup(sem);<br>    splx(spl);<br>&#125;<br></code></pre></td></tr></table></figure><p>Multiprocessor:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> tas;    <span class="hljs-comment">//the protection of count, meaning that if a thread holds the test-and-set, no other threads can modify the count. Obviously, holding the test-and-set operation should be atomic, namely (TAS(sem-&gt;tas) != 0)</span><br>&#125;<br><br>V(<span class="hljs-keyword">struct</span> semaphore *sem) &#123;<br>    <span class="hljs-type">int</span> spl;<br>    <br>    spl = splhigh();<br>    <span class="hljs-keyword">while</span>(TAS(sem-&gt;tas != <span class="hljs-number">0</span>));    <span class="hljs-comment">//Only break when sem-&gt;tas = 0 and we set it to 1, meaning that the thread holds the test-and-set on the semaphore    </span><br>    sem-&gt;count++; <br>    sem-&gt;tas = <span class="hljs-number">0</span>;    <span class="hljs-comment">//release the test-and-set</span><br>    thread_wakeup(sem);<br>    splx(spl)；<br>&#125;<br><br>P(<span class="hljs-keyword">struct</span> semaphore *sem) &#123;<br>    <span class="hljs-type">int</span> spl;<br>    spl = splhigh();    <span class="hljs-comment">//make sure to disable interrupt when we use test-and-set</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">while</span>(TAS(sem-&gt;tas) != <span class="hljs-number">0</span>);    <span class="hljs-comment">//Only break when sem-&gt;tas = 0 and we set it to 1, meaning that the thread holds the test-and-set on the semaphore</span><br>        <span class="hljs-keyword">if</span> (sem-&gt;count &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        sem-&gt;tas = <span class="hljs-number">0</span>;    <span class="hljs-comment">//release the test-and-set;</span><br>        thread_sleep(sem);<br>    &#125;<br>    sem-&gt;count--;<br>    sem-&gt;tas = <span class="hljs-number">0</span>;<br>    splx(spl);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Serious problem! Wake-up Loss!</p><p>==<strong>OS/161 Solution:</strong>==</p><blockquote><p>How do we solve the problem of wake-up loss?</p></blockquote><p>The wait channel should be locked when a thread wants to go to sleep.</p><p>The sleep operation should release the wait channel lock after go to sleep.</p><p>The wakeup operation should acquire the wait channel lock first. If the channel is locked, it means someone is trying to go to sleep, so the wakeup operation should block.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-type">char</span> *sem_name;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wchan</span> *<span class="hljs-title">sem_wchan</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">sem_lock</span>;</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> sem_count;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">V</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span> &#123;<br>    KASSERT(sem != <span class="hljs-literal">NULL</span>);<br>    <br>    spinlock_acquire(&amp;sem-&gt;sem_lock);<br>    <br>    sem-&gt;sem_count++;<br>    KASSERT(sem-&gt;sem_count &gt; <span class="hljs-number">0</span>);<br>    wchan_wakeone(sem-&gt;sem_wchan); <span class="hljs-comment">//require the wait channel lock</span><br>    <br>    spinlock_release(&amp;sem-&gt;sem_lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span> &#123;<br>    KASSERT(sem != <span class="hljs-literal">NULL</span>);<br>    KASSERT(curthread-&gt;t_in_interrupt == <span class="hljs-literal">false</span>); <span class="hljs-comment">//make sure current thread is not in an interrupt context</span><br>    spinlock_acquire(&amp;sem-&gt;sem_lock);<br>    <span class="hljs-keyword">while</span>(sem-&gt;sem_count == <span class="hljs-number">0</span>) &#123;<br>        wchan_lock(sem-&gt;sem_wchan); <span class="hljs-comment">//obtain the lock on the wait channel, preventing other threads(V operation) coming in and manipulating the queue(wake up someone)</span><br>        spinlock_release(&amp;sem-&gt;sem_lock); <span class="hljs-comment">//lock the wait channel before release the sem_lock, making sure nobody can sneak in and take the sem_lock to manipulate the wait channel before we go to sleep(for example, V can sneak in and wake up other threads since the wait channel has not been locked.)</span><br>        wchan_sleep(sem-&gt;sem_wchan); <span class="hljs-comment">//go to sleep while also release the wait channel lock</span><br>        <br>        spinlock_acquire(&amp;sem-&gt;sem_lock);<br>    &#125;<br>    KASSERT(sem-&gt;sem_count &gt; <span class="hljs-number">0</span>);<br>    sem-&gt;sem_count--;<br>    spinlock_release(&amp;sem-&gt;sem_lock);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="condition-variables"><a class="markdownIt-Anchor" href="#condition-variables"></a> Condition Variables</h3><p>A condition variable is always paired with one single lock</p><p>Three methods:</p><ol><li><p><code>cv_wait</code>: block until the condition becomes true(atomically release the lock and go to sleep waiting to be waken)</p></li><li><p><code>cv_broadcast</code>: wake all threads waiting on this condition variable</p></li><li><p><code>cv_signal</code>: wake a single thread waiting on this condition variable</p></li></ol><p>These three methods support the <strong>Waiting and Signaling</strong> mechanism of CV.</p><ul><li>Waiting and Signaling</li></ul><p><code>pthread_cond_wait()</code> blocks the calling thread until the specified condition is signaled. This routine should be called while mutex is locked, and it will automatically release the mutex while it waits.</p><p>After signal is received and thread is awakened, mutex will be automatically locked for use by the thread.</p><p>When the thread finishes, unlock the lock explicitly.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lock the mutex</span><br>...<br>    <br><span class="hljs-comment">//when condition is reached, call signal()</span><br>signal();<br><br><span class="hljs-comment">// unlock the mutex to allow a matching wait routine to complete</span><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>Hold the lock when calling <code>wait</code>! (<code>wait</code> will release the lock before going to sleep and reacquire the lock before returning!)</p><p>Always hold the lock while signaling!(not mandatory)</p><p><strong>Mesa Semantics</strong>: Always use while loop to check the waited condition.</p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lock the mutex</span><br>...<br><br><span class="hljs-keyword">while</span> (check the condition) &#123;<br>    wait();    <span class="hljs-comment">//wait on the condition variable</span><br>&#125;    <span class="hljs-comment">//wait will automatically and automically release the lock</span><br><br><span class="hljs-comment">// After being awakened, mutex will be automatically locked</span><br></code></pre></td></tr></table></figure><p>An example:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 5</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE]; <span class="hljs-comment">// Shared buffer</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;           <span class="hljs-comment">// Items in buffer</span><br><br><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-type">pthread_cond_t</span> cond_produce = PTHREAD_COND_INITIALIZER;<br><span class="hljs-type">pthread_cond_t</span> cond_consume = PTHREAD_COND_INITIALIZER;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        pthread_mutex_lock(&amp;mutex);<br><br>        <span class="hljs-comment">// Buffer is full, wait for consumer</span><br>        <span class="hljs-keyword">while</span> (count == BUFFER_SIZE) &#123;<br>            <span class="hljs-comment">//wait on the condition variable cond_produce</span><br>            <span class="hljs-comment">//automically release the mutex, and relock it before returning</span><br>            pthread_cond_wait(&amp;cond_produce, &amp;mutex);<br>            <span class="hljs-comment">//After waking up, we need to check the condition again as mesa semantics makes no guarantee.</span><br>        &#125;<br><br>        <span class="hljs-comment">// Produce an item</span><br>        buffer[count] = i;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Produced: %d\n&quot;</span>, i);<br>        count++;<br>        i++;<br><br>        <span class="hljs-comment">// Signal consumer that an item is produced</span><br>        <span class="hljs-comment">// atomic action</span><br>        pthread_cond_signal(&amp;cond_consume);    <br>        <span class="hljs-comment">//After signal, remember to release the lock explicitly!</span><br>        pthread_mutex_unlock(&amp;mutex);<br><br>        sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// Simulate time to produce</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        pthread_mutex_lock(&amp;mutex);<br><br>        <span class="hljs-comment">// If buffer is empty, wait for producer</span><br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//wait on the condition variable cond_consume, and automically release the mutex</span><br>            pthread_cond_wait(&amp;cond_consume, &amp;mutex);<br>            <span class="hljs-comment">//When being awaken, mutex will be automatically locked.</span><br>        &#125;<br><br>        <span class="hljs-comment">// Consume an item</span><br>        count--;<br>        <span class="hljs-type">int</span> item = buffer[count];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Consumed: %d\n&quot;</span>, item);<br><br>        <span class="hljs-comment">// Signal producer that an item is consumed</span><br>        <span class="hljs-comment">// atomic action</span><br>        pthread_cond_signal(&amp;cond_produce);<br>        <span class="hljs-comment">//After signal, remember to release the lock explicitly!</span><br>        pthread_mutex_unlock(&amp;mutex);<br><br>        sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// Simulate time to consume</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> prod_thread, cons_thread;<br><br>    <span class="hljs-comment">// Create producer and consumer threads</span><br>    pthread_create(&amp;prod_thread, <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;cons_thread, <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Wait for both threads to finish (they won&#x27;t, in this example)</span><br>    pthread_join(prod_thread, <span class="hljs-literal">NULL</span>);<br>    pthread_join(cons_thread, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><h4 id="a-typical-usage-of-cv-bounded-buffer"><a class="markdownIt-Anchor" href="#a-typical-usage-of-cv-bounded-buffer"></a> A typical usage of CV: Bounded Buffer</h4><p>cyclic buffer:</p><img src="../imgs/l18-bounded-buffer-1740222672645-50.png" alt="" style="zoom: 80%;" /><p>Unsynchronized buffer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bbuffer</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> bcapacity = <span class="hljs-number">128</span>;<br>    <span class="hljs-type">char</span> bbuf_[bcapacity];<br>    <span class="hljs-type">size_t</span> bpos_ = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> blen_ = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> write_closed_ = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> sz)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> sz)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdown_write</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">bbuffer::write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> sz)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-keyword">this</span>-&gt;write_closed_);<br>    <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pos &lt; sz &amp;&amp; <span class="hljs-keyword">this</span>-&gt;blen_ &lt; bcapacity) &#123;<br>        <span class="hljs-comment">/* calculate the position where we write */</span><br>        <span class="hljs-type">size_t</span> bindex = (<span class="hljs-keyword">this</span>-&gt;bpos_ + <span class="hljs-keyword">this</span>-&gt;blen_) % bcapacity;<br>        <span class="hljs-keyword">this</span>-&gt;bbuf_[bindex] = buf[pos];<br>        ++<span class="hljs-keyword">this</span>-&gt;blen_;<br>        ++pos;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span> &amp;&amp; sz &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// try again</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> pos;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">bbuffer::read</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> sz)</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pos &lt; sz &amp;&amp; <span class="hljs-keyword">this</span>-&gt;blen_ &gt; <span class="hljs-number">0</span>) &#123;<br>        buf[pos] = <span class="hljs-keyword">this</span>-&gt;bbuf_[<span class="hljs-keyword">this</span>-&gt;bpos_];<br>        <span class="hljs-keyword">this</span>-&gt;bpos_ = (<span class="hljs-keyword">this</span>-&gt;bpos_ + <span class="hljs-number">1</span>) % bcapacity;<br>        --<span class="hljs-keyword">this</span>-&gt;blen_;<br>        ++pos;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span> &amp;&amp; sz &gt; <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-keyword">this</span>-&gt;write_closed_) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// try again</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> pos;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bbuffer::shutdown_write</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;write_closed_ = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Synchronized buffer:</p><p>Use a lock to protect the internal state of the buffer(shared variables, not local variables).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bbuffer</span> &#123;<br>    ...<br><br>    std::mutex mutex_;<br><br>    ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">bbuffer::write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> sz)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;mutex_.<span class="hljs-built_in">lock</span>();<br><br>    ...<br><br>    <span class="hljs-keyword">this</span>-&gt;mutex_.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span> &amp;&amp; sz &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// try again</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> pos;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">bbuffer::read</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> sz)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;mutex_.<span class="hljs-built_in">lock</span>();<br><br>    ...<br><br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span> &amp;&amp; sz &gt; <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-keyword">this</span>-&gt;write_closed_) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;mutex_.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// try again</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>-&gt;mutex_.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> pos;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Use a <strong>C++ scoped lock</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">bbuffer::write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> sz)</span> </span>&#123;<br>    <span class="hljs-comment">/* lock the mutex for the scope of the function */</span><br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">guard</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;mutex_)</span></span>;<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-keyword">this</span>-&gt;write_closed_);<br>    <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pos &lt; sz &amp;&amp; <span class="hljs-keyword">this</span>-&gt;blen_ &lt; bcapacity) &#123;<br>        <span class="hljs-type">size_t</span> bindex = (<span class="hljs-keyword">this</span>-&gt;bpos_ + <span class="hljs-keyword">this</span>-&gt;blen_) % bcapacity;<br>        <span class="hljs-keyword">this</span>-&gt;bbuf_[bindex] = buf[pos];<br>        ++<span class="hljs-keyword">this</span>-&gt;blen_;<br>        ++pos;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Why not efficient?</p></blockquote><p>Bounded buffer simply returns -1 if <code>read</code> or <code>write</code> fails, and retry immediately.</p><p>We need another synchronization object: <strong>Condition Variable</strong></p><p>By using a Condition Variable, the writer should wait on cv <code>nonfull_</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">bbuffer::write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> sz)</span> </span>&#123;<br>    <span class="hljs-comment">/* `guard` is a scoped lock that locks the mutex for the scope of the function */</span><br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">guard</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;mutex_)</span></span>;<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-keyword">this</span>-&gt;write_closed_);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>-&gt;blen_ == bcapacity) &#123;  <br>        <span class="hljs-comment">// #1</span><br>        <span class="hljs-keyword">this</span>-&gt;nonfull_.<span class="hljs-built_in">wait</span>(guard);<br>    &#125;<br>    <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pos &lt; sz &amp;&amp; <span class="hljs-keyword">this</span>-&gt;blen_ &lt; bcapacity) &#123;<br>        <span class="hljs-type">size_t</span> bindex = (<span class="hljs-keyword">this</span>-&gt;bpos_ + <span class="hljs-keyword">this</span>-&gt;blen_) % bcapacity;<br>        <span class="hljs-keyword">this</span>-&gt;bbuf_[bindex] = buf[pos];<br>        ++<span class="hljs-keyword">this</span>-&gt;blen_;<br>        ++pos;<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">bbuffer::read</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> sz)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">guard</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;mutex_)</span></span>;<br>    ...<br>    <span class="hljs-keyword">while</span> (pos &lt; sz &amp;&amp; <span class="hljs-keyword">this</span>-&gt;blen_ &gt; <span class="hljs-number">0</span>) &#123;<br>        buf[pos] = <span class="hljs-keyword">this</span>-&gt;bbuf_[<span class="hljs-keyword">this</span>-&gt;bpos_];<br>        <span class="hljs-keyword">this</span>-&gt;bpos_ = (<span class="hljs-keyword">this</span>-&gt;bpos_ + <span class="hljs-number">1</span>) % bcapacity;<br>        --<span class="hljs-keyword">this</span>-&gt;blen_;<br>        ++pos;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pos &gt; <span class="hljs-number">0</span>) &#123;                   <br>        <span class="hljs-comment">// #2</span><br>        <span class="hljs-keyword">this</span>-&gt;nonfull_.<span class="hljs-built_in">notify_all</span>();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="other-synchronization-objects"><a class="markdownIt-Anchor" href="#other-synchronization-objects"></a> other synchronization objects</h3><ul><li>monitors</li></ul><p>Provide API-level synchronization typically built in languages or libraries</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Synchronization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS161 Assignment 1</title>
    <link href="/2024/09/16/OS161-A1/"/>
    <url>/2024/09/16/OS161-A1/</url>
    
    <content type="html"><![CDATA[<h1 id="assignment1"><a class="markdownIt-Anchor" href="#assignment1"></a> Assignment1</h1><p>The purpose of this assignment is to get you started with OS/161.</p><p>By the time you complete this assignment, you will have mastered the following:</p><ul><li>Install the environment for running OS/161</li><li>Set up and use a git source control repository for your source code.</li><li>Fetch and build the kernel source tree.</li><li>Become familiar with the OS/161 source tree.</li><li>Learn the basics of using the debugger.</li></ul><h2 id="step-1-os161-installation"><a class="markdownIt-Anchor" href="#step-1-os161-installation"></a> Step 1. OS/161 installation</h2><h3 id="1-set-up-the-environment"><a class="markdownIt-Anchor" href="#1-set-up-the-environment"></a> 1. Set up the environment</h3><p>Use the tools in a Docker container.</p><h4 id="prep-the-work-directory-for-docker"><a class="markdownIt-Anchor" href="#prep-the-work-directory-for-docker"></a> Prep the work directory for Docker</h4><ul><li>clone the repository</li></ul><p>Clone the repository with SSH.</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">... src</span><br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>Clone the repository in <code>wsl</code>. Clone the repo in windows bash causes <code>invalid path error</code>.</p>          </div><blockquote><p>Reference: <a href="https://people.ece.ubc.ca/~os161/os161-site/git-intro.html">An introductory guide to git</a></p></blockquote><ul><li>Additional Configuration</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;yourname@server.ca&quot;</span><br></code></pre></td></tr></table></figure><ul><li>Merging Conflicts</li></ul><blockquote><p>Reference: <a href="https://people.ece.ubc.ca/~os161/os161-site/git-merge.html">Tutorial</a></p></blockquote><h4 id="build-the-container"><a class="markdownIt-Anchor" href="#build-the-container"></a> Build the container</h4><p>Download and run the script to set up the Docker container with the required environment for running os161.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">wget https:<span class="hljs-comment">//people.ece.ubc.ca/~os161/download/os161-cpen331-docker.tar.gz</span><br>gunzip os161-cpen331-docker<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><br>tar -xvf os161-cpen331-docker<span class="hljs-selector-class">.tar</span><br>cd os161-cpen331-docker<br>docker build -t os161 .<br></code></pre></td></tr></table></figure><h4 id="run-the-container"><a class="markdownIt-Anchor" href="#run-the-container"></a> Run the container</h4><p>The following command will run the Docker container and will mount your home directory so that it is accessible from within the container. In the following command replace /home/OS_BASE with the name of the current directory.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> -dit --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,src=/home/OS_BASE,target=/root/os161 --<span class="hljs-built_in">rm</span> --name os161 os161</span><br></code></pre></td></tr></table></figure><p>The previous command printed the container ID, which you will use for the next command. You may also obtain the container ID anytime by running:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker ps</span><br></code></pre></td></tr></table></figure><p>Next you will get a shell to enter your container, using the container ID.</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">exec</span> -it [<span class="hljs-keyword">container</span> ID]/[<span class="hljs-keyword">container</span> name] /bin/bash<br></code></pre></td></tr></table></figure><p>Now you are inside the container! In other words, you are running inside the guest. Execute the following command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/os161<br></code></pre></td></tr></table></figure><p>The os161 directory you just entered maps to <code>home/OS161_BASE</code> on the host. In that directory you will see the clone of your repo that you brought into <code>src</code> directory.</p><h3 id="2-build-os-161-configure-and-build-the-source-tree"><a class="markdownIt-Anchor" href="#2-build-os-161-configure-and-build-the-source-tree"></a> 2. Build OS 161 — configure and build the source tree</h3><blockquote><p>Reference: <a href="http://www.os161.org/resources/building.html">The OS161 building instructions</a></p></blockquote><h4 id="configure-the-tree"><a class="markdownIt-Anchor" href="#configure-the-tree"></a> Configure the tree</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/os161/src<br>./configure --ostree=<span class="hljs-variable">$HOME</span>/os161/root<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>Use <code>.gitignore</code> to tell the version control system to ignore the file <code>defs.mk</code>.</p>          </div><h4 id="build-userland"><a class="markdownIt-Anchor" href="#build-userland"></a> Build userland</h4><p>Type <code>bmake</code> in the top level of the source tree:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bmake</span><br></code></pre></td></tr></table></figure><p>Type <code>bmake install</code> to copy the results into ~/os161/root:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">bmake <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h4 id="configure-a-kernel"><a class="markdownIt-Anchor" href="#configure-a-kernel"></a> Configure a kernel</h4><p>Run the OS/161 config program:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> kern/conf<br>./config DUMBVM<br></code></pre></td></tr></table></figure><h4 id="compile-a-kernel"><a class="markdownIt-Anchor" href="#compile-a-kernel"></a> Compile a kernel</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/os161/src/kern/compile/DUMBVM<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bmake depend</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bmake</span><br></code></pre></td></tr></table></figure><p>Copy the kernel to ~/os161/root:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">bmake <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h4 id="run-the-kernel"><a class="markdownIt-Anchor" href="#run-the-kernel"></a> Run the kernel</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/os161/root<br></code></pre></td></tr></table></figure><p>You will run os161 on top sys161 -- a MIPS hardware simulator. So first you need to get a configuration file for sys161.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget people.ece.ubc.ca/os161/download/sys161.conf.sample -O ~/os161/root/sys161.conf<br></code></pre></td></tr></table></figure><p>Now run your kernel:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sys161</span> kernel<br></code></pre></td></tr></table></figure><h2 id="step-2-tag-your-repository"><a class="markdownIt-Anchor" href="#step-2-tag-your-repository"></a> Step 2. Tag your repository</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">asst1-start</span><br>git push --tags<br></code></pre></td></tr></table></figure><h2 id="step-3-create-your-submit-file"><a class="markdownIt-Anchor" href="#step-3-create-your-submit-file"></a> Step 3. Create your submit file</h2><p>create submit file in <code>src</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> submit<br><span class="hljs-built_in">cd</span> submit<br><span class="hljs-built_in">mkdir</span> asst1<br><span class="hljs-built_in">cd</span> asst1<br><span class="hljs-built_in">touch</span> asst1-answers.md<br></code></pre></td></tr></table></figure><h2 id="step-4-copy-some-output-from-git-commands-into-your-submit-file"><a class="markdownIt-Anchor" href="#step-4-copy-some-output-from-git-commands-into-your-submit-file"></a> Step 4. Copy some output from git commands into your submit file</h2><ol><li>invoke sys161 with the newly built kernel</li></ol><p>input:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/os161/root<br>sys161 kernel<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sys161</span>: System/<span class="hljs-number">161</span> release <span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>, compiled Sep  <span class="hljs-number">5</span> <span class="hljs-number">2024</span> <span class="hljs-number">20</span>:<span class="hljs-number">22</span>:<span class="hljs-number">57</span><br><br><span class="hljs-attribute">OS</span>/<span class="hljs-number">161</span> base system version <span class="hljs-number">1</span>.<span class="hljs-number">99</span>.<span class="hljs-number">08</span><br><span class="hljs-attribute">Copyright</span> (c) <span class="hljs-number">2000</span>, <span class="hljs-number">2001</span>-<span class="hljs-number">2005</span>, <span class="hljs-number">2008</span>-<span class="hljs-number">2011</span>, <span class="hljs-number">2013</span>, <span class="hljs-number">2014</span><br>   <span class="hljs-attribute">President</span> and Fellows of Harvard College.  <span class="hljs-literal">All</span> rights reserved.<br><br><span class="hljs-attribute">Put</span>-your-group-name-here&#x27;s system version <span class="hljs-number">0</span> (DUMBVM #<span class="hljs-number">2</span>)<br><br><span class="hljs-attribute">292k</span> physical memory available<br><span class="hljs-attribute">Device</span> probe...<br><span class="hljs-attribute">lamebus0</span> (system main bus)<br><span class="hljs-attribute">emu0</span> at lamebus0<br><span class="hljs-attribute">ltrace0</span> at lamebus0<br><span class="hljs-attribute">ltimer0</span> at lamebus0<br><span class="hljs-attribute">beep0</span> at ltimer0<br><span class="hljs-attribute">rtclock0</span> at ltimer0<br><span class="hljs-attribute">lrandom0</span> at lamebus0<br><span class="hljs-attribute">random0</span> at lrandom0<br><span class="hljs-attribute">lhd0</span> at lamebus0<br><span class="hljs-attribute">lhd1</span> at lamebus0<br><span class="hljs-attribute">lser0</span> at lamebus0<br><span class="hljs-attribute">con0</span> at lser0<br><br><span class="hljs-attribute">cpu0</span>: MIPS/<span class="hljs-number">161</span> (System/<span class="hljs-number">161</span> <span class="hljs-number">2</span>.x) features <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">OS</span>/<span class="hljs-number">161</span> kernel<span class="hljs-meta"> [? for menu]: ?</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">OS/161 kernel menu</span><br><span class="hljs-meta">    [?o] Operations menu                [khgen] Next kernel heap generation</span><br><span class="hljs-meta">    [?t] Tests menu                     [khdump] Dump kernel heap</span><br><span class="hljs-meta">    [kh] Kernel heap stats              [q] Quit and shut down</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">Operation took 0.481954360 seconds</span><br></code></pre></td></tr></table></figure><ol start="2"><li>make sure that the git repository is working</li></ol><p>input:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">commit</span> b2e7d28ff0d4113ea3b9e53e7aca73069feeb5d2 (HEAD -&gt; master)<br><span class="hljs-attribute">Author</span>: root &lt;root@localhost&gt;<br><span class="hljs-attribute">Date</span>:   Fri Sep <span class="hljs-number">6</span> <span class="hljs-number">20</span>:<span class="hljs-number">24</span>:<span class="hljs-number">16</span> <span class="hljs-number">2024</span> +<span class="hljs-number">0000</span><br><br>    <span class="hljs-attribute">Updated</span> .gitignore<br><br><span class="hljs-attribute">commit</span> <span class="hljs-number">5</span>c4e39fa04a747a210a11fd9940768dda61981c0 (tag: asst1-start, origin/master, origin/HEAD)<br><span class="hljs-attribute">Author</span>: root &lt;root@localhost&gt;<br><span class="hljs-attribute">Date</span>:   Thu Sep <span class="hljs-number">5</span> <span class="hljs-number">22</span>:<span class="hljs-number">25</span>:<span class="hljs-number">13</span> <span class="hljs-number">2024</span> +<span class="hljs-number">0000</span><br><br>    <span class="hljs-attribute">Ignore</span> defs.mk file<br><br><span class="hljs-attribute">commit</span> <span class="hljs-number">341</span>e69822e0908f5c521e68e7c71f68e4c10119d<br><span class="hljs-attribute">Author</span>: Alex Sun &lt;oscar8@sjtu.edu.cn&gt;<br><span class="hljs-attribute">Date</span>:   Thu Sep <span class="hljs-number">5</span> <span class="hljs-number">15</span>:<span class="hljs-number">08</span>:<span class="hljs-number">36</span> <span class="hljs-number">2024</span> -<span class="hljs-number">0700</span><br><br>    <span class="hljs-attribute">Initial</span> commit<br></code></pre></td></tr></table></figure><p>input:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">asst1-<span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><h2 id="step-5-complete-the-code-reading-exercises"><a class="markdownIt-Anchor" href="#step-5-complete-the-code-reading-exercises"></a> Step 5. Complete the code reading exercises</h2><blockquote><p>Reference: <a href="https://people.ece.ubc.ca/~os161/os161-site/browse-code.html">Browse the source code</a></p></blockquote><blockquote><p><strong>Question 1:</strong> In the book chapters and in class you were introduced to the mechanisms used to transfer control between user processes and the operating system. Tell us where we can find the first line of OS/161 code that is executed when a trap occurs. Then tell us where control gets transferred to from that point. What about an interrupt? How does that differ?</p></blockquote><p>Look at the code in file <code>os161/src/kern/arch/mips/locore/exception-mips1.S</code></p><p>When a trap occurs,</p><p>If it is an UTLB exception, the first line of <code>mips_utlb_handler</code> would be the first line of OS/161 code that is executed when the trap occurs.</p><p>If it is a general exception, the first line of <code>mips_general_handler</code> would be the first line of OS/161 code that is executed when the trap occurs.</p><p>After the <code>trapframe</code> is set up, it transfers control to <code>mips_trap</code></p><p><code>mips_trap</code> determines whether it is a system call or an interrupt or something else.</p><p>If it is an interrupt, it then transfers control to interrupt handler.</p><blockquote><p><strong>Question 2:</strong> Making a system call, such as write, ultimately leads to a trap. Find the code in OS/161 that invokes system calls <strong>from user programs</strong> and causes traps. In which file and on which lines did you find this code?</p></blockquote><p>The <code>syscall</code> instruction on line 84 of <code>userland/lib/libc/arch/mips/syscalls-mips.S</code> is responsible for invoking the trap.</p><img src="../imgs/202410111833937.png" alt="" style="zoom: 67%;" /><blockquote><p><strong>Question 3:</strong> Why do you suppose there are <code>libc</code> functions in the &quot;common&quot; part of the source tree (<code>common/libc</code>) as well as in <code>userland/lib/libc</code>?</p></blockquote><p>The <code>common/libc</code> library provides implementations of C standard library functions to both the kernel and user programs, focusing mainly on core functionalities needed by the kernel, avoiding complexity of user-space features.</p><p>The <code>userland/lib/libc</code> library provides implementations of C standard library functions to the user space, dealing with more complex scenarios involving system calls…</p><blockquote><p>Below is a brief overview of the organization of the source tree, and a description of what goes where.</p></blockquote><blockquote><ul><li>configure -- top-level configuration script; configures the OS/161 distribution and build system. It does not configure the operating system kernel, which is a slightly different kind of configuration.</li></ul></blockquote><blockquote><p><strong>Question 4:</strong> Name two things that configure configures. What might invalidate that configuration and make you need/want to rerun it?</p></blockquote><ol><li><p>The configure file designates the target hardware platform and machine type.</p></li><li><p>The configure file designates the default location of the root of the installed system.</p></li></ol><p>If I move my source tree to a different computer that is running a different OS, the configuration will be invalid and I need to rerun the configure file.</p><blockquote><ul><li><code>Makefile</code> -- top-level <code>makefile</code>; builds the OS/161 distribution, including all the provided utilities, but does not build the operating system kernel.</li><li><code>common/</code> -- code used both by the kernel and user-level programs, mostly standard C library functions.</li><li><code>kern/</code> -- the kernel source code.</li><li><code>kern/Makefile</code> -- Once again, there is a <code>Makefile</code>. This <code>Makefile</code> installs header files but does not build anything.</li><li><code>kern/arch/</code> -- This is where architecture-specific code goes. By architecture-specific, we mean the code that differs depending on the hardware platform on which you're running. There are two directories here: mips which contains code specific to the MIPS processor and sys161 which contains code specific to the System/161 simulator.</li><li><code>kern/arch/mips/conf/conf.arch</code> -- This tells the kernel config script where to find the machine-specific, low-level functions it needs (throughout <code>kern/arch/mips/*</code>).</li><li><code>kern/arch/mips/include/</code> -- This folder and its subdirectories include files for the machine-specific constants and functions.</li></ul></blockquote><blockquote><p><strong>Question 5:</strong> What are some of the details which would make a function &quot;machine dependent&quot;? Why might it be important to maintain this separation, instead of just putting all of the code in one function?</p></blockquote><ul><li>Machine Dependent Details:</li></ul><ol><li><p>Functions that utilize specific processor instructions (assembly code) or rely on features unique to a particular CPU architecture</p></li><li><p>Functions accessing memory regions that are hard-wired to specific physical memory</p></li><li><p>Functions dealing with interrupts(traps) or low-level I/O operation</p></li></ol><ul><li>It is important to separate machine-dependent functions from machine-independent functions for the following reasons:</li></ul><ol><li>Machine-independent functions can be reused across different architecture. It would be easier to port the software to different hardware architectures.</li><li>Keep the codebase organized and easy to understand, as well as easy to maintain and modify, without affecting other functions.</li></ol><blockquote><ul><li>kern/arch/mips/* -- The other directories contain source files for the machine-dependent code that the kernel needs to run. A lot of this code is in assembler and will seem very low level, but understanding how it all fits together will help you immensely on Assignment 2.</li></ul></blockquote><blockquote><p><strong>Question 6:</strong> How large is a <code>trapframe</code>? Why?</p></blockquote><p>Look at the code in file <code>os161/src/kern/arch/mips/include/trapframe.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> &#123;</span><br><span class="hljs-type">uint32_t</span> tf_vaddr;<span class="hljs-comment">/* coprocessor 0 vaddr register */</span><br><span class="hljs-type">uint32_t</span> tf_status;<span class="hljs-comment">/* coprocessor 0 status register */</span><br><span class="hljs-type">uint32_t</span> tf_cause;<span class="hljs-comment">/* coprocessor 0 cause register */</span><br><span class="hljs-type">uint32_t</span> tf_lo;<br><span class="hljs-type">uint32_t</span> tf_hi;<br><span class="hljs-type">uint32_t</span> tf_ra;<span class="hljs-comment">/* Saved register 31 */</span><br><span class="hljs-type">uint32_t</span> tf_at;<span class="hljs-comment">/* Saved register 1 (AT) */</span><br><span class="hljs-type">uint32_t</span> tf_v0;<span class="hljs-comment">/* Saved register 2 (v0) */</span><br><span class="hljs-type">uint32_t</span> tf_v1;<span class="hljs-comment">/* etc. */</span><br><span class="hljs-type">uint32_t</span> tf_a0;<br><span class="hljs-type">uint32_t</span> tf_a1;<br><span class="hljs-type">uint32_t</span> tf_a2;<br><span class="hljs-type">uint32_t</span> tf_a3;<br><span class="hljs-type">uint32_t</span> tf_t0;<br><span class="hljs-type">uint32_t</span> tf_t1;<br><span class="hljs-type">uint32_t</span> tf_t2;<br><span class="hljs-type">uint32_t</span> tf_t3;<br><span class="hljs-type">uint32_t</span> tf_t4;<br><span class="hljs-type">uint32_t</span> tf_t5;<br><span class="hljs-type">uint32_t</span> tf_t6;<br><span class="hljs-type">uint32_t</span> tf_t7;<br><span class="hljs-type">uint32_t</span> tf_s0;<br><span class="hljs-type">uint32_t</span> tf_s1;<br><span class="hljs-type">uint32_t</span> tf_s2;<br><span class="hljs-type">uint32_t</span> tf_s3;<br><span class="hljs-type">uint32_t</span> tf_s4;<br><span class="hljs-type">uint32_t</span> tf_s5;<br><span class="hljs-type">uint32_t</span> tf_s6;<br><span class="hljs-type">uint32_t</span> tf_s7;<br><span class="hljs-type">uint32_t</span> tf_t8;<br><span class="hljs-type">uint32_t</span> tf_t9;<br><span class="hljs-type">uint32_t</span> tf_k0;<span class="hljs-comment">/* dummy (see exception-mips1.S comments) */</span><br><span class="hljs-type">uint32_t</span> tf_k1;<span class="hljs-comment">/* dummy */</span><br><span class="hljs-type">uint32_t</span> tf_gp;<br><span class="hljs-type">uint32_t</span> tf_sp;<br><span class="hljs-type">uint32_t</span> tf_s8;<br><span class="hljs-type">uint32_t</span> tf_epc;<span class="hljs-comment">/* coprocessor 0 epc register */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>A <code>trapframe</code> is 37 words large because the <code>trapframe</code> structure save 37 registers during entry to the exception handler and each register data is a word long.</p><blockquote><ul><li><code>kern/arch/sys161/conf/conf.arch</code> -- Similar to <code>mips/conf/conf.arch</code>.</li><li><code>kern/arch/sys161/include</code> -- These files are include files for the System161-specific hardware, constants, and functions. machine-specific constants and functions.</li><li>kern/compile -- This is where you build kernels. See below.</li></ul></blockquote><blockquote><p><strong>Question 7:</strong> Under what circumstances should you re-run the kern/conf/config script?</p></blockquote><p>I should rerun this step if I change the kernel config, add new source files to the build, add new build options or the hardware changes.</p><blockquote><p><strong>Question 8:</strong> Under what circumstances should you run <code>bmake depend</code> in kern/compile/DUMBVM?</p></blockquote><p>I should rerun <code>bmake depend</code> if I change header file inclusions, or after re-running <code>config</code>.</p><blockquote><p><strong>Question 9:</strong> Under what circumstances should you run <code>bmake</code> or <code>bmake install</code> in kern/compile/DUMBVM?</p></blockquote><p>I should run <code>bmake</code> if I want to recompile the kernel.</p><p>I should also run <code>bmake install</code> when I want to copy the newly compiled kernel to <code>~/os161/root</code> where I can boot it in System/161.</p><blockquote><ul><li>kern/dev -- This is where all the low level device management code is stored. Unless you are really interested, you can safely ignore most of this directory.</li><li>kern/fs -- This is where the actual file system implementations go. The subdirectory sfs contains a simple default file system. You will augment this file system as part of Assignment 4, so we'll ask you more questions about it then. The subdirectory semfs contains a special-purpose file system that provides semaphores to user-level programs. We may ask you more questions about this later on, after we discuss in class what semaphores are.</li><li>kern/include -- These are the include files that the kernel needs. The kern subdirectory contains include files that are visible not only to the operating system itself, but also to user-level programs. (Think about why it's named &quot;kern&quot; and where the files end up when installed.)</li><li>kern/lib -- These are library routines used throughout the kernel, e.g., arrays, kernel printf, etc. Note: You can use these data structures as you implement your assignments in CS161. We strongly encourage you to look around and see what we've provided for you.</li><li>kern/main -- This is where the kernel is initialized and where the kernel main function is implemented.</li></ul></blockquote><blockquote><p><strong>Question 10:</strong> When you booted your kernel, you found that there were several commands that you could issue to experiment with it. Explain exactly where and what you would have to do to add a command that printed out, &quot;Hello world!&quot;</p></blockquote><p>Add codes that print &quot;Hello world!&quot; in code base in <code>~/src/userland/testbin</code> and re-compile the kernel.</p><p>Then, run <code>sys161 kernel p testbin/(hello_world_program)</code> to run the code.</p><blockquote><ul><li>kern/proc -- This is where process support lives. You will write most of the code that goes here during Assignments 4 and 5.</li><li>kern/synchprobs -- This is the directory that contains/will contain the framework code that you will need to complete assignment 1. You can safely ignore it for now.</li><li>kern/syscall -- This is where you will add code to create and manage user level processes. As it stands now, OS/161 runs only kernel threads; there is no support for user level code. In Assignments 4 and 5, you'll implement this support.</li><li>kern/thread -- Threads are the fundamental abstraction on which the kernel is built (do not forget to look back at header files!)</li><li>kern/vfs -- The vfs is the &quot;virtual file system.&quot; It is an abstraction for a file system and its existence in the kernel allows you to implement multiple file systems, while sharing as much code as possible. The VFS layer is the file-system independent layer. You will want to go look atvfs.h and vnode.h before looking at this directory.</li><li>kern/vm -- This directory is fairly vacant. In Assignments 6 and 7, you'll implement virtual memory and most of your code will go in here.</li><li>man/ -- the OS/161 manual (&quot;man pages&quot;) appear here. The man pages document (or specify) every program, every function in the C library, and every system call. You will use the system call man pages for reference in the course of assignment 2. The man pages are HTML and can be read with any browser.</li><li>mk/ -- fragments of makefiles used to build the system.</li><li>userland/ -- user-level libraries and program code</li><li>userland/bin/ -- all the utilities that are typically found in /bin, e.g., cat, cp, ls, etc. The things in bin are considered &quot;fundamental&quot; utilities that the system needs to run.</li></ul></blockquote><blockquote><p><strong>Question 11:</strong> Why do we need to include these in your OS/161 distribution? Why can't you just use the standard utilities that are present on the machine on which you're working?</p></blockquote><p>os161 runs in its own virtualized environment (runs on hardware simulator) with a different kernel and system call interface compared to the host machine. Standard utilities from the host operating system rely on system calls and kernel features that are not implemented in OS/161. The userland utilities in OS/161 are specifically built to interact with the OS/161 kernel and its system calls.</p><p>Also, OS/161 programs are compiled for the MIPS architecture, which may be different from the architecture of the host machine(x86/ARM). In that case, the standard utilities on the host machine cannot run in the OS/161 environment. OS/161 needs a set of utilities that are compiled to run specifically within the MIPS architecture.</p><blockquote><ul><li>userland/include/ -- these are the include files that you would typically find in <code>/usr/include</code> (in our case, a subset of them). These are user level include files; not kernel include files.</li><li>userland/lib/ -- library code lives here. We have only two libraries: <code>libc</code>, the C standard library, and <code>hostcompat</code>, which is for recompiling OS/161 programs for the host UNIX system. There is also a crt0 directory, which contains the startup code for user programs.</li></ul></blockquote><blockquote><p><strong>Question 12:</strong> When a user program exits, what is done with the program's return value?</p></blockquote><p>When a user program exits, it invokes the <code>_exit</code> system call. The kernel captures the return value and stores it in a data structure <code>struct proc</code> which contains information about the process. Later, the return value can be retrieved by the parent process using a system call (e.g. <code>waitpid()</code>). After the value is collected, the process is fully cleaned up.</p><blockquote><ul><li><code>userland/sbin/</code> -- this is the source code for the utilities typically found in <code>/sbin</code> on a typical UNIX installation. In our case, there are some utilities that let you halt the machine, power it off and reboot it, among other things.</li><li><code>userland/testbin/</code> -- this is the source code for the test programs found in <code>/testbin</code> in the installed OS/161 tree. You will want to examine this directory closely and be aware of what's available here, as many of these test programs will be useful during the course of the semester.</li></ul></blockquote><blockquote><p><strong>Question 13:</strong> Imagine that you wanted to add a new system call. List all the places that you would need to modify/add code. Then review your answers to questions 7-9 and note which of those actions you need to take in order to test the new system call.</p></blockquote><ul><li>Add code</li></ul><ol><li>Define the system call number</li></ol><p>In file<code>~/os161/src/kern/include/kern/syscall.h</code>, define the number of the newly-defined system call.</p><ol start="2"><li>Declare the system call</li></ol><p>In file <code>~/os161/src/kern/include/syscall.h</code>, declare the new system call.</p><ol start="3"><li>implement the system call</li></ol><p>In the path <code>~/os161/src/kern/syscall/</code>, create a source file and implement the system call.</p><ol start="4"><li>Update the system call dispatcher</li></ol><p>In file <code>~/os161/src/kern/arch/mips/syscall/syscall.c</code>, add the new system call to the <code>switch</code> statement that dispatches the appropriate system call based on its number.</p><ol start="5"><li>Add a prototype in the userland includes</li></ol><ul><li>Actions to take</li></ul><p>In order to test the new system call, I need to run:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/os161/src/kern/compile/DUMBVM<br>bmake depend<br>bmake<br>bmake install<br></code></pre></td></tr></table></figure><h2 id="step-6-learn-how-to-use-the-debugger"><a class="markdownIt-Anchor" href="#step-6-learn-how-to-use-the-debugger"></a> Step 6. Learn how to use the debugger</h2><blockquote><p>Reference:</p><p><a href="https://people.ece.ubc.ca/~os161/os161-site/gdb-attach.html">attaching to OS161 with GDB</a></p><p><a href="https://people.ece.ubc.ca/~os161/os161-site/debug-os161.html">GDB tutorial</a></p></blockquote><h2 id="step-7-trace-the-execution-from-start-to-menu"><a class="markdownIt-Anchor" href="#step-7-trace-the-execution-from-start-to-menu"></a> Step 7. Trace the execution from start to menu()</h2><blockquote><p><strong>Question 14:</strong> What is the name of the very first function that executes when OS161 starts up?</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(gdb) <span class="hljs-built_in">db</span><br>__start () <span class="hljs-meta">at</span> ../../arch/sys161/main/start<span class="hljs-number">.</span>S:<span class="hljs-number">54</span><br><span class="hljs-number">54</span>         addiu <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">sp</span>, -<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p><code>–start()</code> is the very first function that executes when OS161 starts.</p><blockquote><p><strong>Question 15:</strong> What is the very first assembly instruction that executes?</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(gdb) <span class="hljs-built_in">db</span><br>__start () <span class="hljs-meta">at</span> ../../arch/sys161/main/start<span class="hljs-number">.</span>S:<span class="hljs-number">54</span><br><span class="hljs-number">54</span>         addiu <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">sp</span>, -<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p><code>addiu sp, sp, -24</code> is the very first assembly instruction that executes.</p><blockquote><p><strong>Question 16:</strong> Set the breakpoints in the kernel function that shows the menu and in the kernel main function. Now tell GDB to display all the breakpoints that were set and copy the output to your submit file.</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">(gdb) info <span class="hljs-selector-tag">b</span><br>Num     Type           Disp Enb Address    What<br><span class="hljs-number">1</span>       breakpoint     keep y   <span class="hljs-number">0</span>x800139e4 <span class="hljs-keyword">in</span> kmain at ../../main/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>:<span class="hljs-number">211</span><br><span class="hljs-number">2</span>       breakpoint     keep y   <span class="hljs-number">0</span>x80014a0c <span class="hljs-keyword">in</span> <span class="hljs-selector-tag">menu</span> at ../../main/<span class="hljs-selector-tag">menu</span><span class="hljs-selector-class">.c</span>:<span class="hljs-number">697</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>Question 17:</strong> Briefly describe what happens between the beginning of the execution and the invocation of the kernel main function.</p></blockquote><p>First, set up the stack frame for debugging purposes, saving the return address register (<code>ra</code>) to help GDB with disassembly.</p><p>Then, copy the boot argument string from the stack (in register <code>a0</code>) to the kernel's <code>_end</code> address.</p><p>Then, determine the memory layout and initialize the kernel stack.</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata">We <span class="hljs-keyword">set</span> up the <span class="hljs-keyword">memory</span> map like this:<br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *         top of memory</span><br><span class="hljs-comment">    *                         free memory</span><br><span class="hljs-comment">    *         P + 0x1000</span><br><span class="hljs-comment">    *                         first thread&#x27;s stack (1 page)</span><br><span class="hljs-comment">    *         P</span><br><span class="hljs-comment">    *                         wasted space (&lt; 1 page)</span><br><span class="hljs-comment">    *                         copy of the boot string</span><br><span class="hljs-comment">    *         _end</span><br><span class="hljs-comment">    *                         kernel</span><br><span class="hljs-comment">    *         0x80000200</span><br><span class="hljs-comment">    *                         exception handlers</span><br><span class="hljs-comment">    *         0x80000000</span><br></code></pre></td></tr></table></figure><p>Then, copy the exception handler code onto the first page of memory.</p><p>Then, flush the instruction cache to ensure recent changes (such as exception handler code) are correctly read by the instruction cache.</p><p>Then, initilize the TLB, set up the status register and the context register, and load the GP register.</p><p>Finally, call the kernel main function.</p><blockquote><p><strong>Question 18:</strong> What is the assembly language instruction that calls the kernel main function?</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jal kmain<br></code></pre></td></tr></table></figure><blockquote><p><strong>Question 19:</strong> Step through the <code>boot()</code> code to find out what functions are called during early initialization. Paste the gdb output that shows you what these functions are.</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">(gdb) n<br><span class="hljs-number">109</span>             <span class="hljs-built_in">ram_bootstrap</span>();<br>(gdb) n<br><span class="hljs-number">110</span>             <span class="hljs-built_in">proc_bootstrap</span>();<br>(gdb) n<br><span class="hljs-number">111</span>             <span class="hljs-built_in">thread_bootstrap</span>();<br>(gdb) n<br><span class="hljs-number">112</span>             <span class="hljs-built_in">hardclock_bootstrap</span>();<br>(gdb) n<br><span class="hljs-number">113</span>             <span class="hljs-built_in">vfs_bootstrap</span>();<br>(gdb) n<br><span class="hljs-number">114</span>             <span class="hljs-built_in">kheap_nextgeneration</span>();<br></code></pre></td></tr></table></figure><blockquote><p><strong>Question 20:</strong> Set a breakpoint in thread_bootstrap(). Once you hit that breakpoint, at the very first line of that function, attempt to print the contents of the *bootcpu variable. Copy the output into the submit file.</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(gdb) p *<span class="hljs-keyword">bootcpu</span><br><span class="hljs-keyword"></span>Cannot access memory <span class="hljs-built_in">at</span> <span class="hljs-keyword">address </span><span class="hljs-number">0x80000</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>Question 21:</strong> Now, step through that function until after the line that says 'bootcpu = cpu_create(0)'. Now print the content of *bootcpu and paste the output.</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">(gdb) p *bootcpu</span><br><span class="language-xml">$2 = &#123;c_self = 0x8003af00, c_number = 0, c_hardware_number = 0, c_curthread = 0x8003bf80, c_zombies = &#123;tl_head = &#123;</span><br><span class="language-xml">      tln_prev = 0x0, tln_next = 0x8003af1c, tln_self = 0x0&#125;, tl_tail = &#123;tln_prev = 0x8003af10, tln_next = 0x0, </span><br><span class="language-xml">      tln_self = 0x0&#125;, tl_count = 0&#125;, c_hardclocks = 0, c_spinlocks = 0, c_isidle = false, c_runqueue = &#123;tl_head = &#123;</span><br><span class="language-xml">      tln_prev = 0x0, tln_next = 0x8003af44, tln_self = 0x0&#125;, tl_tail = &#123;tln_prev = 0x8003af38, tln_next = 0x0, </span><br><span class="language-xml">      tln_self = 0x0&#125;, tl_count = 0&#125;, c_runqueue_lock = &#123;splk_lock = 0, splk_holder = 0x0&#125;, c_ipi_pending = 0, </span><br><span class="language-xml">  c_shootdown = </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">ts_placeholder</span> = <span class="hljs-number">0</span>&#125; &lt;repeats <span class="hljs-number">16</span> times&gt;&#125;, c_numshootdown = <span class="hljs-number">0</span>, c_ipi_lock = &#123;splk_lock = <span class="hljs-number">0</span>, </span><br><span class="hljs-template-variable">    splk_holder = <span class="hljs-number">0</span>x0&#125;&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>Copy the contents of <code>kern/gdbscripts/array</code> into your .gdbinit file.</p></blockquote><blockquote><p><strong>Question 22:</strong> Print the <code>allcpus</code> array before the boot() function is executed. Paste the output.</p></blockquote><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">(gdb)<span class="hljs-built_in"> array </span>allcpus<br>0 items<br></code></pre></td></tr></table></figure><blockquote><p><strong>Question 23:</strong> Print again the same array after the boot() function is executed. Paste the output.</p></blockquote><p>After the <code>boot</code> function is executed:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">(gdb)<span class="hljs-built_in"> array </span>allcpus<br>4 items<br>$1 = (void *) 0x8003bf00<br>$2 = (void *) 0x8003be00<br>$3 = (void *) 0x8003bd00<br>$4 = (void *) 0x8003bc00<br></code></pre></td></tr></table></figure><h2 id="submission"><a class="markdownIt-Anchor" href="#submission"></a> Submission</h2><p>If I put the tag on the wrong commit:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -d asst1-submit     # Deletes the previous tag<br>git tag asst1-submit     # Tag your latest commit<br>git push origin :refs/tags/asst1-submit     # Delete the tag in your remote<br>git push --tags     # Push the tags<br></code></pre></td></tr></table></figure><p>We have finished Assignment1!😊</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>OS161</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>OS161</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Operating Systems</title>
    <link href="/2024/09/12/Intro/"/>
    <url>/2024/09/12/Intro/</url>
    
    <content type="html"><![CDATA[<p>In this part, we will introduce you to the world of Operating Systems! We will first introduce the 3 major parts of Operating Systems: Virtualization, Concurrency and Persistence, which we will go into the details in later days. Then, we will introduce some basic Operating System interfaces and concepts. At last, we will talk about the OS boot sequence, especially how the OS boot in OS/161.</p><h1 id="introduction-to-operating-systems"><a class="markdownIt-Anchor" href="#introduction-to-operating-systems"></a> Introduction to Operating Systems</h1><blockquote><p><strong>Learning Materials</strong></p><p>Readings:</p><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf">OSTEP book Chapter 2</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/book-rev8.pdf">xv6 book Chapter 0</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/book-rev8.pdf">xv6 book Chapter 3</a></p><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.p">Address Spaces</a></p><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/vm-mechanism.pdf">Address Translation</a></p><p><a href="https://docs.google.com/document/d/1HLHXxTnW6Cb96wZVViH-7gIoF57AdBBMvVmgUxdA1KM">How does an OS boot?</a></p><p><a href="http://os161.eecs.harvard.edu/documentation/sys161-2.0.2/lamebus.html"><code>LAMEbus</code> documentation</a></p><p><a href="https://people.ece.ubc.ca/~os161/download/book-rev8.pdf">xv6 book Chapter 1</a></p><p><a href="http://littleosbook.github.io/#booting">Short section on booting in The Little Book About OS Development</a></p><p>Lecture Slides:</p><p><a href="https://people.ece.ubc.ca/os161/LECTURE-SLIDES/Introduction.pptx">Introduction</a></p><p><a href="https://people.ece.ubc.ca/os161/LECTURE-SLIDES/bootstrap-kernel-mode.pptx">Bootstrapping. What does it mean to be the <em>kernel</em>?</a></p></blockquote><h2 id="3-major-parts-of-operating-systems"><a class="markdownIt-Anchor" href="#3-major-parts-of-operating-systems"></a> 3 Major Parts of Operating Systems</h2><p>In this part, we will briefly introduce the 3 major parts of Operating Systems: Virtualization, Concurrency and Persistence.</p><h3 id="virtualization"><a class="markdownIt-Anchor" href="#virtualization"></a> Virtualization</h3><p>The crux of the problem:</p><blockquote><p>How does OS virtualize resources?</p></blockquote><ul><li>Virtualizing the CPU</li></ul><p>OS creates an illusion that the system has a very large number of virtual CPUs.</p><p>Each running program is represented in the kernel as a process.</p><p>Each process has its own state: Program counter, registers, memory, open files, …</p><p>A process runs for a while…Then the system is interrupted by a <strong>timer interrupt</strong>.</p><p>The kernel performs a <strong>context switch</strong>:</p><blockquote><p>Saves the state of the old process to memory</p><p>Loads the state of the new process onto the CPU</p><p>Let the new process run</p></blockquote><p>After a while, there is another interrupt, and the kernel switches back to the old process.</p><ul><li>Virtualizing Memory</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-number">2</span>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">3</span>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-number">4</span>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span>  <span class="hljs-type">int</span><br><span class="hljs-number">7</span>  main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])<br><span class="hljs-number">8</span>  &#123;<br><span class="hljs-number">9</span>  <span class="hljs-type">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// a1</span><br><span class="hljs-number">10</span> assert(p != <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">11</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d) address pointed to by p: %p\n&quot;</span>,<br><span class="hljs-number">12</span> getpid(), p); <span class="hljs-comment">// a2</span><br><span class="hljs-number">13</span> *p = <span class="hljs-number">0</span>; <span class="hljs-comment">// a3</span><br><span class="hljs-number">14</span> <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-number">15</span> Spin(<span class="hljs-number">1</span>);<br><span class="hljs-number">16</span> *p = *p + <span class="hljs-number">1</span>;<br><span class="hljs-number">17</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d) p: %d\n&quot;</span>, getpid(), *p); <span class="hljs-comment">// a4</span><br><span class="hljs-number">18</span> &#125;<br><span class="hljs-number">19</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">20</span> &#125;<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">prompt</span>&gt; ./<span class="hljs-selector-tag">mem</span> <span class="hljs-selector-tag">&amp;</span> ./<span class="hljs-selector-tag">mem</span> <span class="hljs-selector-tag">&amp;</span><br><span class="hljs-selector-attr">[1]</span> <span class="hljs-number">24113</span><br><span class="hljs-selector-attr">[2]</span> <span class="hljs-number">24114</span><br>(<span class="hljs-number">24113</span>) <span class="hljs-selector-tag">address</span> <span class="hljs-selector-tag">pointed</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">by</span> <span class="hljs-selector-tag">p</span>: <span class="hljs-number">0</span><span class="hljs-selector-tag">x200000</span><br>(<span class="hljs-number">24114</span>) <span class="hljs-selector-tag">address</span> <span class="hljs-selector-tag">pointed</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">by</span> <span class="hljs-selector-tag">p</span>: <span class="hljs-number">0</span><span class="hljs-selector-tag">x200000</span><br>(<span class="hljs-number">24113</span>) <span class="hljs-selector-tag">p</span>: <span class="hljs-number">1</span><br>(<span class="hljs-number">24114</span>) <span class="hljs-selector-tag">p</span>: <span class="hljs-number">1</span><br>(<span class="hljs-number">24114</span>) <span class="hljs-selector-tag">p</span>: <span class="hljs-number">2</span><br>(<span class="hljs-number">24113</span>) <span class="hljs-selector-tag">p</span>: <span class="hljs-number">2</span><br>(<span class="hljs-number">24113</span>) <span class="hljs-selector-tag">p</span>: <span class="hljs-number">3</span><br>(<span class="hljs-number">24114</span>) <span class="hljs-selector-tag">p</span>: <span class="hljs-number">3</span><br>(<span class="hljs-number">24113</span>) <span class="hljs-selector-tag">p</span>: <span class="hljs-number">4</span><br>(<span class="hljs-number">24114</span>) <span class="hljs-selector-tag">p</span>: <span class="hljs-number">4</span><br>...<br></code></pre></td></tr></table></figure><p>Each process accesses its own <strong>address space</strong>, which the OS maps onto the physical memory of the machine. We will talk more about address spaces and how virtual memory is translated into physical memory later.</p><p>Virtual memory may be much larger than physical memory.</p><img src="../imgs/202409101132215.png" alt="" style="zoom: 67%;" /><hr /><h3 id="concurrency"><a class="markdownIt-Anchor" href="#concurrency"></a> Concurrency</h3><p>A Multi-threaded Program:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">2</span>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-number">3</span>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><span class="hljs-number">4</span>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common_threads.h&quot;</span></span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-number">7</span>  <span class="hljs-type">int</span> loops;<br><span class="hljs-number">8</span><br><span class="hljs-number">9</span>  <span class="hljs-type">void</span> *<span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><span class="hljs-number">10</span> <span class="hljs-type">int</span> i;<br><span class="hljs-number">11</span> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loops; i++) &#123;<br><span class="hljs-number">12</span> counter++;<br><span class="hljs-number">13</span> &#125;<br><span class="hljs-number">14</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">15</span> &#125;<br><span class="hljs-number">16</span><br><span class="hljs-number">17</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><span class="hljs-number">18</span> <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-number">19</span> <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: threads &lt;value&gt;\n&quot;</span>);<br><span class="hljs-number">20</span> <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><span class="hljs-number">21</span> &#125;<br><span class="hljs-number">22</span> loops = atoi(argv[<span class="hljs-number">1</span>]);<br><span class="hljs-number">23</span> <span class="hljs-type">pthread_t</span> p1, p2;<br><span class="hljs-number">24</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Initial value : %d\n&quot;</span>, counter);<br><span class="hljs-number">25</span><br><span class="hljs-number">26</span> Pthread_create(&amp;p1, <span class="hljs-literal">NULL</span>, worker, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">27</span> Pthread_create(&amp;p2, <span class="hljs-literal">NULL</span>, worker, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">28</span> Pthread_join(p1, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">29</span> Pthread_join(p2, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">30</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Final value : %d\n&quot;</span>, counter);<br><span class="hljs-number">31</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">32</span> &#125;<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">prompt&gt;</span> <span class="hljs-string">gcc</span> <span class="hljs-string">-o</span> <span class="hljs-string">threads</span> <span class="hljs-string">threads.c</span> <span class="hljs-string">-Wall</span> <span class="hljs-string">-pthread</span><br><span class="hljs-string">prompt&gt;</span> <span class="hljs-string">./threads</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">Initial value :</span> <span class="hljs-number">0</span><br><span class="hljs-attr">Final value :</span> <span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure><p>Each thread increments <code>counter</code> 1000 times</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">prompt</span>&gt; ./threads <span class="hljs-number">100000</span><br><span class="hljs-attribute">Initial</span> value : <span class="hljs-number">0</span><br><span class="hljs-attribute">Final</span> value : <span class="hljs-number">143012</span> // huh??<br><span class="hljs-attribute">prompt</span>&gt; ./threads <span class="hljs-number">100000</span><br><span class="hljs-attribute">Initial</span> value : <span class="hljs-number">0</span><br><span class="hljs-attribute">Final</span> value : <span class="hljs-number">137298</span> // what the??<br></code></pre></td></tr></table></figure><p>What?</p><blockquote><p>Incrementing <code>counter</code> takes 3 instructions:</p></blockquote><blockquote><p>One to load the value of the counter from memory into a register, one to increment it, and one to store it back into memory.</p></blockquote><blockquote><p>These three instructions do not execute atomically.</p></blockquote><p>So it leads to the crux of the problem:</p><blockquote><p>How to build correct concurrent problems?</p></blockquote><hr /><h3 id="persistence"><a class="markdownIt-Anchor" href="#persistence"></a> Persistence</h3><p>The crux of the problem:</p><blockquote><p>How to store data persistently</p></blockquote><p>The <strong>file system</strong> is the part of the OS in charge of managing persistent data</p><hr /><h3 id="design-goals"><a class="markdownIt-Anchor" href="#design-goals"></a> Design Goals</h3><p>Finding the right set of trade-offs is a key to building systems.</p><p>Our goals:</p><ul><li><p>build up some <strong>abstractions</strong></p></li><li><p>provide <strong>high performance</strong></p></li></ul><p>provide virtualization and other OS features without excessive overheads (extra time, extra space).</p><ul><li>provide <strong>protection</strong> between applications</li></ul><p>main principles of OS: <strong>isolation</strong></p><ul><li><p><strong>reliability</strong></p></li><li><p>other: energy-efficiency, security, mobility</p></li></ul><h2 id="operating-system-interfaces"><a class="markdownIt-Anchor" href="#operating-system-interfaces"></a> Operating System Interfaces</h2><h3 id="user-space-and-kernel-space"><a class="markdownIt-Anchor" href="#user-space-and-kernel-space"></a> user space and kernel space</h3><p>A process alternates between executing in user space and kernel space.</p><img src="../imgs/202409071727314.png" alt="" style="zoom:50%;" /><hr /><h3 id="shell"><a class="markdownIt-Anchor" href="#shell"></a> shell</h3><p>An ordinary user program that reads commands from the user and executes them</p><p>The primary user interface to traditional Unix-like systems</p><hr /><h3 id="processes-and-memory"><a class="markdownIt-Anchor" href="#processes-and-memory"></a> Processes and memory</h3><p><code>fork()</code></p><p><code>wait()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();<br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>pid = wait();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br><span class="hljs-built_in">exit</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>exec(filename, *argv)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *argv[<span class="hljs-number">3</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;echo&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>argv[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>exec(<span class="hljs-string">&quot;/bin/echo&quot;</span>, argv);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exec error\n&quot;</span>);<br></code></pre></td></tr></table></figure><hr /><h3 id="io-and-file-descriptors"><a class="markdownIt-Anchor" href="#io-and-file-descriptors"></a> I/O and File descriptors</h3><p>The file descriptor interface <strong>abstracts</strong> away the differences between files, pipes, and devices, making them all look like streams of bytes</p><ul><li>I/O redirection</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cat&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>close(<span class="hljs-number">0</span>);<br>open(<span class="hljs-string">&quot;input.txt&quot;</span>, O_RDONLY);<br>exec(<span class="hljs-string">&quot;cat&quot;</span>, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>Now it is clear why it is a good idea that <code>fork</code> and <code>exec</code> are separate calls. This separation allows the shell to fix up (e.g. I/O redirection) the child process before the child runs the intended program (<code>exec</code>).</p><ul><li><code>fork</code> system call</li></ul><p>Although fork copies the file descriptor table, each underlying file offset is shared between parent and child.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">exit</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>wait();<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;world\n&quot;</span>, <span class="hljs-number">6</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>output: &quot;hello world&quot;</p><ul><li><code>dup</code> system call</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = dup(<span class="hljs-number">1</span>);<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-number">6</span>);<br>write(fd, <span class="hljs-string">&quot;world\n&quot;</span>, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>output: &quot;hello world&quot;</p><hr /><h3 id="pipes"><a class="markdownIt-Anchor" href="#pipes"></a> Pipes</h3><p>A small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing</p><img src="../imgs/202409162140360-1740411340153-24.png" alt="" style="zoom:33%;" /><p>The pipe file is just a <strong>memory buffer</strong>.</p><p>The mechanics of pipe is that it creates a special &quot;pipe&quot; file in memory. Parent process's two file descriptors refer to its <code>vnode</code>: one for reading (<code>pfd[0]</code>), one for writing (<code>pfd[1]</code>). Then the parent process forks a child process, which shares file handles with the parent and can read/write the same pipe. The parent and the child each close one side of the pipe(read/write) and can communicate with each other.</p><p><img src="../imgs/202410262356423-1740411340153-25.png" alt="" /></p><ul><li><strong>Redirecting Pipe I/O</strong>:</li></ul><p>As shown below, parent redirects output end of the pipe (<code>pfd[1]</code>) to STDOUT via the <code>dup2</code> system  call. In this way, whatever the parent is writing to STDOUT can be read by the child from the input end of the pipe (<code>pfd[0]</code>).</p><p><img src="../imgs/202410241132668.png" alt="" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pipe(p);<br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>    close(<span class="hljs-number">0</span>);<br>    dup(p[<span class="hljs-number">0</span>]);    <span class="hljs-comment">//duplicate p[0] to 0</span><br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>    exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>);<br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>The program redirect child process's stdin to the read end of the pipe</p><p>p[0] is the read end of the pipe</p><p>p[1] is the write end of the pipe</p><hr /><h3 id="file-system"><a class="markdownIt-Anchor" href="#file-system"></a> File System</h3><ul><li><code>chdir</code> system call</li></ul><p>They open the same file:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">chdir(<span class="hljs-string">&quot;/a&quot;</span>);<br>chdir(<span class="hljs-string">&quot;b&quot;</span>);<br>open(<span class="hljs-string">&quot;c&quot;</span>, O_RDONLY);<br><br>open(<span class="hljs-string">&quot;/a/b/c&quot;</span>, O_RDONLY);<br></code></pre></td></tr></table></figure><ul><li><code>O_CREATE</code> flag and <code>mknod</code> system call</li></ul><p><code>open</code> with the <code>O_CREATE</code> flag creates a new data file</p><p><code>mknod</code> creates a new device file</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mkdir(<span class="hljs-string">&quot;/dir&quot;</span>);<br>fd = open(<span class="hljs-string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY);<br>close(fd);<br>mknod(<span class="hljs-string">&quot;/console&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ul><li><code>fstat</code></li></ul><p><code>fstat</code> retrieves information about the object a file descriptor refers to.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DIR 1 <span class="hljs-comment">// Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE 2 <span class="hljs-comment">// File</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEV 3 <span class="hljs-comment">// Device</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br><span class="hljs-type">short</span> type; <span class="hljs-comment">// Type of file</span><br><span class="hljs-type">int</span> dev; <span class="hljs-comment">// File system’s disk device</span><br>uint ino; <span class="hljs-comment">// Inode number</span><br><span class="hljs-type">short</span> nlink; <span class="hljs-comment">// Number of links to file</span><br>uint size; <span class="hljs-comment">// Size of file in bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>link</code> system call</li></ul><p>The same underlying file, called an <strong><code>inode</code></strong>, can have multiple names, called <strong>links</strong>,</p><p>Create a new file named both a and b:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">open(<span class="hljs-string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);<br>link(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br></code></pre></td></tr></table></figure><p>Each <code>inode</code> is identified by a unique <strong><code>inode number</code></strong></p><ul><li><code>unlink</code> system call</li></ul><p>Removes a name from the file system</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">unlink(<span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = open(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>, O_CREATE|O_RDWR);<br>unlink(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="traps-interrupts-and-drivers-in-x86"><a class="markdownIt-Anchor" href="#traps-interrupts-and-drivers-in-x86"></a> Traps, Interrupts, and Drivers (in x86)</h2><h3 id="systems-calls-exceptions-and-interrupts"><a class="markdownIt-Anchor" href="#systems-calls-exceptions-and-interrupts"></a> Systems Calls, Exceptions, and Interrupts</h3><ul><li>interrupt</li></ul><p>An interrupts stops the normal processor loop and starts executing a new sequence called an <strong>interrupt handler</strong></p><p>Processor should switch from <strong>user mode</strong> to <strong>kernel mode</strong>, and back</p><ul><li>Difference between traps and interrupts</li></ul><p><strong>traps</strong> are caused by the current process running on a processor (e.g. system call)</p><p><strong>interrupts</strong> are caused by devices and may not be related to the currently running process</p><hr /><h3 id="x86-protection"><a class="markdownIt-Anchor" href="#x86-protection"></a> x86 protection</h3><p>To make a system call on the x86, a program invokes the int n instruction</p><p>n specifies the index into the IDT (interrupt descriptor table), representing different types of interrupt</p><img src="../imgs/202409082242329.png" alt="" style="zoom: 50%;" /><hr /><h3 id="code-assembly-trap-handlers"><a class="markdownIt-Anchor" href="#code-assembly-trap-handlers"></a> Code: Assembly trap handlers</h3><p>The user mode processor registers are saved in the <code>trapframe</code> on the kernel stack</p><img src="../imgs/202409082254703.png" alt="" style="zoom: 67%;" /><hr /><h3 id="code-c-trap-handler"><a class="markdownIt-Anchor" href="#code-c-trap-handler"></a> Code: C trap handler</h3><p>Each handler sets up a <strong>trap frame</strong> and then calls the C function <code>trap</code></p><p>If the trap is <code>T_SYSCALL</code>, trap calls the <strong>system call handler</strong> <code>syscall</code></p><p>After checking for a system call, trap looks for <strong>hardware interrupts</strong></p><p>If the trap is not a system call and not a hardware device looking for attention, trap assumes it was caused by <strong>incorrect behavior</strong> as part of the code that was executing before the trap</p><p>If the code was a <strong>user program</strong>, clean it up</p><p>If it was <strong>kernel</strong> running, there must be a kernel bug: trap prints details about the surprise and then calls <code>panic</code>.</p><hr /><h3 id="code-system-calls"><a class="markdownIt-Anchor" href="#code-system-calls"></a> Code: System Calls</h3><p><code>trap</code> invoke <code>syscall</code></p><p><code>syscall</code> loads the system call number from the trap frame and indexes into the system call table</p><hr /><h3 id="code-interrupts"><a class="markdownIt-Anchor" href="#code-interrupts"></a> Code: Interrupts</h3><p>Can occur at any time</p><p>Signal the CPU when a device needs attention</p><hr /><h3 id="drivers"><a class="markdownIt-Anchor" href="#drivers"></a> Drivers</h3><p>A driver manage a particular device: it provides interrupt handlers for a device, causes a device to perform operations, causes a device to generate interrupts, …</p><hr /><h3 id="code-disk-driver"><a class="markdownIt-Anchor" href="#code-disk-driver"></a> Code: Disk driver</h3><ul><li>Disk sectors</li></ul><p>A numbered sequence of 512-byte blocks</p><p>The disk driver <strong>represent disk sectors</strong> with a data structure called a <strong>buffer</strong></p><p>Each buffer represents the contents of one sector on a particular disk device</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">3500</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> &#123;</span><br><span class="hljs-number">3501</span> <span class="hljs-type">int</span> flags;    <span class="hljs-comment">//track the relationship between memory and disk</span><br><span class="hljs-number">3502</span> uint dev;<br><span class="hljs-number">3503</span> uint sector;<br><span class="hljs-number">3504</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">// LRU cache list</span><br><span class="hljs-number">3505</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-number">3506</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">qnext</span>;</span> <span class="hljs-comment">// disk queue</span><br><span class="hljs-number">3507</span> uchar data[<span class="hljs-number">512</span>];<br><span class="hljs-number">3508</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="address-space-and-address-translation"><a class="markdownIt-Anchor" href="#address-space-and-address-translation"></a> Address Space and Address Translation</h2><h3 id="address-spaces"><a class="markdownIt-Anchor" href="#address-spaces"></a> Address Spaces</h3><ul><li>Time sharing</li></ul><p>Where the programs actually lives:</p><img src="../imgs/202409092154279.png" alt="" style="zoom: 67%;" /><ul><li>Address Space</li></ul><p>Layout of an user address space:</p><img src="../imgs/202409092207753.png" alt="" style="zoom: 33%;" /><p>Layout of a virtual address space:</p><img src="../imgs/202409121951307.png" alt="" style="zoom:50%;" /><hr /><h3 id="address-translation"><a class="markdownIt-Anchor" href="#address-translation"></a> Address Translation</h3><ul><li>Dynamic (Hardware-based) Relocation</li></ul><p>When a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value.</p><p>physical address = virtual address + base</p><p><code>base</code> is the process's <strong>physical starting address</strong> (first instruction)</p><p><code>bounds</code> holds the <strong>size</strong> of the process's <strong>address space</strong> to help with protection</p><ul><li>OS Issues</li></ul><p>what OS does at boot time (After the kernel is loaded into memory by bootloader):</p><img src="../imgs/202409112244003.png" alt="" style="zoom:50%;" /><p>what happens when a process (Process A) starts running:</p><p>Address Translation is done by hardware only, except for exception</p><p>when starting a new process A,</p><blockquote><p>allocate entry in process table</p><p>allocate memory for process (looking for free memory via <code>free list</code>)</p><p>set base/bound registers</p><p>return from trap into A</p></blockquote><p>when a context switch occurs,</p><blockquote><p>save regs(A) to proc-struct(A) (including base/bounds, PC…);</p><p>restore regs(B) from proc-struct(B) (including base/bounds, PC…)</p><p>return from trap into B</p></blockquote><img src="../imgs/202409112257475.png" alt="" style="zoom: 67%;" /><h2 id="os-booting"><a class="markdownIt-Anchor" href="#os-booting"></a> OS Booting</h2><h3 id="general-booting-sequence"><a class="markdownIt-Anchor" href="#general-booting-sequence"></a> General booting sequence</h3><p>Booting an operating system consists of transferring control along a chain of small programs</p><p>An example of the boot process. Each box is a program:</p><img src="../imgs/202409141920846.png" alt="" style="zoom: 33%;" /><ul><li>BIOS</li></ul><p>Today, BIOS mainly runs some early diagnostics (power-on-self-test) and then transfers control to the bootloader.</p><ul><li>The Bootloader</li></ul><p>task: transfer control to the operating system</p><p>Using GRUB, the OS can be built as an ordinary ELF executable, which will be loaded by GRUB into the correct memory location.</p><ul><li>Kernel ELF Information</li></ul><p>Entry point address: where CPU executes the first instruction <strong>after the kernel is loaded into memory by the bootloader</strong>.</p><p>In OS161:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@xxxxxxxxxxxx</span><span class="hljs-symbol">:~/os161/root</span><span class="hljs-comment"># os161-readelf -h kernel</span><br><span class="hljs-title class_">ELF</span> <span class="hljs-symbol">Header:</span><br>  ...<br>  <span class="hljs-title class_">Entry</span> point <span class="hljs-symbol">address:</span>               <span class="hljs-number">0x8002d6f0</span>    //the first instruction to run<br>  ...<br></code></pre></td></tr></table></figure><hr /><h3 id="how-does-the-os-boot-in-os161"><a class="markdownIt-Anchor" href="#how-does-the-os-boot-in-os161"></a> How does the OS boot in OS161?</h3><blockquote><p><strong>Q:</strong> Where does the processor expect to find the very first instruction to run, after it is powered on?</p></blockquote><p>We first need to know the design of MIPS processors.</p><ul><li>MIPS processors</li></ul><p>Physical Memory MIPS assumes:</p><p><img src="../imgs/202409112349239.png" alt="" /></p><p>Virtual Memory MIPS assumes:</p><p><img src="../imgs/202409112350501.png" alt="" /></p><p>Boot ROM area is where the <strong><code>bootloader</code></strong> lives. So 0xbfc00000 is where the very first instruction to run. Namely, after the processor is powered on, the <code>bootloader</code> runs first.</p><p>kernel area:</p><p><img src="../imgs/202409120001748.png" alt="" /></p><p>Draw a <a href="https://drive.google.com/file/d/1UEE5l3ZmK0VskThRifhHr8tAQUrBBvYB/">diagram</a> showing how kseg0 and kseg1 map to the same physical memory area:</p><img src="../imgs/202409121132415.png" alt="" style="zoom:50%;" /><blockquote><p><strong>Q:</strong> Based on that, can you tell what is the maximum amount of virtual memory that a user program can use?</p></blockquote><p>2G</p><blockquote><p><strong>Q:</strong> What is an <strong>exception address</strong> and why is it critical for the boot sequence? Where does the hardware expect to find exception code AFTER we boot (boot flag not set)?</p></blockquote><p><strong>Exception Address</strong> refers to a specific memory location where the processor jumps to when an exception or interrupt occurs.</p><p>After we boot up, boot flag is no longer set, we find exception code in kernel area(0x80000000 and 0x80000080)</p><p>Look at os161 source code:</p><p>Begin with <code>main.c</code> -- it is located in <code>~/os161/src/kern/main/main.c</code>.</p><p>Look at the <code>boot()</code> function. In particular, trace all the way through <code>ram_bootstrap()</code>. Find the lowest-level function that reads the size of the RAM from the hardware:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br><span class="hljs-title function_">lamebus_map_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lamebus_softc *bus, <span class="hljs-type">int</span> slot, <span class="hljs-type">uint32_t</span> offset)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> address;<br><br>(<span class="hljs-type">void</span>)bus;   <span class="hljs-comment">// not needed</span><br><br>KASSERT(slot &gt;= <span class="hljs-number">0</span> &amp;&amp; slot &lt; LB_NSLOTS);<br><br>address = LB_BASEADDR + slot*LB_SLOT_SIZE + offset;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)address;<br>&#125;<br></code></pre></td></tr></table></figure><p>Take a look at <code>~/os161/src/kern/arch/sys161/main/start.S</code>. <strong>Since we are running on the simulator, the early boot code is located not in the boot ROM, but in sys161 -- the hardware simulator.</strong> The code in <code>start.S</code> is the very first code that runs on the system! It sets up the operating system to run and gives you the idea of what the actual boot ROM code looks like.</p><div class="note note-info">            <p>Note that the code in <code>start.S</code> is executed by the hardware simulator and it serves the same purpose as the actual bootloader.</p>          </div><blockquote><p><strong>Q:</strong> How does <code>kmain()</code> get called?</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*<br>* Now, copy the exception handler code onto the first page of memory.<br>*/<br><br>li a0, EXADDR_UTLB<br>la a1, mips_utlb_handler<br>la a2, mips_utlb_end<br>sub a2, a2, a1<br>jal memmove<br>nop<br><br>li a0, EXADDR_GENERAL<br>la a1, mips_general_handler<br>la a2, mips_general_end<br>sub a2, a2, a1<br>jal memmove<br>nop<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*<br>* We&#x27;re all set up!<br>* Fetch the copy of the bootstring as the argument, and call main.<br>*/<br>jal kmain<br>move a0, s0/* in delay slot */<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>To sum up, after the MIPS processor is powered on, it starts executing the code in <code>start.S</code>, which is executed by the sys161 hardware simulator to serve the purpose of the bootloader. The code in <code>start.S</code>, or the bootloader, initialize hardware and load the kernel into memory (including copy the exception handlers to specific memory locations), then transfer controls to the kernel entry point (<code>kmain</code>).</p>          </div>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
