

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/imgs/wallhaven-p9qeze.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Alex Sun">
  <meta name="keywords" content="">
  
    <meta name="description" content="CodeTop高频面试题 每日刷题记录 持续更新题解中...">
<meta property="og:type" content="article">
<meta property="og:title" content="CodeTop每日刷题">
<meta property="og:url" content="http://oooscar8.github.io/2025/02/26/CodeTop/index.html">
<meta property="og:site_name" content="Alex&#39;s Space">
<meta property="og:description" content="CodeTop高频面试题 每日刷题记录 持续更新题解中...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250226002119210-1740507847618-1.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250226022026507-1740507847619-2.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/rev1ex1-1740730077355-1.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/rev1ex2-1740730077355-2.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250228155901013-1740730077356-5.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250227172552837-1740730077356-3.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250227195951624-1740730077356-4.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250228001315221-1740730077356-7.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250228011721923-1740730077356-6.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/reverse_ex1-1740714561484-25-1740820376665-1.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/reverse_ex2-1740820376666-2.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250228142239754-1740820376666-3.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250228154706185-1740820376666-4.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250301171414009.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250303003651920.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250302230928277-1740932494020-1.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250302231029479-1740932494020-2.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/merge_ex1-1740997005127-1.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250303144645759-1740997005128-2.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250303172305424-1740997005128-3.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/tree1-1741019452271-54-1741022849649-1.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250304010913490-1741022849650-2.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/tree1-1741417327569-3-1741450172381-1.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/binarytree-1741450172382-2.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/binarytree-1741450172382-2.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/circularlinkedlist-1741513173102-1.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/circularlinkedlist_test2-1741513173102-3.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/circularlinkedlist_test3-1741513173102-2.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/rev2ex2-1741513173102-4.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image-1741598703839-1.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/spiral1-1741598703840-2.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/spiral-1741598703840-3.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/160_statement-1741768368110-3.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/160_example_1_1-1741768368110-2.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/160_example_2-1741768368110-1.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/160_example_3-1741768368110-4.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/2b1d9a2937b3d27709359bda0a4c378-1741768368110-6.jpg">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250312152905663-1741768368110-7.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/1626420311-PkUiGI-image-1741768368110-5.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/1626420320-YUiulT-image-1741768368110-8.png">
<meta property="og:image" content="http://oooscar8.github.io/2025/02/26/imgs/rainwatertrap-1742049673383-1.png">
<meta property="article:published_time" content="2025-02-25T18:21:45.000Z">
<meta property="article:modified_time" content="2025-03-29T12:31:03.701Z">
<meta property="article:author" content="Alex Sun">
<meta property="article:tag" content="CodeTop">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="刷题">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://oooscar8.github.io/2025/02/26/imgs/image-20250226002119210-1740507847618-1.png">
  
  
  
  <title>CodeTop每日刷题 - Alex&#39;s Space</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"oooscar8.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Alex&#39;s Space</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/imgs/chuyin.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CodeTop每日刷题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-26 02:21" pubdate>
          2025年2月26日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          216 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CodeTop每日刷题</h1>
            
            
              <div class="markdown-body">
                
                <p>从今天开始，我将每天坚持按<code>CodeTop</code>面试出现频度从高到低排序从第一题开始刷起，暂定每日刷两题。将会持续更新题解……</p>
<h1 id="day1226"><a class="markdownIt-Anchor" href="#day1226"></a> Day1(2.26)</h1>
<h2 id="leetcode-3-无重复字符的最长子串medium"><a class="markdownIt-Anchor" href="#leetcode-3-无重复字符的最长子串medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">Leetcode 3. 无重复字符的最长子串(Medium)</a></h2>
<blockquote>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>  请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
</blockquote>
<p>这道题我看了提示第一句：“Generate all possible substrings”被误导了（好吧是我理解的问题），我第一反应是从长到短遍历所有substrings，直到找到第一个不含重复字符的字符串，然后返回其长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> len = s.<span class="hljs-built_in">length</span>(); len &gt; <span class="hljs-number">0</span>; len--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>() - len + <span class="hljs-number">1</span>; i++) &#123;<br>                    string substring = s.<span class="hljs-built_in">substr</span>(i, len);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isUnique</span>(substring)) &#123;<br>                        <span class="hljs-keyword">return</span> substring.<span class="hljs-built_in">length</span>();<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnique</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            unordered_set&lt;<span class="hljs-type">char</span>&gt; set;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>                <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">find</span>(ch) != set.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                set.<span class="hljs-built_in">insert</span>(ch);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>然而这个算法时间复杂度是糟糕的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，连test都要超时，要更换思路。</p>
<p>我想到可以从左到右扫描字符串，用<strong>哈希表</strong>存储扫描到的字符和字符的最后出现位置(index)，用一个<strong>Sliding Window</strong>表示当前扫描到的无重复字符的substring。当遇到重复的字符且该字符在Sliding Window里面，那就需要更新Sliding Window的起始位置；否则的话检查当前的substring的长度是否超过了之前记录的最大长度<code>maxlen</code>，如果是那就更新<code>maxlen</code>。同时每扫描一个字符，都在哈希表中重新更新当前字符的最后出现位置。</p>
<p>这样的话只需要扫描一遍字符串，而在哈希表中通过key寻找值的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，因此总体的时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>! 这就很快了！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; charLastIndex;<br>        <span class="hljs-type">size_t</span> start_pos = <span class="hljs-number">0</span>;   <span class="hljs-comment">// Sliding window的起始位置</span><br>        <span class="hljs-type">size_t</span> max_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (charLastIndex.<span class="hljs-built_in">find</span>(s[i]) != charLastIndex.<span class="hljs-built_in">end</span>() &amp;&amp; charLastIndex[s[i]] &gt;= start_pos) &#123;<br>                <span class="hljs-comment">// 如果当前字符在窗口内出现过，更新窗口的起始位置</span><br>                start_pos = charLastIndex[s[i]] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果当前字符在窗口内没有出现过，检查当前窗口的长度是否是最大的</span><br>                max_len = <span class="hljs-built_in">max</span>(max_len, i - start_pos + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 更新当前字符最后出现的位置</span><br>            charLastIndex[s[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<img src="/imgs/image-20250226002119210-1740507847618-1.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
<h2 id="leetcode-146-lru缓存机制medium"><a class="markdownIt-Anchor" href="#leetcode-146-lru缓存机制medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache">Leetcode 146. LRU缓存机制(Medium)</a></h2>
<blockquote>
<p>请你设计并实现一个满足 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code></li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
</blockquote>
<p>这道题核心关键点在<strong>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行</strong>。</p>
<p><code>get</code>根据key要在常数项时间内得到value，唯一方法就是用哈希表<code>unordered_map</code>存储<code>key-value</code>，但是要evict的时候，单靠哈希表没办法获得LRU key。因此还需要一个数据结构能够在常数项时间内找到LRU key并删除他，同时也需要在访问key之后在常数项时间内重新排序key。要重新排序key，那就肯定要先删除这个key，再将其移动到别的位置。</p>
<p>也就是说，这个数据结构需要能够在常数项时间内删除任意位置的元素，那基本就锁定了，就是链表<code>list</code>!</p>
<p>但是<code>list</code>要在常数项时间内删除任意位置的元素，前提是你要给他指向这个元素的迭代器。 不然的话你通过key遍历链表找到要删除的元素那时间复杂度就是<code>O(N)</code>了。那有什么办法能够给定key，马上得到其在list中的迭代器呢？</p>
<p>那就只能在将key插入链表后，将指向key的迭代器也放入哈希表中。这样你就能通过key在哈希表中得知这个key在list中的位置，然后就能以常数项时间在list中删除key，并将其插入头/尾部了。</p>
<p>确定好数据结构后，实现起来就简单了。我的方法是将新访问/插入的key加到链表的末尾，同时如果key本身在链表中，还要先从当前位置删除，再加到链表末尾。而evict LRU就从链表的头部evict，你也可以将两者反过来，反正<code>list</code>是双端链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123; capacity_ = capacity; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = lru_cache_.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (it == lru_cache_.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        lru_list_.<span class="hljs-built_in">erase</span>(it-&gt;second.first);<br>        lru_list_.<span class="hljs-built_in">push_back</span>(key);<br>        it-&gt;second.first = --lru_list_.<span class="hljs-built_in">end</span>();<br>        <span class="hljs-keyword">return</span> it-&gt;second.second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = lru_cache_.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (it != lru_cache_.<span class="hljs-built_in">end</span>()) &#123;<br>            lru_list_.<span class="hljs-built_in">erase</span>(it-&gt;second.first);<br>            lru_list_.<span class="hljs-built_in">push_back</span>(key);<br>            it-&gt;second.first = --lru_list_.<span class="hljs-built_in">end</span>();<br>            it-&gt;second.second = value;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cache_full</span>()) &#123;<br>                <span class="hljs-built_in">evict_lru</span>();<br>            &#125;<br>            lru_list_.<span class="hljs-built_in">push_back</span>(key);<br>            lru_cache_[key] = &#123;--lru_list_.<span class="hljs-built_in">end</span>(), value&#125;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> capacity_;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::pair&lt;std::list&lt;<span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">int</span>&gt;&gt; lru_cache_;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; lru_list_;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cache_full</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> lru_cache_.<span class="hljs-built_in">size</span>() == capacity_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">evict_lru</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> lru_key = lru_list_.<span class="hljs-built_in">front</span>();<br>        lru_list_.<span class="hljs-built_in">pop_front</span>();<br>        lru_cache_.<span class="hljs-built_in">erase</span>(lru_key);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<img src="/imgs/image-20250226022026507-1740507847619-2.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
<h1 id="day2227"><a class="markdownIt-Anchor" href="#day2227"></a> Day2(2.27)</h1>
<h2 id="leetcode-206-反转链表easy"><a class="markdownIt-Anchor" href="#leetcode-206-反转链表easy"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list">Leetcode 206. 反转链表(Easy)</a></h2>
<blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/rev1ex1-1740730077355-1.jpg" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/imgs/rev1ex2-1740730077355-2.jpg" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶</strong>：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
</blockquote>
<p>目标：分别用迭代和递归的方式解决这道题</p>
<h3 id="迭代法"><a class="markdownIt-Anchor" href="#迭代法"></a> 迭代法</h3>
<p>我的第一想法是一个个遍历<code>head-&gt;next</code>，重新创建一个新结点指向原来的头结点作为新的头结点，然后就将<code>head-&gt;next</code>删掉，删法就是让<code>head-&gt;next</code>指向<code>head-&gt;next-&gt;next</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Iterative solution 1.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *new_head = head;<br><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span> &amp;&amp; head-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            new_head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(head-&gt;next-&gt;val, new_head);<br>            head-&gt;next = head-&gt;next-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> new_head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>但是这样每遍历一个元素，就要多创建一个<code>ListNode</code>非常占用空间，怎么才能仅通过修改指针的方式就翻转整个链表？</p>
<p>答案是每遍历过去一个结点，用<code>pre</code>指针记录下这个结点。这样当遍历到下一个结点的时候，就可以将他的<code>next</code>指针指向<code>pre</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Iterative solution 2 (better).</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *pre = <span class="hljs-literal">NULL</span>;<br><br>        ListNode *p = head;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            ListNode* next = p-&gt;next;<br>            p-&gt;next = pre;<br>            pre = p;<br>            p = next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这样内存消耗就是O(1)复杂度。<code>pre</code>和<code>p</code>指针只要创建一个，随着遍历向后移动。</p>
<img src="/imgs/image-20250228155901013-1740730077356-5.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
<h3 id="递归法"><a class="markdownIt-Anchor" href="#递归法"></a> 递归法</h3>
<p>迭代法往往思路上更简洁优雅，这题也不例外。反转链表，本质上就是重新排序链表中的所有元素。迭代法的想法就是：</p>
<ol>
<li>先翻转（排序）好头结点之后的所有元素，返回新的头结点</li>
<li>再将原本的头结点加到链表末尾</li>
<li>最后返回新的头结点</li>
</ol>
<p>迭代结束的条件就是当前要排序的链表为空或元素个数为1，直接返回当前头结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Recursive solution.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束条件，返回新的头结点</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode *new_head = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br><br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">return</span> new_head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<img src="/imgs/image-20250227172552837-1740730077356-3.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
<h2 id="leetcode-215-数组中的第k个最大元素medium"><a class="markdownIt-Anchor" href="#leetcode-215-数组中的第k个最大元素medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">Leetcode 215. 数组中的第K个最大元素(Medium)</a></h2>
<blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你<strong>必须设计并实现时间复杂度为 <code>O(n)</code> 的算法</strong>解决此问题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4], k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
</blockquote>
<p>这题非常好！可以复习快速排序和堆排序，尤其是快速排序的各种变型！</p>
<p>这道题核心是要求<strong>时间复杂度为 <code>O(n)</code></strong></p>
<h3 id="快速选择"><a class="markdownIt-Anchor" href="#快速选择"></a> 快速选择</h3>
<p>第一种选择：使用快速选择算法。快速选择与快速排序是同样的核心思想，但是快速选择不需要完全排序整个数组，只要在partition的过程中正好找到那个正确位置的pivot就可以了。</p>
<p>快速选择其实有现成的STL算法提供：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基本语法</span><br><span class="hljs-built_in">nth_element</span>(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);<br><br><span class="hljs-comment">// 带比较器的语法</span><br><span class="hljs-built_in">nth_element</span>(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);<br></code></pre></td></tr></table></figure>
<p><code>nth_element</code>能够将在正常排序后会位于指定位置<code>nth</code>的元素放在这个指定位置<code>nth</code>（默认的排序方式是从小到大，也可以自定义比较器。</p>
<p>那这题就秒掉了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">nth_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">begin</span>() + nums.<span class="hljs-built_in">size</span>() - k, nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>但是我头铁想要手撕快速选择：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 手撕快速选择算法</span><br><span class="hljs-comment">// 随机选择pivot</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> nums[left];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> pivotIndex = left + <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">swap</span>(nums[pivotIndex], nums[right]);<br><br>        <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(nums, left, right);<br><br>        <span class="hljs-keyword">if</span> (pivot_index == nums.<span class="hljs-built_in">size</span>() - K) &#123;<br>            <span class="hljs-keyword">return</span> nums[pivot_index];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivot_index &lt; nums.<span class="hljs-built_in">size</span>() - K) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, pivot_index + <span class="hljs-number">1</span>, right, K);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, left, pivot_index - <span class="hljs-number">1</span>, K);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[right];<br>        <span class="hljs-type">int</span> i = left;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = left; j &lt; right; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt;= pivot) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>                ++i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(nums[i], nums[right]);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这样随机选择pivot在大部分case（随机数据）情况下都是<code>O(N)</code>的时间复杂度，除了leetcode上最后一个test case：</p>
<img src="/imgs/image-20250227195951624-1740730077356-4.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />
<p>这个test case包含有大量的重复数字，常规的随机选择pivot拼尽全力也无法战胜。leetcode官方题解为了应对这个精心构造的数据，用了双指针的方法用来在partition的时候<strong>快速向中间收敛</strong>。</p>
<p>修改后用随机选择pivot + 双指针的快速选择算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 手撕快速选择算法</span><br><span class="hljs-comment">// 随机选择pivot + 双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> nums[left];<br>        &#125;<br><br>        <span class="hljs-type">int</span> pivotIndex = left + <span class="hljs-built_in">rand</span>() % (right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">swap</span>(nums[pivotIndex], nums[right]);<br><br>        <span class="hljs-type">int</span> pivot_index = <span class="hljs-built_in">partition</span>(nums, left, right);<br><br>        <span class="hljs-keyword">if</span> (pivot_index == nums.<span class="hljs-built_in">size</span>() - K) &#123;<br>            <span class="hljs-keyword">return</span> nums[pivot_index];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivot_index &lt; nums.<span class="hljs-built_in">size</span>() - K) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, pivot_index + <span class="hljs-number">1</span>, right, K);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, left, pivot_index - <span class="hljs-number">1</span>, K);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[right];<br>        <span class="hljs-type">int</span> i = left - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> j = right;<br><br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-comment">// 从左向右找到第一个大于等于pivot的元素</span><br>            <span class="hljs-keyword">while</span> (++i &lt; right &amp;&amp; nums[i] &lt; pivot);<br>            <span class="hljs-comment">// 从右向左找到第一个小于等于pivot的元素</span><br>            <span class="hljs-keyword">while</span> (--j &gt;= left &amp;&amp; nums[j] &gt; pivot);<br><br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(nums[i], nums[right]);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<img src="/imgs/image-20250228001315221-1740730077356-7.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />
<h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3>
<p>也可以用堆排序算法。同样可以用STL中的priority_queue秒掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// STL priority_queue 堆排序算法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">max_heap</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            max_heap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_heap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>建堆的时间复杂度是<code>O(N)</code>, <code>pop</code>的时间复杂度是<code>O(K * logN)</code>，所以总复杂度还是<code>O(N)</code>符合要求。</p>
<p>但是一样，还是头铁，我要自己建堆！</p>
<p>建堆的过程就是从原先的vector对应的二叉树的最后一个非叶子节点作为根节点的子树开始调整，调整为大根堆，然后依次向上继续调整。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 手撕堆排序算法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">buildMaxHeap</span>(nums);<br><br>        <span class="hljs-type">int</span> heapSize = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; ++i) &#123;<br>            nums[<span class="hljs-number">0</span>] = nums[heapSize - <span class="hljs-number">1</span>];<br>            heapSize--;<br>            <span class="hljs-built_in">maxHeapify</span>(nums, <span class="hljs-number">0</span>, heapSize);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> heapSize = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 从最后一个非叶子节点为根节点的子树开始，将其调整为大根堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = heapSize / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-built_in">maxHeapify</span>(nums, i, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> largest = i;<br><br>        <span class="hljs-keyword">if</span> (left &lt; heapSize &amp;&amp; nums[left] &gt; nums[largest]) &#123;<br>            largest = left;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; heapSize &amp;&amp; nums[right] &gt; nums[largest]) &#123;<br>            largest = right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (largest != i) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[largest]);<br>            <span class="hljs-built_in">maxHeapify</span>(nums, largest, heapSize);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<img src="/imgs/image-20250228011721923-1740730077356-6.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
<h1 id="day3228"><a class="markdownIt-Anchor" href="#day3228"></a> Day3(2.28)</h1>
<h2 id="leetcode-25-k-个一组翻转链表hard"><a class="markdownIt-Anchor" href="#leetcode-25-k-个一组翻转链表hard"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group">Leetcode 25. K 个一组翻转链表(Hard)</a></h2>
<blockquote>
<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/reverse_ex1-1740714561484-25-1740820376665-1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/imgs/reverse_ex2-1740820376666-2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[3,2,1,4,5]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中的节点数目为 <code>n</code></li>
<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>**进阶：**你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p>
</blockquote>
<h3 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h3>
<p>我第一个想到的办法是复用之前<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list">Leetcode 206. 反转链表(Easy)</a>的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Recursive solution.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束条件，返回新的头结点</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode *new_head = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br><br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">return</span> new_head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>我之前用递归的方法<strong>翻转一个链表</strong>。这题K个结点一组翻转链表无非就是<strong>翻转N/K个子链表</strong>。需要变化的点就是原先翻转后的链表末尾指向<code>NULL</code>，而这题中翻转后的<strong>子链表的末尾应该指向下一个子链表的头结点</strong>。并且递归条件从原本的<code>head-&gt;next == NULL</code>改成<code>k == 1</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 翻转一个从head开始K个结点的子链表，翻转后的链表末尾指向tail</span><br><span class="hljs-comment">// 返回翻转后的子链表的头结点</span><br><span class="hljs-function">ListNode *<span class="hljs-title">reverseKList</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k, ListNode *tail)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 递归结束条件，返回新的头结点</span><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    ListNode *new_head = <span class="hljs-built_in">reverseKList</span>(head-&gt;next, k - <span class="hljs-number">1</span>, tail);<br><br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = tail;<br><br>    <span class="hljs-keyword">return</span> new_head;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有了这个helper function，下一步就是翻转一个个子链表(Group)然后让他们首尾相接就可以了。我还是用递归的方法实现<code>reverseKGroup</code>：</p>
<ol>
<li>先翻转第一个Group之后的所有Group让他们首尾相接，返回翻转好的链表的头结点</li>
<li>再翻转第一个Group，并将翻转好的第一个Group的末尾指向后面翻转好的链表的头结点</li>
<li>最后返回新的头结点</li>
</ol>
<p>要特别注意的是<code>reverseKGroup</code>递归的结束条件是当前要翻转的链表中的结点数量小于K（不到一个Group），这种情况就不进行翻转直接返回原先的头结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode *tail = head;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (tail != <span class="hljs-literal">NULL</span> &amp;&amp; count &lt; k )<br>    &#123;<br>        tail = tail-&gt;next;<br>        ++count;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt; k) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    tail = <span class="hljs-built_in">reverseKGroup</span>(tail, k);<br>    head = <span class="hljs-built_in">reverseKList</span>(head, k, tail);<br><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/imgs/image-20250228142239754-1740820376666-3.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
<p>这个算法需要递归调用<code>reverseKGroup</code> N/K次，因此空间复杂度是<code>O(N/K)</code>。</p>
<p>那怎么才能实现进阶要求的<code>O(1)</code>空间复杂度呢？那<code>reverseKGroup</code>和<code>reverseKList</code>就不能用递归，得用迭代。</p>
<h3 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Iterative solution</span><br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br><br>        ListNode* pre = dummy;<br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            ListNode *tail = pre;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>                tail = tail-&gt;next;<br>                <span class="hljs-keyword">if</span> (tail == <span class="hljs-literal">NULL</span>) &#123;<br>                    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 此时的tail就指向我们当前要翻转的子链表的尾结点</span><br>            ListNode *next  = tail-&gt;next;<br>            <span class="hljs-built_in">tie</span>(head, tail) = <span class="hljs-built_in">reverseKList</span>(head, tail);<br>            <span class="hljs-comment">// 将翻转后的子链表接回原链表</span><br>            tail-&gt;next = next;<br>            pre-&gt;next = head;<br>            <span class="hljs-comment">// 移动指针到下一个子链表的开头</span><br>            pre = tail;<br>            head = next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 翻转一个头结点为head，尾结点为tail的子链表</span><br>    <span class="hljs-comment">// 返回翻转后的子链表的头结点和尾结点</span><br>    <span class="hljs-function">pair&lt;ListNode*, ListNode*&gt; <span class="hljs-title">reverseKList</span><span class="hljs-params">(ListNode *head, ListNode *tail)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *pre = tail-&gt;next;<br><br>        ListNode *p = head;<br>        <span class="hljs-keyword">while</span> (pre != tail) &#123;<br>            ListNode* next = p-&gt;next;<br>            p-&gt;next = pre;<br>            pre = p;<br>            p = next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;pre, head&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>我们每翻转完一个Group的子链表，将子链表的尾结点作为<code>pre</code>记录下来，这样当翻转完下一个子链表的时候就可以将翻转后的子链表接回去。</p>
<p>那第一个Group的子链表没有<code>pre</code>怎么办呢？难道要特殊处理吗？</p>
<p>我们这里用到了一个tricky的方法，在整个链表的头结点前加一个dummy node指向头结点，这的<code>pre</code>的初始值就是dummy，不需要特殊处理。这个dummy node还有一个好处就是当最后返回整个翻转后的链表的头结点的时候，<code>dummy-&gt;next</code>就正好是我们要找的头结点！一举两得！</p>
<img src="/imgs/image-20250228154706185-1740820376666-4.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
<p>这样实现我们只需要构造常数个变量，<code>pre</code>,<code>head</code>,<code>tail</code>指针都会跟着链表的遍历向后变化。</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>从实现的思路上来看，我觉得递归法比迭代法更简洁直观，也更容易写对（不用dummy node这种trick）。但是从内存消耗上来说，迭代法只需要创建常量个变量，而递归法需要消耗栈空间。</p>
<h2 id="leetcode-15-三数之和medium"><a class="markdownIt-Anchor" href="#leetcode-15-三数之和medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum">Leetcode 15. 三数之和(Medium)</a></h2>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p>**注意：**答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
</blockquote>
<h3 id="两数之和"><a class="markdownIt-Anchor" href="#两数之和"></a> 两数之和</h3>
<p>这题是两数之和问题的扩展，因此我先做了两数之和问题：</p>
<blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
</blockquote>
<p>这题就很简单，因为题目前提是只会存在一个有效答案，因此不需要担心重复问题。只需要用一个哈希表存储每个元素值和其对应的index。这样就可以以O(1)的时间复杂度找到对应值的index。因此总体的时间复杂度就是遍历一遍<code>nums</code>的<code>O(N)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            hashmap.<span class="hljs-built_in">insert</span>(&#123;nums[i], i&#125;);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; index;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> range = hashmap.<span class="hljs-built_in">equal_range</span>(target - nums[i]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = range.first; it != range.second; it++)<br>                <span class="hljs-comment">// 找到第一个不是当前i的index</span><br>                <span class="hljs-keyword">if</span> (it-&gt;second != i)<br>                &#123;<br>                    index.<span class="hljs-built_in">push_back</span>(i);<br>                    index.<span class="hljs-built_in">push_back</span>(it-&gt;second);<br>                    <span class="hljs-keyword">return</span> index;<br>                &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>然而此题三数之和问题如果沿用哈希表，先解决两数之和问题，再加上第三个数，就会得到大量的重复的三元组，还要用哈希表做去重操作，非常消耗时间和空间。因此需要更换思路。</p>
<h3 id="三数之和排序双指针"><a class="markdownIt-Anchor" href="#三数之和排序双指针"></a> 三数之和：排序+双指针</h3>
<p>三数之和这道题可以用双指针精妙地将原本三层遍历<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的时间复杂度降到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​，具体的证明过程非常建议去看一下leetcode官方题解，讲得非常好！在这里我尝试简单说明一下：</p>
<p>首先我们要解决的是重复性问题，怎么才能保证不会得到重复的三元组？</p>
<p>我们仍需要使用三重循环，第一重大循环获取第一个数，第二、三重循环获取第二、三个数，我们只需要规定好每重循环枚举到的元素大小顺序就可以了。</p>
<p>具体来说，我们规定三重遍历中第二重循环枚举到的元素比第一重循环枚举到的元素大，第三重循环枚举到的元素比第二重循环枚举到的元素大，这样我们获得的三元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b, c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>的大小顺序一定是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mo>=</mo><mi>b</mi><mo>&lt;</mo><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a &lt;= b &lt;= c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>。要实现这一点，我们就需要先对数组从小到大排序。同时，对数组从小到大排序后，我们每层循环时，就可以跳过相邻的重复元素。</p>
<p>解决了重复性问题，接下来就是怎么才能将原本的三重循环降到只需要遍历两次数组呢？</p>
<p>可以这样思考，一旦固定了第二个数，那么第三个数就唯一确定了。并且由于我们是从左到右（从小到大）遍历第二个数，那么我们可以同时从右到左遍历第三个数。一旦第三个数找到了，他右边的数就再也不会用到了（因为我们接下来遍历到的第二个数只会更大，所以以后只需要继续遍历这第三个数左边的数）。</p>
<p>到这里解法就很清晰了，要用左右双指针分别指向遍历到的第二个数和第三个数。左指针只需要向右遍历，右指针只需要向左遍历，因此第二、三重循环加起来只需要遍历一次数组。再加上第一层大循环，总的时间复杂度就变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        // 将nums数组从小到大排序<br>        nums.sort(nums.begin(), nums.end());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = 0; i &lt; nums.size(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            // 定义双指针<br>            <span class="hljs-type">int</span> l = i + 1;<br>            <span class="hljs-type">int</span> r = num.size() - 1;<br>            <span class="hljs-type">int</span> target = -nums[i];<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                // 如果<br>                // 1. 当前左指针指向的数与前一个数相同；<br>                // 2. 或者左右指针指向的数相加小于target(说明再向左移动右指针也不可能找到等于target的和了)；<br>                // 则向右移动左指针，右指针不动<br>                <span class="hljs-keyword">if</span> ((l != i + 1 &amp;&amp; nums[l] == nums[l - 1]) || nums[l] + nums[r] &lt; target) &#123;<br>                    l++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[l] + nums[r] == target) &#123;<br>                    result.push_back(&#123;nums[i], nums[l], nums[r]&#125;);<br>                    l++;<br>                    r--;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                // 到这一步，说明nums[l] + nums[r] &gt; target，那就要向左移动右指针, 左指针不动<br>                r--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<img src="/imgs/image-20250301171414009.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
<h1 id="day431"><a class="markdownIt-Anchor" href="#day431"></a> Day4(3.1)</h1>
<h2 id="leetcode-53-最大子数组和medium"><a class="markdownIt-Anchor" href="#leetcode-53-最大子数组和medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray">Leetcode 53. 最大子数组和(Medium)</a></h2>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
</blockquote>
<h3 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h3>
<p>这题是非常经典可以用动态规划算法来解决的。求解一个数组的最大子数组问题，可以分解为求解以每个位置结尾的最大子数组和，然后取最大值。</p>
<p>用数学语言表述就是：我们用<code>f(i)</code>代表以第 i 个数结尾的「连续子数组的最大和」，我们要求解的最大子数组就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow></msub><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">max_{0≤i≤n−1}{f(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">n</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></span></p>
<p>那么我们如何求解每个位置的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>呢？这里就是动态规划的核心解决的问题：<strong>子问题重叠</strong>。每个位置的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，都与前一个位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>有关。当我们在寻找以<code>nums[i]</code>为结尾的最大子数组时，可以比较<code>f(i - 1) + nums[i]</code>大，还是<code>nums[i]</code>大，来决定是将<code>nums[i]</code>加入到前一个元素为结尾的最大子数组中，还是单独新成立一个子数组。即，</p>
<p><code>f(i) = max(f(i-1) + nums[i], nums[i])</code></p>
<p>这就是本题动态规划的<strong>状态转移方程</strong>建立的递推关系。</p>
<p>在空间利用上，我们只需要一个<code>max_fi</code>存储全局的最大子数组之和，一个<code>pre_fi</code>来存储前一个位置的状态（最大子数组之和）。因为计算当前位置的状态只需要用到前一个位置的状态。因此空间复杂度是<code>O(1)</code>。同时因为只需要遍历一遍数组，时间复杂度是<code>O(N)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 动态规划</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> max_fi = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-type">int</span> pre_fi = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> fi = <span class="hljs-built_in">max</span>(nums[i], pre_fi + nums[i])<br>                <span class="hljs-keyword">if</span> (fi &gt; max_fi) &#123;<br>                    max_fi = fi;<br>                &#125;<br>            pre_fi = fi;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_fi;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<img src="/imgs/image-20250303003651920.png" srcset="/img/loading.gif" lazyload alt="" style="zoom:67%;" />
<h2 id="leetcode-补充题4-手撕快速排序medium"><a class="markdownIt-Anchor" href="#leetcode-补充题4-手撕快速排序medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array">Leetcode 补充题4. 手撕快速排序(Medium)</a></h2>
<blockquote>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p>
<p>你必须在 <strong>不使用任何内置函数</strong> 的情况下解决问题，时间复杂度为 <code>O(nlog(n))</code>，并且空间复杂度尽可能小。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">5,2,3,1</span>]<br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,1,1,2,0,0]</span><br>输出：<span class="hljs-string">[0,0,1,1,2,5]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li>
<li><code>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></li>
</ul>
</blockquote>
<p>时间复杂度为 O(nlog(n))的排序数组方式有很多种，但CodeTop这题指定我们手撕快速排序。快速排序是非常重要经常考察的一种排序方式。在Day2中我刚刚手撕过快速排序的变型快速选择，今天借着这道题就来熟练一下手撕快速排序！</p>
<h3 id="第一版随机快排递归"><a class="markdownIt-Anchor" href="#第一版随机快排递归"></a> 第一版：随机快排+递归</h3>
<p>这基本就是常规的快排写法，唯一的优化就是随机选取pivot。这题的测试集有一个顺序排序好的数组，如果不随机选pivot时间复杂度会变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，过不了test</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 随机快排 + 递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 初始化随机数种子</span><br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br>        <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (begin &gt;= end)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Randomly select the pivot</span><br>        <span class="hljs-type">int</span> pivot_index = begin + <span class="hljs-built_in">rand</span>() % (end - begin + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">swap</span>(nums[pivot_index], nums[end]);<br><br>        pivot_index = <span class="hljs-built_in">partition</span>(nums, begin, end);<br><br>        <span class="hljs-built_in">quickSort</span>(nums, begin, pivot_index - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(nums, pivot_index + <span class="hljs-number">1</span>, end);<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Return the index of the pivot after partitioning</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[end];<br>        <span class="hljs-comment">// i指向小于pivot的区域的最后一个元素</span><br>        <span class="hljs-type">int</span> i = begin - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = begin; j &lt; end; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; pivot)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[++i], nums[j]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(nums[i + <span class="hljs-number">1</span>], nums[end]);<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这也是leetcode官方题解的写法。然而实测速度非常感人。原因是测试集里那个全是相同数的数组。二路分区（分为小于pivot的部分和大于pivot的部分）的策略也会导致相同的数都归到pivot同一侧，时间复杂度变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<img src="/imgs/image-20250302230928277-1740932494020-1.png" srcset="/img/loading.gif" lazyload alt="" style="zoom:67%;" />
<p>那么这题就不能用快排来写吗？不！我还要优化！</p>
<h3 id="第二版三路随机快排尾递归优化"><a class="markdownIt-Anchor" href="#第二版三路随机快排尾递归优化"></a> 第二版：三路随机快排+尾递归优化</h3>
<p>为了能handle那个逆天的全是相同数字的数组，我决定采用<strong>三路分区</strong>来完成partition。也就是说，将数组分为小于pivot，等于pivot，和大于pivot三个部分。这样partition过后只需要对小于pivot的部分和大于pivot的部分进行快排就行了。</p>
<p>第二个优化的点就是我将<code>quickSort</code>中连续的两个递归转化成了先递归pivot一侧的元素，然后迭代进行第二次递归pivot另一侧的元素，应该能够减少一点栈空间的消耗。虽然实测效果不明显。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 三路随机快排+尾递归优化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 初始化随机数种子</span><br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br>        <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span> (begin &lt; end)<br>        &#123;<br>            <span class="hljs-comment">// Randomly select the pivot</span><br>            <span class="hljs-type">int</span> pivot_index = begin + <span class="hljs-built_in">rand</span>() % (end - begin + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">swap</span>(nums[pivot_index], nums[end]);<br><br>            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pivot_range = <span class="hljs-built_in">threeWayPartition</span>(nums, begin, end);<br><br>            <span class="hljs-comment">// 先处理较小的分区，迭代处理较大的分区</span><br>            <span class="hljs-keyword">if</span> (pivot_range.first - begin &lt; end - pivot_range.second)<br>            &#123;<br>                <span class="hljs-built_in">quickSort</span>(nums, begin, pivot_range.first - <span class="hljs-number">1</span>);<br>                begin = pivot_range.second + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">quickSort</span>(nums, pivot_range.second + <span class="hljs-number">1</span>, end);<br>                end = pivot_range.first - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 三路分区</span><br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">threeWayPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[end];<br>        <span class="hljs-type">int</span> lt = begin;<br>        <span class="hljs-type">int</span> gt = end;<br>        <span class="hljs-type">int</span> i = begin;<br><br>        <span class="hljs-keyword">while</span> (i &lt;= gt)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; pivot)<br>                <span class="hljs-built_in">swap</span>(nums[i++], nums[lt++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; pivot)<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[gt--]);<br>            <span class="hljs-keyword">else</span><br>                i++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;lt, gt&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>不多说，效果见图，神中神！ 谁说这题不能用快排写？</p>
<img src="/imgs/image-20250302231029479-1740932494020-2.png" srcset="/img/loading.gif" lazyload alt="" style="zoom:67%;" />
<h1 id="day533"><a class="markdownIt-Anchor" href="#day533"></a> Day5(3.3)</h1>
<h2 id="leetcode-21-合并两个有序链表easy"><a class="markdownIt-Anchor" href="#leetcode-21-合并两个有序链表easy"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists">Leetcode 21. 合并两个有序链表(Easy)</a></h2>
<blockquote>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/merge_ex1-1740997005127-1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
</blockquote>
<h3 id="迭代-2"><a class="markdownIt-Anchor" href="#迭代-2"></a> 迭代</h3>
<p>这题我想到的解法是用迭代法，用一个指针p来指向合并的链表末尾，用两个指针p1和p2分别指向当前需要比较的两个list的元素。我还在合并的链表的头结点前面加了一个dummy node，方便最后返回合并链表的头结点<code>dummy-&gt;next</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 迭代法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode *list1, ListNode *list2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* p1 = list1;<br>        ListNode* p2 = list2;<br>        ListNode* p = dummy;<br><br>        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">NULL</span> &amp;&amp; p2 != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;<br>                p-&gt;next = p1;<br>                p1 = p1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p-&gt;next = p2;<br>                p2 = p2-&gt;next;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!p2) p-&gt;next = p1;<br>        <span class="hljs-keyword">if</span> (!p1) p-&gt;next = p2;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="递归-2"><a class="markdownIt-Anchor" href="#递归-2"></a> 递归</h3>
<p>递归法其实感觉才是yyds，因为思路很简洁清晰，很容易写对。</p>
<p>两个链表的merge操作用递归定义其实就是：</p>
<p><img src="/imgs/image-20250303144645759-1740997005128-2.png" srcset="/img/loading.gif" lazyload alt="摘自Leetcode官方题解" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode *list1, ListNode *list2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!list1) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (!list2) <span class="hljs-keyword">return</span> list1;<br><br>        <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>            list1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1-&gt;next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        <br>        list2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1, list2-&gt;next);<br>        <span class="hljs-keyword">return</span> list2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h3>
<p>迭代和递归法时间复杂度都是O(N + M)。</p>
<p>迭代法空间复杂度是O(1)，只需要维护常数个变量；递归法空间复杂度是O(N+M)，因为递归调用需要消耗栈空间，递归调用深度是O(N + M)。</p>
<h2 id="leetcode-5-最长回文子串medium"><a class="markdownIt-Anchor" href="#leetcode-5-最长回文子串medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring">Leetcode 5. 最长回文子串(Medium)</a></h2>
<blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
</blockquote>
<h3 id="中心扩展-双指针"><a class="markdownIt-Anchor" href="#中心扩展-双指针"></a> 中心扩展 + 双指针</h3>
<p>这题我自己的解法是运用双指针来完成中心扩展。可以这样想：回文字符串，是从最中心的1个字符或2个（相等）字符向外扩展的。因此当我们每遍历1个字符，或2个相邻的相同字符，就分别向左向右扩展1个字符（用左右双指针），查看这两个字符是否相等，如果相等那我们就得到了新的更长的字符串（接下来就记录下来当前的子串，然后继续向左向右扩展），否则就可以返回我们上次记录下来的子串。这个返回的子串就是以我们遍历到的那1个字符或2个（相等）字符为回文中心的最长子串。</p>
<p>这个算法的时间复杂度是多少呢？最外层是遍历(N次)字符寻找回文中心，第二层是根据回文中心向外扩展。要注意的是回文中心有长度为1和长度为2两种情况，因此第二层实际上是两次循环。总时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度是O(1)，只需要一个全局的<code>longest</code>来记录当前遍历过得回文中心里最长的子串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; longest;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= i + <span class="hljs-number">1</span>; ++j) &#123;<br>                    <span class="hljs-type">int</span> l = i;<br>                    <span class="hljs-type">int</span> r = j;<br>                    <span class="hljs-keyword">if</span> (r &gt;= s.<span class="hljs-built_in">size</span>() || s[l] != s[j]) <span class="hljs-keyword">break</span>;<br>                    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pre = &#123;l, r&#125;;<br>                    <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt;= s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (s[l] != s[r]) <span class="hljs-keyword">break</span>;<br>                        pre = &#123;l, r&#125;;<br>                        l--;<br>                        r++;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (pre.second - pre.first &gt; longest.second - longest.first) &#123;<br>                        longest = pre;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(longest.first, longest.second - longest.first + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure>
<img src="/imgs/image-20250303172305424-1740997005128-3.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
<h3 id="动态规划-2"><a class="markdownIt-Anchor" href="#动态规划-2"></a> 动态规划</h3>
<p>上面中心扩展的方法效果已经够好了，为什么还要用动态规划写一遍呢？因为动态规划的解法具有更强的普适性。</p>
<p>为什么这题可以用动态规划求解？可以这样思考：我们要判定一个子串是否是回文子串，与这个子串去掉最左右两个字符的子串是否是回文数列有关。P(i, j)为true表示以下标i为开头，j为结尾的子串是回文子串。可以写出动态规划的<strong>状态转移方程</strong>：</p>
<p>$ P(i,j)=P(i+1,j−1)∧(S_i==S_j) $</p>
<p>因此可以用一个二维数组表示dp，其中数组的两个下标分别代表i, j，数组的值就是bool值表示当前子串是否是回文子串。数组的初始值先都设置为false，除了i = j的数组元素设置为true。</p>
<p>注意在状态转移方程中，我们是从<strong>长度较短的字符串向长度较长的字符串进行转移</strong>的，因此循环的顺序是从短字符到长字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 动态规划 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>            vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<br>            <span class="hljs-comment">// 初始化dp数组</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                dp[i][i] = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 从短字符开始循环更新dp数组，向长字符转移</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> L = <span class="hljs-number">2</span>; L &lt;= n; ++L) &#123;<br>                <span class="hljs-comment">// 先固定左指针，就能根据长度唯一确定右指针</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; n; ++l) &#123;<br>                    <span class="hljs-type">int</span> r = l + L - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (r &gt;= n) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (s[l] != s[r]) <span class="hljs-keyword">continue</span>;<br><br>                    <span class="hljs-comment">// 运行到这里，说明s[l] = s[r]，更新dp数组</span><br>                    <span class="hljs-keyword">if</span> (r - l &lt; <span class="hljs-number">3</span>) &#123;<br>                        dp[l][r] = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[l][r] = dp[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>];<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (dp[l][r] &amp;&amp; L &gt; maxLen) &#123;<br>                        begin = l;<br>                        maxLen = L;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(begin, maxLen);<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure>
<p>动态规划的总时间复杂度还是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为判断子串是否是回文子串可以根据转移前的状态来判断，时间复杂度是<code>O(1)</code></p>
<p>但是空间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为需要构建二维dp数组来保存所有子串的状态（是否是回文子串）</p>
<p>这里再总结一下动态规划的解题步骤：</p>
<ol>
<li>确定dp数组及下标的含义（有哪些变量？状态是什么？）</li>
<li>确定状态转移方程/递推公式（如何根据前面已得知的状态推导出当前要求解的状态）</li>
<li>初始化dp数组（包括边界条件）</li>
<li>确定遍历顺序（已知的状态-&gt;未知的状态）</li>
</ol>
<h1 id="day634"><a class="markdownIt-Anchor" href="#day634"></a> Day6(3.4)</h1>
<h2 id="leetcode-102-二叉树的层序遍历medium"><a class="markdownIt-Anchor" href="#leetcode-102-二叉树的层序遍历medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal">Leetcode 102. 二叉树的层序遍历(Medium)</a></h2>
<blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/tree1-1741019452271-54-1741022849649-1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</blockquote>
<h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h3>
<p>二叉树的层序遍历，就是经典的BFS(深度优先搜索)算法，用一个queue来完成。每遍历一层，将每个节点的左右孩子push进queue，然后pop当前节点。每层遍历完后，正好这层的所有节点都pop出去了，下一层的所有节点都在queue中，通过<code>queue.size()</code>就可以知道下一层的节点个数，以此确定下层的循环遍历次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>            queue&lt;TreeNode *&gt; queue;<br>            <span class="hljs-keyword">if</span> (root) queue.<span class="hljs-built_in">push</span>(root);<br><br>            <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><br>                <span class="hljs-type">int</span> n = queue.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                    TreeNode* cur = queue.<span class="hljs-built_in">front</span>();<br>                    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                    <span class="hljs-keyword">if</span> (cur-&gt;left) queue.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    <span class="hljs-keyword">if</span> (cur-&gt;right) queue.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    queue.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <br>                result.<span class="hljs-built_in">push_back</span>(vec);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h3>
<p>每个节点进队出队各一次，时间复杂度是O(N)；</p>
<p>队列中的元素不超过N个，空间复杂度是O(N)。</p>
<img src="/imgs/image-20250304010913490-1741022849650-2.png" srcset="/img/loading.gif" lazyload alt="" style="zoom: 67%;" />
<h2 id="leetcode-1-两数之和easy"><a class="markdownIt-Anchor" href="#leetcode-1-两数之和easy"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum">Leetcode 1. 两数之和(Easy)</a></h2>
<blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
</blockquote>
<p>这题在Day3做三数之和问题的时候已经提前做过了，这里就当再复习一遍吧。</p>
<p>题目前提是只会存在一个有效答案，因此不需要担心重复问题。只需要用一个哈希表存储每个元素值和其对应的index。这样就可以以O(1)的时间复杂度找到对应值的index。因此总体的时间复杂度就是遍历一遍<code>nums</code>的<code>O(N)</code>，空间复杂度也是<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        unordered_multimap&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            hashmap.<span class="hljs-built_in">insert</span>(&#123;nums[i], i&#125;);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; index;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> range = hashmap.<span class="hljs-built_in">equal_range</span>(target - nums[i]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = range.first; it != range.second; it++)<br>                <span class="hljs-comment">// 找到第一个不是当前i的index</span><br>                <span class="hljs-keyword">if</span> (it-&gt;second != i)<br>                &#123;<br>                    index.<span class="hljs-built_in">push_back</span>(i);<br>                    index.<span class="hljs-built_in">push_back</span>(it-&gt;second);<br>                    <span class="hljs-keyword">return</span> index;<br>                &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="day735"><a class="markdownIt-Anchor" href="#day735"></a> Day7(3.5)</h1>
<h2 id="leetcode-33-搜索旋转排序数组medium"><a class="markdownIt-Anchor" href="#leetcode-33-搜索旋转排序数组medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array">Leetcode 33. 搜索旋转排序数组(Medium)</a></h2>
<blockquote>
<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>
<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
</blockquote>
<h3 id="二分查找变型"><a class="markdownIt-Anchor" href="#二分查找变型"></a> 二分查找（变型）</h3>
<p>这题就是在一个（类似）排序好的数组里找某个值的位置，显然是用二分法来查找。</p>
<p>但是这个数组并不是完全排序好的，而是<strong>由两段排序好的子数组拼接而成</strong>，那么我们自然思路就是先找到拼接的分界点，然后根据target的大小选择其中一段子数组来进行二分查找。</p>
<p>我们可以注意到第一段子数组的第一个元素和第二段子个数组的最后一个元素在旋转前的数组中是相邻的两个数。我们可以用类似于二分法的方式找到这两段子数组的拼接点，具体来说就是找到第二段子数组的第一个元素的下标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回数组最小的元素下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (nums[m] &gt;= nums[<span class="hljs-number">0</span>] &amp;&amp; nums[m + <span class="hljs-number">1</span>] &lt; nums[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">return</span> m + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nums[m] &gt;= nums[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, m + <span class="hljs-number">1</span>, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, l, m - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>找到这个拼接点的下标后，就可以根据target的大小选择其中一个子数组进行二分查找了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> min_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; nums[n - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-comment">// 找到数组中最小值的下标，也就是两个子数组的拼接点</span><br>        min_index = <span class="hljs-built_in">binary_search</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (target &lt;= nums[n - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, min_index, n - <span class="hljs-number">1</span>, target);<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, <span class="hljs-number">0</span>, min_index - <span class="hljs-number">1</span>, target);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nums[m] == target) &#123;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nums[m] &lt; target) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, m + <span class="hljs-number">1</span>, r, target); <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">binary_search</span>(nums, l, m - <span class="hljs-number">1</span>, target);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度分析-3"><a class="markdownIt-Anchor" href="#复杂度分析-3"></a> 复杂度分析</h3>
<p>这题就是做两次二分查找，第一次先找到拼接点的下标，第二次在其中一个子数组中做普通的二分查找。因此总时间复杂度是<code>O(logN)</code></p>
<p>我是用递归的方法做二分查找的，递归深度是<code>logN</code>，因此空间复杂度是<code>O(logN)</code></p>
<h2 id="leetcode-200-岛屿数量medium"><a class="markdownIt-Anchor" href="#leetcode-200-岛屿数量medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands">Leetcode 200. 岛屿数量(Medium)</a></h2>
<blockquote>
<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>[<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li>
</ul>
</blockquote>
<h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h3>
<p>用DFS解这题的思路很简单，每遍历到一个陆地（‘1’），就用DFS将其连接的陆地（‘1’）都变为‘0’。最后岛屿的数量就是遍历到的陆地数量。</p>
<p>我们先回顾一下dfs的代码框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">void dfs(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本节点所连接的其他节点) &#123;<br>        处理节点;<br>        dfs(图，选择的节点); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这题处理节点就是将当前节点变为0，然后dfs当前节点相邻的四个节点，dfs终止条件就是当前节点是0。不需要存放任何结果，因此回溯时也不用撤销处理结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// DFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> num_islands = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; rows; ++row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; cols; ++col) &#123;<br>                <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 新的岛屿，开始进行DFS</span><br>                ++num_islands;<br>                <span class="hljs-built_in">dfs</span>(grid, row, col);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num_islands;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br>        grid[row][col] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span> (row - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row - <span class="hljs-number">1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, row - <span class="hljs-number">1</span>, col);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (row + <span class="hljs-number">1</span> &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; grid[row + <span class="hljs-number">1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, row + <span class="hljs-number">1</span>, col)<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[row][col - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, row, col - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col + <span class="hljs-number">1</span> &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[row][col + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, row, col + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度是<code>O(M * N)</code>，空间复杂度由DFS深度决定，深度最多是M * N（网格上全是陆地），因此空间复杂度是<code>O(M * N)</code></p>
<h3 id="bfs-2"><a class="markdownIt-Anchor" href="#bfs-2"></a> BFS</h3>
<p>岛屿问题也可以用BFS来解决，同样也是每遍历到一个岛屿，就用BFS将其连接的陆地（‘1’）都变为‘0’。只不过BFS是将遍历到的岛屿作为中心一圈一圈向外扩展，而DFS是找到一条路径搜到底，然后再回溯。</p>
<p>BFS需要用一个队列来存储当前遍历到的位置，要注意的是每次元素<strong>入队后应立即对其进行标记</strong>，避免重复访问。</p>
<p>回顾一下BFS的代码框架：（针对四方格地图）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 表示四个方向</span><br><span class="hljs-comment">// grid是地图，也就是一个二维数组</span><br><span class="hljs-comment">// visited标记访问过的节点，不要重复访问</span><br><span class="hljs-comment">// x, y表示开始搜索的节点下标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// 定义队列</span><br>    que.<span class="hljs-built_in">push</span>(&#123;x, y&#125;); <span class="hljs-comment">// 起始节点加入队列</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//只要加入队列，立刻标记为访问过的节点</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 从队头取元素</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second; <span class="hljs-comment">// 当前节点坐标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-comment">// 开始向当前节点的四个方向左右上下去遍历</span><br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 坐标越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty]) &#123;<br>                <span class="hljs-comment">// 如果节点没被访问过</span><br>                que.<span class="hljs-built_in">push</span>(&#123;nextx, nexty&#125;); <span class="hljs-comment">// 队列添加该节点为下一轮要遍历的节点</span><br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记，避免重复访问</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么这题就很简单了，往模版里套就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// BFS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rows = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> num_islands = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 4个方向</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; rows; ++row)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; cols; ++col)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (grid[row][col] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 新的岛屿，开始进行BFS</span><br>                ++num_islands;<br>                queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>                q.<span class="hljs-built_in">push</span>(&#123;row, col&#125;);<br>                grid[row][col] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = q.<span class="hljs-built_in">front</span>();<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>                    &#123;<br>                        <span class="hljs-type">int</span> next_row = cur.first + dir[i][<span class="hljs-number">0</span>];<br>                        <span class="hljs-type">int</span> next_col = cur.second + dir[i][<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span> (next_row &gt;= <span class="hljs-number">0</span> &amp;&amp; next_row &lt; rows &amp;&amp; next_col &gt;= <span class="hljs-number">0</span> &amp;&amp; next_col &lt; cols &amp;&amp; grid[next_row][next_col] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                        &#123;<br>                            q.<span class="hljs-built_in">push</span>(&#123;next_row, next_col&#125;);<br>                            grid[next_row][next_col] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num_islands;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度是<code>O(M * N)</code>；空间复杂度是<code>O(min&#123;M, N&#125;)</code>，因为在最坏情况下，也就是网格中全是陆地（‘1’），队列中最多同时存在<code>min&#123;M, N&#125;</code>个元素。</p>
<h1 id="day836"><a class="markdownIt-Anchor" href="#day836"></a> Day8(3.6)</h1>
<h2 id="leetcode-46-全排列medium"><a class="markdownIt-Anchor" href="#leetcode-46-全排列medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations">Leetcode 46. 全排列(Medium)</a></h2>
<blockquote>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
</blockquote>
<h3 id="递归-3"><a class="markdownIt-Anchor" href="#递归-3"></a> 递归</h3>
<p>我想到的解法是用递归。大循环遍历数组中的每个数作为我们选定的数，然后先获取除了我们选定的这个数以外的所有数的全排列，然后将我们选定的这个数作为所有我们得到的排列的最后一个数。这样我们就获得了以我们选定的数为结尾的全排列。因此当我们的大循环遍历完所有的数后，就得到了整体的全排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_list</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">permute</span>(nums_list);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(list&lt;<span class="hljs-type">int</span>&gt; &amp;nums_list)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums_list.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, nums_list.<span class="hljs-built_in">front</span>()));<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums_list.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> front = nums_list.<span class="hljs-built_in">front</span>();<br>            nums_list.<span class="hljs-built_in">pop_front</span>();<br><br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sub_permute = <span class="hljs-built_in">permute</span>(nums_list);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : sub_permute) &#123;<br>                it.<span class="hljs-built_in">push_back</span>(front);<br>                result.<span class="hljs-built_in">push_back</span>(it);<br>            &#125;<br><br>            nums_list.<span class="hljs-built_in">push_back</span>(front);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>为什么我要用个list来复制nums数组呢？因为我要获取我选定的数以外的数的全排列的时候，需要先将该数拿出去，获取完选下一个数之前再拿回来。用list方便从头尾部插入删除元素。</p>
<p>也可以用原先的vector，将选定的数先swap到vector的末尾，放回去的时候再swap回原来的位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">1</span>, nums);<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(nums[n - <span class="hljs-number">1</span>], nums[i]);<br>            <span class="hljs-type">int</span> back = nums.<span class="hljs-built_in">back</span>();<br>            nums.<span class="hljs-built_in">pop_back</span>();<br><br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sub_permute = <span class="hljs-built_in">permute</span>(nums);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : sub_permute) &#123;<br>                it.<span class="hljs-built_in">push_back</span>(back);<br>                result.<span class="hljs-built_in">push_back</span>(it);<br>            &#125;<br><br>            nums.<span class="hljs-built_in">push_back</span>(back);<br>            <span class="hljs-built_in">swap</span>(nums[n - <span class="hljs-number">1</span>], nums[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h3>
<p>这题用回溯法的思路会稍微复杂一点，我们可以想象有 n 个排列成一行的空格。我们需要从左往右依此填入题目给定的 n个数，每个数只能使用一次。每次backtracking就是往<code>begin</code>位置填入一个数，[0, begin - 1]的位置已经填好数了，然后在<code>begin + 1</code>位置继续调用backtracking。当最后<code>begin = n</code>的时候说明整个一行都填完了，这就得到了其中一个排列，加入到最后的<code>result</code>里面。</p>
<p>事实上我们不需要单独创建一个数组来作为填入的一行，也不需要标记原数组中哪些元素已填入了这一行中，可以直接在原数组上进行操作。每次调用backtracking往<code>begin</code>位置填入时，将要填入的数与<code>begin</code>位置的数交换，然后再从<code>begin + 1</code>处填下一个数。这样的话，每次调用backtracking往<code>begin</code>位置填入时，原数组的[0, begin - 1]就是已经填入的数，寻找要填入的数时在[begin, n)位置寻找就可以了。</p>
<p>要注意，每次回溯后需要撤销处理结果，也就是将填入的数再与原先begin位置的数交换回来，然后继续寻找下一个要在<code>begin</code>位置填入的数。</p>
<p>回顾一下回溯法的代码框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">void backtracking(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>本题代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">backtracking</span>(result, nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (begin == len) &#123;<br>            result.<span class="hljs-built_in">emplace_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = begin; i &lt; len; ++i) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[begin], nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(result, nums, begin + <span class="hljs-number">1</span>, len);<br>            <span class="hljs-built_in">swap</span>(nums[begin], nums[i]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度分析-4"><a class="markdownIt-Anchor" href="#复杂度分析-4"></a> 复杂度分析</h3>
<p>上面递归和回溯算法的时间复杂度都是<code>O(N * N!)</code></p>
<p>回溯法的空间复杂度只与递归深度有关，递归深度为N，因此空间复杂度是O(N)；</p>
<p>递归法的递归深度也是N，但是每层递归都需要创建一个临时数组来存储子问题的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sub_permute = <span class="hljs-built_in">permute</span>(nums);<br></code></pre></td></tr></table></figure>
<p>这个临时数组有多大呢？当处理长度为n的数组时，<code>sub_permute</code>会存储(n-1)!个排列，每个排列有(n-1)个元素，因此这个临时数组占用空间为O((n-1) × (n-1)!) = O(n × (n-1)!) = O(n!)</p>
<p>因此这个递归法的空间复杂度是<code>O(n!)</code></p>
<h2 id="leetcode-121-买卖股票的最佳时机easy"><a class="markdownIt-Anchor" href="#leetcode-121-买卖股票的最佳时机easy"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">Leetcode 121. 买卖股票的最佳时机(Easy)</a></h2>
<blockquote>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
</blockquote>
<h3 id="naive-solution"><a class="markdownIt-Anchor" href="#naive-solution"></a> Naive Solution</h3>
<p>外层大循环遍历股票买入日期，内层循环遍历股票卖出日期，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// O(N^2)时间复杂度</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>            <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-type">int</span> max_profit = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; prices.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (prices[j] - prices[i] &gt; max_profit) &#123;<br>                        max_profit = prices[j] - prices[i];<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (max_profit &gt; result) &#123;<br>                    result = max_profit;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure>
<h3 id="动态规划-3"><a class="markdownIt-Anchor" href="#动态规划-3"></a> 动态规划</h3>
<p>这题是经典的动态规划例题，能够将Naive算法的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>时间复杂度降到<code>O(N)</code>。</p>
<p>动态规划的思想是当前位置的状态可以由前一个位置的状态通过递归算式推导出。可以这样想，如果我们将股票第<code>i</code>天卖出可以获取到的最大利润定义为<code>f(i)</code>，那么第<code>i + 1</code>天可以获取到的最大利润<code>f(i + 1)</code>就可以这样表示：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>+</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i + 1) = max(f(i) + prices[i] - prices[i - 1], 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>​</p>
<p>上面这就是本题动态规划的<strong>状态转移方程（递推公式）</strong></p>
<p>那么最后要求的买卖股票最大利润就是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><msub><mi mathvariant="normal">∣</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mtext>  </mtext><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f(i)|_{max} \ \ 0&lt;=i&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p>
<p>因此我们的实现只需要遍历一次数组，每遍历到一个日期，求以该日期为卖出日期能够获取到的最大利润。我用了一个<code>pre_max_profit</code>变量保存以该日期的前一个日期为卖出日期能获取到的最大利润，这样就能根据上面的递推公式求出当前的状态，并更新<code>pre_max_profit</code>，然后遍历到下一个日期。再用一个全局变量<code>max_profit</code>保存全局的最大利润。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>            <span class="hljs-type">int</span> max_profit = <span class="hljs-number">0</span>; <br><br>            <span class="hljs-type">int</span> pre_max_profit = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                pre_max_profit = <span class="hljs-built_in">max</span>(prices[i] - prices[i - <span class="hljs-number">1</span>] + pre_max_profit, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (pre_max_profit &gt; max_profit) &#123;<br>                    max_profit = pre_max_profit;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> max_profit;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure>
<p>如前所述，用动态规划解本题的时间复杂度是<code>O(N)</code>，并且只需要创建常数个变量，空间复杂度是<code>O(1)</code>。</p>
<h1 id="day937"><a class="markdownIt-Anchor" href="#day937"></a> Day9(3.7)</h1>
<h2 id="leetcode-88-合并两个有序数组easy"><a class="markdownIt-Anchor" href="#leetcode-88-合并两个有序数组easy"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array">Leetcode 88. 合并两个有序数组(Easy)</a></h2>
<blockquote>
<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p>**注意：**最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,0,0,0]</span>, m = 3, nums2 = <span class="hljs-comment">[2,5,6]</span>, n = 3<br>输出：<span class="hljs-comment">[1,2,2,3,5,6]</span><br>解释：需要合并 <span class="hljs-comment">[1,2,3]</span> 和 <span class="hljs-comment">[2,5,6]</span> 。<br>合并结果是 <span class="hljs-comment">[1,2,2,3,5,6]</span> ，其中斜体加粗标注的为 nums1 中的元素。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1]</span>, m = 1, nums2 = <span class="hljs-comment">[]</span>, n = 0<br>输出：<span class="hljs-comment">[1]</span><br>解释：需要合并 <span class="hljs-comment">[1]</span> 和 <span class="hljs-comment">[]</span> 。<br>合并结果是 <span class="hljs-comment">[1]</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[0]</span>, m = 0, nums2 = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br>解释：需要合并的数组是 <span class="hljs-comment">[]</span> 和 <span class="hljs-comment">[1]</span> 。<br>合并结果是 <span class="hljs-comment">[1]</span> 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m + n</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m, n &lt;= 200</code></li>
<li><code>1 &lt;= m + n &lt;= 200</code></li>
<li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li>
</ul>
<p>**进阶：**你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p>
</blockquote>
<h3 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h3>
<p>合并两个有序排列问题，就是用<strong>双指针</strong>来解决。</p>
<p>本题的特殊点在于需要将合并的数组存在<code>nums1</code>中，而不是单开一个空的数组向里面填。可以注意到<code>nums1</code>中后面n个数都是0，也就是待填入的数。因此我们可以从后往前遍历<code>nums1</code>和<code>nums2</code>，将较大的数从<code>nums1</code>的后面往前面写。</p>
<p>如果退出循环的时候是<code>nums2</code>遍历完了，说明<code>nums2</code>中的数已经都插入到<code>nums1</code>中了，可以直接退出；如果是<code>nums1</code>遍历完了，那说明<code>nums1</code>中的数都放到了正确的位置，接下来只要把<code>nums2</code>中剩余的数平移到<code>nums1</code>中就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums2, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> p1 = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p2 = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> p = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p1 &gt;= <span class="hljs-number">0</span> &amp;&amp; p2 &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;<br>                nums1[p] = nums2[p2];<br>                p2--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums1[p] = nums1[p1];<br>                p1--;<br>            &#125;<br>            p--;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p2; p2 &gt;= <span class="hljs-number">0</span>; --p2) &#123;<br>                nums1[p2] = nums2[p2];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>很显然，时间复杂度是<code>O(M + N)</code>，空间复杂度是<code>O(1)</code></p>
<h2 id="leetcode-20-有效的括号easy"><a class="markdownIt-Anchor" href="#leetcode-20-有效的括号easy"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses">Leetcode 20. 有效的括号(Easy)</a></h2>
<blockquote>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>**输入：**s = &quot;()&quot;</p>
<p>**输出：**true</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>**输入：**s = &quot;()[]{}&quot;</p>
<p>**输出：**true</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>**输入：**s = &quot;(]&quot;</p>
<p>**输出：**false</p>
</blockquote>
<p><strong>示例 4：</strong></p>
<blockquote>
<p>**输入：**s = &quot;([])&quot;</p>
<p>**输出：**true</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>'()[]&#123;&#125;'</code> 组成</li>
</ul>
</blockquote>
<h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3>
<p>本题的关键点在于**“左括号必须以正确的顺序闭合”**，也就是说&quot;( [ ) ]&quot;的顺序是错误的。</p>
<p>本题是运用<strong>栈</strong>的经典例题。当我们遇到左括号，就压入栈中；如果遇到右括号，检查当前栈顶是不是相对应的左括号，如果是那么将栈顶元素出栈，如果不是说明出错。</p>
<p>如果遍历到最后还没出错，并且栈最后为空，说明这是一个有效的字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>            stack&lt;<span class="hljs-type">char</span>&gt; brackets;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                    brackets.<span class="hljs-built_in">push</span>(c);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (brackets.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> ((c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; brackets.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span>) || (c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; brackets.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>) || c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; brackets.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                        brackets.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> (brackets.<span class="hljs-built_in">empty</span>()) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure>
<p>很显然，时间复杂度是<code>O(N)</code>；空间复杂度是<code>O(N)</code>，因为最坏情况下所有元素都是左括号都压入栈中。</p>
<h1 id="day1038"><a class="markdownIt-Anchor" href="#day1038"></a> Day10(3.8)</h1>
<h2 id="leetcode-103-二叉树的锯齿形层次遍历medium"><a class="markdownIt-Anchor" href="#leetcode-103-二叉树的锯齿形层次遍历medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal">Leetcode 103. 二叉树的锯齿形层次遍历(Medium)</a></h2>
<blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/tree1-1741417327569-3-1741450172381-1.jpg" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[20,9]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</blockquote>
<h3 id="栈-2"><a class="markdownIt-Anchor" href="#栈-2"></a> 栈</h3>
<p>都说层次遍历/BFS要用队列写，诶我偏用栈写一次（事实证明确实麻烦了）</p>
<p>如果用栈的话，每次都要为下一层单独开一个stack，遍历当前层的stack的时候，将下一层的元素压入下一层的stack中。然后在遍历完当前层的stack后，将下一层的stack赋值给当前层的stack，开始遍历下一层。</p>
<p>用栈的好处是：我们从栈中遍历的顺序就是锯齿形的顺序。每次从栈顶取到的元素直接放入结果的数组中就可以了，只要交替变换每层之间左右孩子被压入栈中的顺序就行了。而下面用队列的方法其实并不会改变普通层次遍历的遍历顺序，只是放入结果的位置改变了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-type">bool</span> left_first = <span class="hljs-literal">true</span>;<br><br>        stack&lt;TreeNode*&gt; cur_stack;<br>        stack&lt;TreeNode*&gt; next_stack;<br>        <span class="hljs-keyword">if</span> (root) cur_stack.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; cur_level;<br>        <span class="hljs-keyword">while</span> (!cur_stack.<span class="hljs-built_in">empty</span>() || !next_stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* cur = cur_stack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (left_first) &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) next_stack.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) next_stack.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) next_stack.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) next_stack.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            &#125;<br>            cur_stack.<span class="hljs-built_in">pop</span>();<br>            cur_level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur_stack.<span class="hljs-built_in">empty</span>()) &#123;<br>                cur_stack = next_stack;<br>                next_stack = std::<span class="hljs-built_in">move</span>(<span class="hljs-built_in">stack</span>&lt;TreeNode*&gt;());<br>                result.<span class="hljs-built_in">push_back</span>(cur_level);<br>                cur_level.<span class="hljs-built_in">clear</span>();<br>                left_first = !left_first;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="队列双端队列"><a class="markdownIt-Anchor" href="#队列双端队列"></a> 队列+双端队列</h3>
<p>当然，层次遍历还是用队列最方便。但是此题需要返回锯齿形的遍历顺序，那么我们就不能按每层中遍历到的元素顺序直接返回。具体来说，奇数层需要返回从右到左的元素顺序。但我们从队列中遍历的顺序是从左到右的呀，那怎么办呢？很简单，对奇数层来说，从左到右每从queue中遍历到一个元素，就将其插入到我们选定的容器的开头(front)，这样一层遍历完之后容器开头就是最右侧的元素了。而对于偶数层来说，从左到右每从queue中遍历到一个元素，就将其插入到我们选定的容器的末尾(back)。</p>
<p>那么问题就来了，什么容器可以既方便从开头插入元素，又方便从末尾插入元素？没错，就是双端队列(deque)！将每层的遍历结果都用deque来存储，然后赋值给vector加入结果中就可以了！</p>
<p>这个方法的好处就是我们不需要修改普通二叉树的层次遍历逻辑，只要修改存储遍历结果的方式就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode *root)<br>    &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-type">bool</span> left_first = <span class="hljs-literal">true</span>;<br><br>        queue&lt;TreeNode *&gt; que;<br>        <span class="hljs-keyword">if</span> (root)<br>            que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            deque&lt;<span class="hljs-type">int</span>&gt; deq;<br><br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>            &#123;<br>                TreeNode *cur = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (cur-&gt;left)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br><br>                <span class="hljs-keyword">if</span> (left_first) &#123;<br>                    deq.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    deq.<span class="hljs-built_in">push_front</span>(cur-&gt;val);<br>                &#125;<br>            &#125;<br><br>            result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;deq.<span class="hljs-built_in">begin</span>(), deq.<span class="hljs-built_in">end</span>()&#125;);<br>            left_first = !left_first;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度分析-5"><a class="markdownIt-Anchor" href="#复杂度分析-5"></a> 复杂度分析</h3>
<p>BFS的时间复杂度就是<code>O(N)</code>，每个元素只需要遍历一次。空间复杂度是<code>O(N)</code>，因为无论是用栈还是队列，最坏情况下都需要存储N个元素，并且还需要一个容器来存储每层的结果。</p>
<h2 id="leetcode-236-二叉树的最近公共祖先medium"><a class="markdownIt-Anchor" href="#leetcode-236-二叉树的最近公共祖先medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">Leetcode 236. 二叉树的最近公共祖先(Medium)</a></h2>
<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/binarytree-1741450172382-2.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/imgs/binarytree-1741450172382-2.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">5</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span> 。因为根据定义最近公共祖先节点可以为节点本身。<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[1,2]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[2, 105]</code> 内。</li>
<li><code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>
<li><code>p != q</code></li>
<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
</blockquote>
<h3 id="递归-4"><a class="markdownIt-Anchor" href="#递归-4"></a> 递归</h3>
<p>这题都知道要用递归来写，但是要想清楚思路还是有些难度。只要能够想清楚递归的思路，代码写起来是很简单的！</p>
<p>我们可以这样想，如果我们要找的p和q分别在当前节点的左右子树，那么当前节点就是p和q的最近共同祖先。如果p和q都在其中一个（左或右）子树，那么这棵子树的根节点，（也就是root的左或右节点），就是离p和q更近的共同祖先。接下来就在这棵子树中寻找最近的共同祖先。</p>
<p>因此我们递归的返回条件是什么呢？<strong>只要我们找到p或q节点，就直接返回</strong>。因为我们每次递归调用的时候，root节点都是p和q的共同祖先。而一旦root节点是p或者q，那么很显然root就一定会是p和q的共同祖先。</p>
<p>那怎么判断当前递归调用时的root节点是否是p和q最近的共同祖先呢？结合递归的返回条件，我们可以分别递归调用左子树和右子树。如果在左子树中找到了p或q节点，又在右子树中找到了p或q节点，那么说明p和q节点分别在root的左右子树，显然root就是p和q的最近祖先。而如果只在其中一侧找到了p或q节点，说明p和q节点都在这棵子树上，那么就返回这一侧的递归结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-comment">// 只要找到p和q的其中一个，就返回</span><br>        <span class="hljs-keyword">if</span> (!root || root == p || root == q) <span class="hljs-keyword">return</span> root;<br><br>        TreeNode* l = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* r = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-keyword">if</span> (l &amp;&amp; r) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (l) <span class="hljs-keyword">return</span> l;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度分析-6"><a class="markdownIt-Anchor" href="#复杂度分析-6"></a> 复杂度分析</h3>
<p>二叉树的每个节点都只会访问一次，时间复杂度是<code>O(N)</code>；</p>
<p>空间复杂度取决于递归调用的深度，而递归调用的深度取决于二叉树的高度。最坏情况下二叉树会退化成链表，高度为N。因此空间复杂度是<code>O(N)</code></p>
<h1 id="day1139"><a class="markdownIt-Anchor" href="#day1139"></a> Day11(3.9)</h1>
<h2 id="leetcode-141-环形链表easy"><a class="markdownIt-Anchor" href="#leetcode-141-环形链表easy"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle">Leetcode 141. 环形链表(Easy)</a></h2>
<blockquote>
<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/circularlinkedlist-1741513173102-1.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/imgs/circularlinkedlist_test2-1741513173102-3.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="/imgs/circularlinkedlist_test3-1741513173102-2.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p>**进阶：**你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
</blockquote>
<h3 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h3>
<p>最容易想到的是用哈希表存储我们访问过的节点。每遍历到一个节点，先检查该节点是否在哈希表中，如果是说明是环形链表。遍历到最后都没找到重复遍历过的节点，说明不是环形链表。</p>
<p>代码很容易，这里就不写了。这个算法的空间复杂度是<code>O(N)</code>，有没有一种<code>O(1)</code>的空间复杂度的算法解此题呢？</p>
<h3 id="双指针快慢指针"><a class="markdownIt-Anchor" href="#双指针快慢指针"></a> 双指针（快慢指针）</h3>
<p>这题可以用双指针的一个trick：<strong>快慢指针</strong>。我们通常使用双指针都是两个指针每次移动一格，速度一样。这题在我们判断环形链表的时候，可以使用一慢一快两个指针：慢指针一次移动一格，快指针一次移动两格。那么如果链表不是环形的，快指针应该会一直在慢指针的前方。而如果是环形链表，那么两个指针走着走着一定会重合。可以想象龟兔赛跑的场景：乌龟和兔子在链表上移动，兔子跑得快，如果链表是环形的，那么就会套圈，与乌龟相遇。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            TreeNode* one_step = head;<br>            TreeNode* two_step = head-&gt;next;<br><br>            <span class="hljs-keyword">while</span> (one_step &amp;&amp; two_step) &#123;<br>                <span class="hljs-keyword">if</span> (one_step == two_step) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                one_step = one_step-&gt;next;<br>                <span class="hljs-keyword">if</span> (!two_step-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                two_step = two_step-&gt;next-&gt;next;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure>
<h2 id="leetcode-92-反转链表-iimedium"><a class="markdownIt-Anchor" href="#leetcode-92-反转链表-iimedium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii">Leetcode 92. 反转链表 II(Medium)</a></h2>
<blockquote>
<p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/rev2ex2-1741513173102-4.jpg" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span><br>输出：<span class="hljs-selector-attr">[5]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目为 <code>n</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-500 &lt;= Node.val &lt;= 500</code></li>
<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>
</ul>
<p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p>
</blockquote>
<p>此题难度并不大，就是翻转链表的变型。比普通的翻转一整个链表要多做的事情就是将[left, right]的子链表翻转后接回原本的链表，那就需要一个变量<code>pre_last</code>保存子链表的前一个节点，还需要一个<code>cur_first</code>指向翻转后的子链表的最后一个节点（这样就可以在翻转子链表的循环结束后将翻转后的子链表的最后一个节点的next指向原本子链表的后一个节点，也就是接回原链表）。翻转链表就是常规的套路：用一个<code>pre</code>节点保存遍历到的前一个节点，将当前节点指向<code>pre</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>            ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>            head = dummy;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; left; ++i) &#123;<br>                head = head-&gt;next;<br>            &#125;<br>            ListNode* pre_last = head; <span class="hljs-comment">// 将要翻转的第一个节点的前一个节点</span><br>            head = head-&gt;next;<br>            ListNode* cur_first = head; <span class="hljs-comment">// 将要翻转的第一个节点，也是翻转后的子链表的最后一个节点</span><br><br>            ListNode* pre = pre_last;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= right - left; ++i) &#123;<br>                ListNode* next = head-&gt;next;<br>                head-&gt;next = pre;<br>                pre = head;<br>                head = next;<br>            &#125;<br>            <span class="hljs-comment">// 循环结束后，pre指向翻转后的子链表的第一个节点，head指向翻转的子链表的后面一个节点</span><br>            pre_last-&gt;next = pre;<br>            cur_first-&gt;next = head;<br><br>            <span class="hljs-keyword">return</span> dummy-&gt;next;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure>
<p>这样就可以保证只需要扫描一次就完成翻转，时间复杂度是<code>O(N)</code>；并且只需要常数个变量，空间复杂度是<code>O(1)</code>。</p>
<h1 id="day12310"><a class="markdownIt-Anchor" href="#day12310"></a> Day12(3.10)</h1>
<h2 id="leetcode-23-合并k个排序链表hard"><a class="markdownIt-Anchor" href="#leetcode-23-合并k个排序链表hard"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists">Leetcode 23. 合并K个排序链表(Hard)</a></h2>
<blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br><span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>k == lists.length</code></li>
<li><code>0 &lt;= k &lt;= 10^4</code></li>
<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>
<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>
<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>
</ul>
</blockquote>
<h3 id="优先级队列"><a class="markdownIt-Anchor" href="#优先级队列"></a> 优先级队列</h3>
<p>这题可以使用优先级队列进行合并。先将每个链表的头节点放入<strong>最小堆</strong>中，然后每次从堆顶取出一个节点（这个节点就是当前所有链表中的最小值，接入结果链表中），然后将这个节点所在链表的next节点放入堆中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *tail = dummy;<br><br>        <span class="hljs-comment">// 将每个链表的头节点放入堆中</span><br>        <span class="hljs-keyword">for</span> (ListNode* node : lists)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (node) minHeap.<span class="hljs-built_in">push</span>(node);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!minHeap.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            ListNode *smallest_node = minHeap.<span class="hljs-built_in">top</span>();<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (smallest_node-&gt;next) minHeap.<span class="hljs-built_in">push</span>(smallest_node-&gt;next);<br><br>            tail-&gt;next = smallest_node;<br>            tail = tail-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 自定义比较器</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CompareListNode</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode *a, ListNode *b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;   <span class="hljs-comment">// 最小堆中，大的元素放小的元素下方</span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 创建最小堆</span><br>    priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, CompareListNode&gt; minHeap;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>堆中的元素是每个链表当前需要比较的最小值，因此最多有K个，空间复杂度是<code>O(K)</code>；</p>
<p>堆的插入和删除操作时间复杂度都是<code>O(logK)</code>，K个链表中的每个元素都需要插入和删除各一次，因此总时间复杂度是<code>O(N * K * logK)</code></p>
<h3 id="分治合并"><a class="markdownIt-Anchor" href="#分治合并"></a> 分治合并</h3>
<p>这题也可以用分治的思想进行合并，可以这样思考递归的思路：合并K个链表，就是先将前K/2个链表合并，再将后K/2个链表合并，然后将合并后的这两个链表合并。递归的结束条件是当前要合并的链表数量只有一个，那么直接返回当前链表。</p>
<p>而合并两个链表的实现很简单，在Day5中已经做过了，就是用双指针。</p>
<p>如下图：第一轮两两合并，第二轮再将第一轮合并后的链表两两合并，直到最后两个链表合并得到最终的合并链表。</p>
<p><img src="/imgs/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image-1741598703839-1.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 分治合并</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (lists.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将第l个链表到第r个链表合并成一个链表</span><br>    <span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;ListNode *&gt; &amp;lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> lists[l];<br><br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(<span class="hljs-built_in">merge</span>(lists, l, mid), <span class="hljs-built_in">merge</span>(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* tail = dummy;<br><br>        ListNode* p1 = list1;<br>        ListNode* p2 = list2;<br>        <span class="hljs-keyword">while</span> (p1 &amp;&amp; p2) &#123;<br>            <span class="hljs-keyword">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;<br>                tail-&gt;next = p1;<br>                p1 = p1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = p2;<br>                p2 = p2-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!p1) tail-&gt;next = p2;<br>        <span class="hljs-keyword">if</span> (!p2) tail-&gt;next = p1;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>分治合并的递归深度是<code>log(K)</code>，空间复杂度就是消耗的栈空间<code>O(logK)</code>；</p>
<p>时间复杂度需要好好计算以下，我们考虑递归<strong>向上回升</strong>的过程。第一轮是两两合并链表，共合并<code>K/2</code>组链表，合并每组的时间复杂度是<code>O(2N)</code>；第二层共合并<code>K/4</code>组链表，合并每组的时间复杂度是<code>O(4N)</code>...，而递归的层数是<code>log(K)</code>，因此总时间复杂度是<code>O(N * K * logK)</code></p>
<h2 id="leetcode-54-螺旋矩阵medium"><a class="markdownIt-Anchor" href="#leetcode-54-螺旋矩阵medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix">Leetcode 54. 螺旋矩阵(Medium)</a></h2>
<blockquote>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/spiral1-1741598703840-2.jpg" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/imgs/spiral-1741598703840-3.jpg" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
</blockquote>
<h3 id="模拟"><a class="markdownIt-Anchor" href="#模拟"></a> 模拟</h3>
<p>本题就是模拟螺旋数组访问的路径，分别用4个变量维护四个方向的boundry：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> rows = matrix.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> cols = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br><span class="hljs-type">int</span> upper_boundry = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> lower_boundry = rows - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> left_boundry = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right_boundry = cols - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>用一个大循环表示路径访问了一圈，大循环中四个小循环分别表示四个路径访问方向。保证访问的路径始终落在boundry范围里面。每访问完一行或一列，更新boundry。如果更新后的boundry越界，说明整个数组访问结束，退出大循环。</p>
<p>完整代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;matrix)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-type">int</span> rows = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> upper_boundry = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lower_boundry = rows - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left_boundry = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right_boundry = cols - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (; j &lt;= right_boundry; ++j)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>            &#125;<br>            j = right_boundry;<br>            i = upper_boundry + <span class="hljs-number">1</span>;<br>            upper_boundry++;<br>            <span class="hljs-keyword">if</span> (upper_boundry &gt; lower_boundry) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (; i &lt;= lower_boundry; ++i)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>            &#125;<br>            i = lower_boundry;<br>            j = right_boundry - <span class="hljs-number">1</span>;<br>            right_boundry--;<br>            <span class="hljs-keyword">if</span> (right_boundry &lt; left_boundry) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (; j &gt;= left_boundry; --j)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>            &#125;<br>            j = left_boundry;<br>            i = lower_boundry - <span class="hljs-number">1</span>;<br>            lower_boundry--;<br>            <span class="hljs-keyword">if</span> (upper_boundry &gt; lower_boundry) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">for</span> (; i &gt;= upper_boundry; --i)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>            &#125;<br>            i = upper_boundry;<br>            j = left_boundry + <span class="hljs-number">1</span>;<br>            left_boundry++;<br>            <span class="hljs-keyword">if</span> (right_boundry &lt; left_boundry) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>除了结果数组，只需要创建常数个变量维护boundry，空间复杂度是<code>O(1)</code>；</p>
<p>矩阵中每个元素被访问一次，时间复杂度是<code>O(mn)</code>，其中m和n分别是矩阵的行数和列数。</p>
<h1 id="day13311"><a class="markdownIt-Anchor" href="#day13311"></a> Day13(3.11)</h1>
<h2 id="leetcode-300-最长上升子序列medium"><a class="markdownIt-Anchor" href="#leetcode-300-最长上升子序列medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence">Leetcode 300. 最长上升子序列(Medium)</a></h2>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>
</ul>
</blockquote>
<h3 id="动态规划-4"><a class="markdownIt-Anchor" href="#动态规划-4"></a> 动态规划</h3>
<p>这题的关键难点在于搞清楚<code>dp</code>数组究竟应该存储什么状态。可以这样想：一个数组我们求解出的最长递增子序列一定有一个末尾元素（虽然是废话），因此我们可以求出以每个元素作为末尾元素的最长递增子序列的长度。最后看谁最长，就是整个数组的最长递增子序列长度。</p>
<p>我们用<code>dp</code>数组保存以每个元素作为末尾元素的最长递增子序列的长度，<code>dp[i]</code>表示以数组中第<code>i</code>个元素作为末尾元素的最长递增子序列长度。那怎么求<code>dp[i]</code>呢？根据动态规划的状态转移特性，我们求<code>dp[i]</code>的时候已经求得了<code>dp[0...i−1]</code>的值，因此状态方程可以写为：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mtext>，其中</mtext><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi><mtext>且</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[j]) + 1，其中0 &lt;= j &lt; i且nums[j] &lt; nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>​</p>
<p>也就是找在以 当前元素前面的元素 为末尾的最长递增子序列中能接上当前元素的子序列中最大的子序列。</p>
<p>最后的结果就是<code>dp</code>数组中的最大值。</p>
<p>可以看到，本题的动态规划求解当前状态时，不仅仅需要前一个位置的状态，而是要遍历前面所有位置的状态，因此必须要用<code>dp</code>数组来保存所有位置的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j] &gt; max &amp;&amp; nums[j] &lt; nums[i]) max = dp[j];<br>            &#125;<br>            dp[i] = max + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> max_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; max_length) max_length = dp[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_length;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>本题动态规划的空间复杂度是<code>O(N)</code>，因为需要一个一维的<code>dp</code>数组；</p>
<p>时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为求解每个位置的状态时，需要遍历前面所有位置的状态。</p>
<h2 id="leetcode-415-字符串相加easy"><a class="markdownIt-Anchor" href="#leetcode-415-字符串相加easy"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings">Leetcode 415. 字符串相加(Easy)</a></h2>
<blockquote>
<p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;123&quot;</span><br>输出：<span class="hljs-string">&quot;134&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;456&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;77&quot;</span><br>输出：<span class="hljs-string">&quot;533&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-string">&quot;0&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1.length, num2.length &lt;= 104</code></li>
<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li>
<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>
</ul>
</blockquote>
<h3 id="模拟-2"><a class="markdownIt-Anchor" href="#模拟-2"></a> 模拟</h3>
<p>本题其实就是模拟<strong>竖式加法</strong>的过程。从两个字符串的最后一个数（整数的个位数）开始加起，如果进位设置<code>of</code>加到下一位中。这里我用了一个trick：向较短的字符串前面补上0，让两个字符串一样长，方便循环做加法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length1 = num1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> length2 = num2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> length = <span class="hljs-built_in">max</span>(length1, length2);<br><br>        <span class="hljs-type">int</span> zeros;<br>        <span class="hljs-keyword">if</span> (length1 &gt; length2) &#123;<br>            zeros = length1 - length2;<br>            num2 = <span class="hljs-built_in">string</span>(zeros, <span class="hljs-string">&#x27;0&#x27;</span>) + num2;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            zeros = length2 - length1;<br>            num1 = <span class="hljs-built_in">string</span>(zeros, <span class="hljs-string">&#x27;0&#x27;</span>) + num1;<br>        &#125;<br><br>        string result;<br>        <span class="hljs-type">int</span> of = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 是否有overflow</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">int</span> sum = (num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + (num2[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + of;<br>            <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">9</span>) &#123;<br>                sum -= <span class="hljs-number">10</span>;<br>                of = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                of = <span class="hljs-number">0</span>;<br>            &#125;<br>            result = (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;0&#x27;</span> + sum) + result;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (of) result = <span class="hljs-string">&#x27;1&#x27;</span> + result;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这个算法的时间复杂度是<code>O(max&#123;len1, len2&#125;)</code>；</p>
<p>空间复杂度是<code>O(n)</code>，因为我通过向较短的字符串前面添加'0'字符使两个字符串长度相等，这会创建新的string对象，最坏情况下会需要<code>O(n)</code>的额外空间（当一个字符串远长于另一个时）。</p>
<h1 id="day14312"><a class="markdownIt-Anchor" href="#day14312"></a> Day14(3.12)</h1>
<h2 id="leetcode-160-相交链表easy"><a class="markdownIt-Anchor" href="#leetcode-160-相交链表easy"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists">Leetcode 160. 相交链表(Easy)</a></h2>
<blockquote>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交：</p>
<p><img src="/imgs/160_statement-1741768368110-3.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/160_example_1_1-1741768368110-2.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br>— 请注意相交节点的值不为 <span class="hljs-number">1</span>，因为在链表 <span class="hljs-keyword">A</span> 和链表 B 之中值为 <span class="hljs-number">1</span> 的节点 (<span class="hljs-keyword">A</span> 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <span class="hljs-keyword">A</span> 和链表 B 中值为 <span class="hljs-number">8</span> 的节点 (<span class="hljs-keyword">A</span> 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/imgs/160_example_2-1741768368110-1.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。  <br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="/imgs/160_example_3-1741768368110-4.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：No <span class="hljs-built_in">int</span>ersection<br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p>**进阶：**你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
</blockquote>
<h3 id="哈希集合"><a class="markdownIt-Anchor" href="#哈希集合"></a> 哈希集合</h3>
<p>用哈希集合解这题就很简单，先遍历一遍A链表，将遍历过的节点存在哈希集合里。再遍历B链表，每遍历到一个节点先检查是否在哈希集中，如果是则返回该节点。最后如果遍历完B链表了说明与A链表无相交。代码省略。</p>
<p>该算法的空间复杂度是<code>O(N)</code>，有没有<code>O(1)</code>空间复杂度的算法呢？答案就是双指针！</p>
<h3 id="双指针-2"><a class="markdownIt-Anchor" href="#双指针-2"></a> 双指针</h3>
<p>这题与其说是双指针的套路题，不如说是一道脑筋急转弯，因为就算告诉你这题用双指针你也不会做。</p>
<p>这题的关键点在于怎么让两个指针<code>pA</code>和<code>pB</code>同时走到第一个相交的节点？要知道A链表和B链表在他们相交前各自的长度是未知的。这里就是核心的trick了：我们让<code>pA</code>和<code>pB</code>以相同的速度先在各自的链表上同步走，然后<strong>让<code>pA</code>走完A链表后继续从B链表的开头开始走起，让<code>pB</code>走完B链表后继续从A链表的开头开始走起。</strong></p>
<p>想明白了吗？没想明白的话，建议自己画图模拟一下。这样<code>pA</code>和<code>pB</code>在走完自己的路，又走完对方走过的路后，一定会同时到达两个链表第一次相交的节点。而如果两个链表不相交，那<code>pA</code>和<code>pB</code>在走完自己和对方的路后会同时抵达终点<code>NULL</code>。</p>
<img src="/imgs/2b1d9a2937b3d27709359bda0a4c378-1741768368110-6.jpg" srcset="/img/loading.gif" lazyload alt = "蓝色是pA的路线，红色是pB的路线" style="zoom: 40%;" />
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!headA || !headB)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        ListNode *pA = headA;<br>        ListNode *pB = headB;<br><br>        <span class="hljs-keyword">while</span> (pA || pB)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (pA == pB) <span class="hljs-keyword">return</span> pA;<br>        <br>            pA = (!pA) ? headB : pA-&gt;next;<br>            pB = (!pB) ? headA : pB-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>显然这个算法的时间复杂度是<code>O(M + N)</code>，空间复杂度是<code>O(1)</code></p>
<p>最后放一个leetcode评论区神评：</p>
<img src="/imgs/image-20250312152905663-1741768368110-7.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />
<p>你悟了吗？</p>
<h2 id="leetcode-143-重排链表medium"><a class="markdownIt-Anchor" href="#leetcode-143-重排链表medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list">Leetcode 143. 重排链表(Medium)</a></h2>
<blockquote>
<p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-symbol">L1</span> → … → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-built_in">Ln</span><br></code></pre></td></tr></table></figure>
<p>请将其重新排列后变为：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-built_in">Ln</span> → <span class="hljs-symbol">L1</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-symbol">L2</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">2</span> → …<br></code></pre></td></tr></table></figure>
<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/1626420311-PkUiGI-image-1741768368110-5.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">1,4,2,3</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/imgs/1626420320-YUiulT-image-1741768368110-8.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[1,5,2,4,3]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表的长度范围为 <code>[1, 5 * 104]</code></li>
<li><code>1 &lt;= node.val &lt;= 1000</code></li>
</ul>
</blockquote>
<h3 id="双端队列"><a class="markdownIt-Anchor" href="#双端队列"></a> 双端队列</h3>
<p>这题一看，先要从链表末尾拿一个元素，再从链表开头拿一个元素，……，而链表本身不支持随机访问。因此很容易想到可以用一个支持<strong>随机访问/快速访问和删除首尾元素</strong>的容器来装链表。Leetcode官方题解选的是前者，用<code>vector</code>。</p>
<p>我选择的是后者，用一个双端队列。先将链表装到双端队列里面。每次取节点要么取<code>deque</code>的最后一个元素，要么取第一个元素，每次取完将该元素从<code>deque</code>中删除，以上操作都是<code>O(1)</code>的时间复杂度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span>;<br><br>        deque&lt;ListNode *&gt; list;<br><br>        ListNode *p = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (p)<br>        &#123;<br>            list.<span class="hljs-built_in">push_back</span>(p);<br>            p = p-&gt;next;<br>        &#125;<br><br>        p = head;<br>        <span class="hljs-type">bool</span> back = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!list.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (back)<br>            &#123;<br>                p-&gt;next = list.<span class="hljs-built_in">back</span>();<br>                list.<span class="hljs-built_in">pop_back</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p-&gt;next = list.<span class="hljs-built_in">front</span>();<br>                list.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            p = p-&gt;next;<br>            back = !back;<br>        &#125;<br><br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>有一个容易忽略的点：要设置最后一个元素指向<code>NULL</code>。</p>
<p>显然，这个算法的时间复杂度是<code>O(N)</code>；空间复杂度也是<code>O(N)</code>。</p>
<h1 id="day15315"><a class="markdownIt-Anchor" href="#day15315"></a> Day15(3.15)</h1>
<h2 id="leetcode-56-合并区间medium"><a class="markdownIt-Anchor" href="#leetcode-56-合并区间medium"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals">Leetcode 56. 合并区间(Medium)</a></h2>
<blockquote>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 104</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>
</ul>
</blockquote>
<h3 id="第一版排序-直接在vector上修改"><a class="markdownIt-Anchor" href="#第一版排序-直接在vector上修改"></a> 第一版：排序 + 直接在vector上修改</h3>
<p>先将区间按左端点从小到大排序，然后从vector的开头开始合并，如果要跟下一个区间合并，则设置当前区间的右端点，然后将下一个区间删除。如果不合并，则将下一个区间设置为当前区间。</p>
<p>然而在vector的任意位置删除的开销很大，总时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因此我想到可以用方便在任意位置删除元素的容器来存储以及合并区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Less</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Less</span>());<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; intervals.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &lt; intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;<br>                ++i;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(intervals[i][<span class="hljs-number">1</span>], intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            intervals.<span class="hljs-built_in">erase</span>(intervals.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> intervals;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="第二版排序-链表"><a class="markdownIt-Anchor" href="#第二版排序-链表"></a> 第二版：排序 + 链表</h3>
<p>什么容器方便在任意位置删除元素？链表！因此我决定先将区间放到链表中。然后同理还是先按左端点从小到大排序。从开头开始合并区间，如果要跟下一个区间合并，则设置当前区间的右端点，并删除下一个区间。如果不合并，则将下一个区间设置为当前区间。</p>
<p>注意点：<code>list</code>排序要用容器内部的<code>sort</code>函数，不能用<code>sort(list.begin(), list.end())</code>，因为<code>list</code>的迭代器不支持随机访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Less</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;intervals)<br>    &#123;<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">list</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br><br>        list.<span class="hljs-built_in">sort</span>(<span class="hljs-built_in">Less</span>());<br><br>        <span class="hljs-keyword">auto</span> it = list.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">auto</span> next_it = <span class="hljs-built_in">next</span>(it);<br>        <span class="hljs-keyword">while</span> (next_it != list.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((*it)[<span class="hljs-number">1</span>] &lt; (*next_it)[<span class="hljs-number">0</span>])<br>            &#123;<br>                ++it;<br>                ++next_it;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            (*it)[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>((*it)[<span class="hljs-number">1</span>], (*next_it)[<span class="hljs-number">1</span>]);<br>            next_it = list.<span class="hljs-built_in">erase</span>(next_it);<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(list.<span class="hljs-built_in">begin</span>(), list.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>链表的删除操作时间复杂度是<code>O(1)</code>，因此总时间复杂度就是排序链表的复杂度<code>O(NlogN)</code>；空间复杂度是<code>O(N)</code>。</p>
<h2 id="leetcode-42-接雨水hard"><a class="markdownIt-Anchor" href="#leetcode-42-接雨水hard"></a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water">Leetcode 42. 接雨水(Hard)</a></h2>
<blockquote>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/imgs/rainwatertrap-1742049673383-1.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 104</code></li>
<li><code>0 &lt;= height[i] &lt;= 105</code></li>
</ul>
</blockquote>
<h3 id="动态规划推荐"><a class="markdownIt-Anchor" href="#动态规划推荐"></a> 动态规划（推荐）</h3>
<p>接雨水的核心点：<strong>对于下标<code>i</code>处的位置，水能达到的最大高度等于下标<code>i</code>两边的最大高度的最小值。</strong></p>
<p>搞清楚这一点，那么其实我们要求的东西就变成了：对于每个下标<code>i</code>，其左边的最大高度和其右边的最大高度。这就很明显可以用动态规划求解了。</p>
<p>怎么求下标<code>i</code>的左边（包括下标<code>i</code>）的最大高度<code>leftMax[i]</code>呢？如果我们知道了下标<code>i - 1</code>的左边（包括下标<code>i - 1</code>）的最大高度<code>leftMax[i - 1]</code>，那么就很容易求出<code>leftMax[i]</code>了：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mtext>，其中</mtext><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">leftMax[i] = max(leftMax[i - 1], height[i])，其中leftMax[0] = height[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></p>
<p>那么同理，</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mtext>，其中</mtext><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">rightMax[i] = max(rightMax[i + 1], height[i])，其中rightMax[n - 1] = height[n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>以上两个递推公式就是此题动态规划的状态转移方程。</p>
<p>因此从左向右遍历一遍<code>height</code>数组就可以求出<code>leftMax</code>数组；从右向左再遍历一遍<code>height</code>数组就可以求出<code>rightMax</code>数组。时间复杂度是<code>O(N)</code>。</p>
<p>最后求每个下标<code>i</code>处能接到的雨水数量就等于<code>min(leftMax(i), rightMax(i)) - height[i]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftMax</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightMax</span><span class="hljs-params">(n)</span></span>;<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        rightMax[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            leftMax[i] = <span class="hljs-built_in">max</span>(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            rightMax[i] = <span class="hljs-built_in">max</span>(rightMax[i + <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> drip = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            drip += <span class="hljs-built_in">min</span>(leftMax[i], rightMax[i]) - height[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> drip;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>显然动态规划的解法时间复杂度是<code>O(N)</code>，空间复杂度也是<code>O(N)</code>。</p>
<h3 id="双指针-3"><a class="markdownIt-Anchor" href="#双指针-3"></a> 双指针</h3>
<p>还是这个核心思想：<strong>对于下标<code>i</code>处的位置，水能达到的最大高度等于下标<code>i</code>两边的最大高度的最小值。</strong></p>
<p>我们还是需要知道对于每个下标<code>i</code>处的位置，到底是其左边的最大高度大，还是其右边的最大高度大。如果是其左边的最大高度大，那我们需要知道其右边的最大高度是多少；反之如果是其右边的最大高度大，那我们需要知道其左边的最大高度是多少。</p>
<p>但我们可以对空间利用进行优化，不需要两个数组分别存储每个下标<code>i</code>处的左边最大高度和右边最大高度。</p>
<p>想象以下这个假设：对于一个下标<code>i</code>，如果我们知道了他的<code>leftMax</code>（左边的最大高度）一定比他的<code>rightMax</code>（右边的最大高度）的最小值还要小，那我们只要取<code>leftMax</code>来计算当前位置雨水的高度就行了，我们不需要知道下标<code>i</code>的<code>rightMax</code>具体是多少。反过来也一样，对于一个下标<code>i</code>，如果我们知道了他的<code>rightMax</code>（右边的最大高度）一定比他的<code>leftMax</code>（左边的最大高度）的最小值还要小，那我们只要取<code>rightMax</code>来计算当前位置雨水的高度就行了，我们不需要知道下标<code>i</code>的<code>leftMax</code>具体是多少。</p>
<p>为了应用以上假设，我们需要双指针<code>l</code>和<code>r</code>分别指向数组的开头和末尾下标，还需要两个变量<code>l_leftMax</code>和<code>r_rightMax</code>。注意！这两个变量与上面我说的下标<code>i</code>的<code>leftMax</code>（左边的最大高度）和<code>rightMax</code>（右边的最大高度）不同！<code>l_leftMax</code>应当理解为当前下标<code>l</code>的<code>leftMax</code>（左边的最大高度），<code>r_rightMax</code>应当理解为当前下标<code>r</code>的<code>rightMax</code>（右边的最大高度）。</p>
<p>然后我们就可以让<code>l</code>和<code>r</code>双指针向中间移动收敛了。最初双指针<code>l</code>和<code>r</code>分别指向数组的开头和末尾下标。当<code>l</code>或<code>r</code>每移动一格，就更新<code>l_leftMax</code>和<code>r_rightMax</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// l_leftMax是下标l（包括下标l）的左边最大高度；</span><br>l_leftMax = <span class="hljs-built_in">max</span>(l_leftMax, height[l]); <br><span class="hljs-comment">// r_rightMax是下标r（包括下标r）的右边最大高度；</span><br>r_rightMax = <span class="hljs-built_in">max</span>(r_rightMax, height[r]);<br></code></pre></td></tr></table></figure>
<p>这部分很简单，就是上面动态规划的思想。</p>
<p>然后就是关键点了：我们比较当前的<code>l_leftMax</code>和<code>r_rightMax</code>：</p>
<ol>
<li>
<p>如果<code>l_leftMax &lt; r_rightMax</code>，而显然<code>r_rightMax（下标r的rightMax) &lt;= 下标l的rightMax</code>，因此根据符号的传递性，<code>l_leftMax（下标l的leftMax） &lt; 下标l的rightMax</code>。</p>
<p>因此对于下标<code>l</code>来说，我们知道了其左边的最大高度更小，而这个值我们刚好知道，就是<code>l_leftMax</code>！这样就可以计算出下标<code>l</code>处的水滴数量 = <code>l_leftMax - height[l]</code>。加入结果中后，将<code>l</code>指针向右移动一格，等待计算下一格的水滴数量。</p>
</li>
<li>
<p>同理，如果<code>l_leftMax &gt;= r_rightMax</code>，而显然<code>下标r的leftMax &gt;= l_leftMax（下标l的leftMax）</code>，因此根据符号的传递性，<code>下标r的leftMax &gt;= r_rightMax（下标r的rightMax）</code>。</p>
<p>因此对于下标<code>r</code>来说，我们知道了其右边的最大高度更小，而这个值我们刚好知道，就是<code>r_rightMax</code>！这样就可以计算出下标<code>r</code>处的水滴数量 = <code>r_rightMax - height[r]</code>。加入结果中后，将<code>r</code>指针向左移动一格，等待计算下一格的水滴数量。</p>
</li>
</ol>
<p>思路好像挺复杂，但代码写起来很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;height)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> l_leftMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r_rightMax = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> drip = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-comment">// l_leftMax是下标l（包括下标l）的左边最大高度；</span><br>            l_leftMax = <span class="hljs-built_in">max</span>(l_leftMax, height[l]); <br>            <span class="hljs-comment">// r_rightMax是下标r（包括下标r）的右边最大高度；</span><br>            r_rightMax = <span class="hljs-built_in">max</span>(r_rightMax, height[r]);<br><br>            <span class="hljs-keyword">if</span> (l_leftMax &lt; r_rightMax) &#123;<br>                <span class="hljs-comment">// 下标l的rightMax &gt;= 下标r的rightMax = r_rightMax &gt; l_leftMax = 下标l的leftMax；</span><br>                drip += l_leftMax - height[l];<br>                l++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 下标r的rightMax = r_rightMax &lt;= l_leftMax = 下标l的leftMax &lt;= 下标r的leftMax；</span><br>                drip += r_rightMax - height[r];<br>                r--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> drip;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>显然双指针的解法时间复杂度是<code>O(N)</code>，空间复杂度是<code>O(1)</code>。</p>
<h3 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h3>
<p>与上面两种方法求每个下标<code>i</code>的左右最大高度不同，这题也可以用到单调递减栈来求解。什么是单调递减栈？就是从栈底到栈顶元素大小单调递减。</p>
<p>从左到右遍历数组<code>height</code>，每遍历到一个下标<code>i</code>，如果<code>height[i] &lt;= height[top]（top是栈顶下标）</code>，就将下标入栈；否则的话如果栈中至少有两个下标，我们就找到了一个可以接雨水的区域。该区域的宽度是<code>i - left - 1</code>，高度是<code>min(height[left], height[i]) - height[top]</code>。根据宽度和高度即可计算得到该区域能接到的雨水量。为了得到<code>left</code>，需要先将<code>top</code>出栈，在对<code>top</code>计算能接的雨水量之后，<code>left</code>变成新的<code>top</code>，重复上述操作，直到栈变空，或者<code>height[top]</code>大于等于当前遍历到的<code>height[i]</code>。然后将当前的下标<code>i</code>入栈，继续遍历后面的下标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单调栈</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;height)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br>        <span class="hljs-type">int</span> drip = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || height[i] &lt;= height[st.<span class="hljs-built_in">top</span>()])<br>            &#123;<br>                st.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前下标的高度大于栈顶下标的高度，如果栈中只有一个下标，替换他</span><br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            <span class="hljs-comment">// 到这一步，栈中至少有两个下标，并且当前下标的高度大于栈顶的高度；</span><br>            <span class="hljs-comment">// 意味着我们找到了一个可以接雨水的区域</span><br>            <span class="hljs-keyword">while</span> (height[i] &gt; height[st.<span class="hljs-built_in">top</span>()])<br>            &#123;<br>                <span class="hljs-type">int</span> top = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-comment">// 计算这个接雨水区域的宽度和高度</span><br>                <span class="hljs-type">int</span> w = i - left - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[i], height[left]) - height[top];<br>                drip += w * h;<br>            &#125;<br>            <span class="hljs-comment">// 到这里，当前下标的高度终于比栈顶高度小了（也可能栈空了）</span><br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> drip;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>显然这个算法的时间复杂度是<code>O(N)</code>，空间复杂度也是<code>O(N)</code>。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Leetcode/" class="category-chain-item">Leetcode</a>
  
  
    <span>></span>
    
  <a href="/categories/Leetcode/CodeTop/" class="category-chain-item">CodeTop</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/CodeTop/" class="print-no-link">#CodeTop</a>
      
        <a href="/tags/Leetcode/" class="print-no-link">#Leetcode</a>
      
        <a href="/tags/%E5%88%B7%E9%A2%98/" class="print-no-link">#刷题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CodeTop每日刷题</div>
      <div>http://oooscar8.github.io/2025/02/26/CodeTop/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Alex Sun</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/02/27/cs144-lab6/" title="CS144 Lab 6">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CS144 Lab 6</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/24/Simulator/" title="Simulator Lab">
                        <span class="hidden-mobile">Simulator Lab</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'http://oooscar8.github.io/2025/02/26/CodeTop/';
          this.page.identifier = '/2025/02/26/CodeTop/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
