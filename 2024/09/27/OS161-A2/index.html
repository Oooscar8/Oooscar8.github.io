

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/imgs/wallhaven-p9qeze.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Alex Sun">
  <meta name="keywords" content="">
  
    <meta name="description" content="Implement basic synchronization primitives - blocking locks and condition variables based on existing implementation of mutexes and semaphores">
<meta property="og:type" content="article">
<meta property="og:title" content="OS161 Assignment 2">
<meta property="og:url" content="http://oooscar8.github.io/2024/09/27/OS161-A2/index.html">
<meta property="og:site_name" content="Alex&#39;s Space">
<meta property="og:description" content="Implement basic synchronization primitives - blocking locks and condition variables based on existing implementation of mutexes and semaphores">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://oooscar8.github.io/2024/09/27/imgs/202409251839431.png">
<meta property="og:image" content="http://oooscar8.github.io/2024/09/27/imgs/202409252300462.png">
<meta property="og:image" content="http://oooscar8.github.io/2024/09/27/imgs/202409252301416.png">
<meta property="article:published_time" content="2024-09-26T16:00:00.000Z">
<meta property="article:modified_time" content="2025-02-23T09:32:04.565Z">
<meta property="article:author" content="Alex Sun">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="OS161">
<meta property="article:tag" content="Synchronization">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://oooscar8.github.io/2024/09/27/imgs/202409251839431.png">
  
  
  
  <title>OS161 Assignment 2 - Alex&#39;s Space</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"oooscar8.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Alex&#39;s Space</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/imgs/chuyin.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="OS161 Assignment 2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-27 00:00" pubdate>
          2024年9月27日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          1.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          10 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">OS161 Assignment 2</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="assignment2"><a class="markdownIt-Anchor" href="#assignment2"></a> Assignment2</h1>
<blockquote>
<p>Use <a target="_blank" rel="noopener" href="https://www.gnu.org/prep/standards/html_node/Writing-C.html">this document</a> as a guideline for writing high-quality code.</p>
</blockquote>
<blockquote>
<p>In this assignment you finally get to write your own code in OS161! By the end of this assignment you will:</p>
<ul>
<li>Have a good understanding of the implementation of <strong>spinlocks</strong> and <strong>semaphores</strong> in OS161</li>
<li>Implement locks</li>
<li>Implement condition variables.</li>
</ul>
</blockquote>
<h2 id="step-1-prepare"><a class="markdownIt-Anchor" href="#step-1-prepare"></a> Step 1. Prepare</h2>
<p>Make sure you don't have any uncommitted updates in your repo. Now, tag your repository as shown here:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">asst2-start</span><br></code></pre></td></tr></table></figure>
<p>Now push that new tag:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git push <span class="hljs-comment">--tags</span><br></code></pre></td></tr></table></figure>
<p>Make a directory submit/asst2 in your os161 tree. You will put your file with the answers to code reading questions in that directory.</p>
<ul>
<li><strong>Physical memory and CPUs</strong></li>
</ul>
<p>Change <code>sys161.conf</code> file in <code>~/os161/root</code>:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">31 </span>mainboard ramsize=<span class="hljs-number">2097152</span> cpus=<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>Built-in thread tests</strong></li>
</ul>
<p>The thread test code uses the <strong>semaphore synchronization primitive</strong></p>
<p>You should trace the execution of one of these thread tests in GDB to see <strong>how the scheduler acts</strong>, <strong>how threads are created</strong>, and what exactly happens in a <strong>context switch</strong>. You should be able to step through a call to <code>thread_switch()</code> and see exactly <strong>where</strong> the current thread changes.</p>
<ul>
<li><strong>Debugging concurrent programs</strong></li>
</ul>
<p><code>thread_yield()</code> is automatically called for you at intervals that vary randomly.</p>
<p>Change <code>sys161.conf</code> file in <code>~/os161/root</code>:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">28	random <span class="hljs-attribute">seed</span>=1<br></code></pre></td></tr></table></figure>
<p>Once you are done with initial debugging/testing, remember to set the random device back to <code>autoseed</code>.</p>
<p>This should allow you to <strong>test your solutions under varying conditions</strong> and may expose scenarios that you had not anticipated, which is central to effective testing.</p>
<h2 id="step-2-code-reading-exercises"><a class="markdownIt-Anchor" href="#step-2-code-reading-exercises"></a> Step 2. Code reading exercises</h2>
<blockquote>
<ol>
<li>What happens to a thread when it exits (i.e., calls thread_exit())? What about when it sleeps?</li>
</ol>
</blockquote>
<p><code>thread_exit()</code> detaches the thread from the process, checks the stack guard band, turns interrupts off on this processor and performs a thread switch(find another thread to run).</p>
<p><code>thread.c</code> 777:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Cause the current thread to exit.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The parts of the thread structure we don&#x27;t actually need to run</span><br><span class="hljs-comment"> * should be cleaned up right away. The rest has to wait until</span><br><span class="hljs-comment"> * thread_destroy is called from exorcise().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Does not return.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">thread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">cur</span>;</span><br><br>    cur = curthread;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Detach from our process. You might need to move this action</span><br><span class="hljs-comment">	 * around, depending on how your wait/exit works.</span><br><span class="hljs-comment">	 */</span><br>    proc_remthread(cur);<br><br>    <span class="hljs-comment">/* Make sure we *are* detached (move this only if you&#x27;re sure!) */</span><br>    KASSERT(cur-&gt;t_proc == <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">/* Check the stack guard band. */</span><br>    thread_checkstack(cur);<br><br>    <span class="hljs-comment">/* Interrupts off on this processor */</span><br>    splhigh();<br>    thread_switch(S_ZOMBIE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    panic(<span class="hljs-string">&quot;braaaaaaaiiiiiiiiiiinssssss\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>First, <code>wchan_sleep</code> makes sure that we are not in an interrupt handler, hold the specific  spinlock associated with the wait channel WC and no others. Then, it performs a thread switch, and puts the thread go to sleep on the specified wait channel WC before finding another thread to run. Lastly, when being woken up, it locks the spinlock again before returning.</p>
<p><code>thread.c</code> 1026:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Yield the cpu to another process, and go to sleep, on the specified</span><br><span class="hljs-comment"> * wait channel WC, whose associated spinlock is LK. Calling wakeup on</span><br><span class="hljs-comment"> * the channel will make the thread runnable again. The spinlock must</span><br><span class="hljs-comment"> * be locked. The call to thread_switch unlocks it; we relock it</span><br><span class="hljs-comment"> * before returning.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">wchan_sleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> wchan *wc, <span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>    <span class="hljs-comment">/* may not sleep in an interrupt handler */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt);<br><br>    <span class="hljs-comment">/* must hold the spinlock */</span><br>    KASSERT(spinlock_do_i_hold(lk));<br><br>    <span class="hljs-comment">/* must not hold other spinlocks */</span><br>    KASSERT(curcpu-&gt;c_spinlocks == <span class="hljs-number">1</span>);<br><br>    thread_switch(S_SLEEP, wc, lk);<br>    spinlock_acquire(lk);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>What function(s) handle(s) a context switch?</li>
</ol>
</blockquote>
<p><code>thread.c</code> 560:</p>
<p><code>thread_switch()</code></p>
<p>Machine-dependent functions for working on switchframes:</p>
<p>During context switch, switch what is saved on the kernel stack.</p>
<p><code>switchframe_switch()</code></p>
<blockquote>
<ol start="3">
<li>What does it mean for a thread to be in each of the possible thread states?</li>
</ol>
</blockquote>
<p>During context switching, we need to put the thread in the right place according to its <code>newstate</code>.</p>
<ul>
<li>
<p><strong>S_RUN</strong>:</p>
<p>For <code>S_RUN</code>, it means the thread is currently running. A thread should never be put into the <code>S_RUN</code> state within <code>thread_switch</code>. But if it does, call panic.</p>
</li>
<li>
<p><strong>S_READY</strong>:
A thread in the <code>S_READY</code> state is ready to run but is not currently running. <code>thread_make_runnable</code> is called to add it to the run queue so that the scheduler can pick it up for execution later.</p>
</li>
<li>
<p><strong>S_SLEEP</strong>:
A thread in the <code>S_SLEEP</code> state is blocked, waiting to be woken up. The thread is added to the wait channel <code>wc</code>, and it will remain in this state until a wakeup call (like <code>wchan_wake</code>) signals it. After putting the thread on the list, we release the spinlock associated with the wait channel <code>wc</code>.</p>
</li>
<li>
<p><strong>S_ZOMBIE</strong>:
A thread in the <code>S_ZOMBIE</code> state has finished its execution but has not yet been fully cleaned up. The thread is added to the CPU's zombie list <code>c_zombies</code>, where it waits to be freed.</p>
</li>
</ul>
<p><code>thread.c</code>: <code>thread_switch()</code>: 595:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Put the thread in the right place. */</span><br><span class="hljs-keyword">switch</span> (newstate) &#123;<br>    <span class="hljs-keyword">case</span> S_RUN:<br>        panic(<span class="hljs-string">&quot;Illegal S_RUN in thread_switch\n&quot;</span>);<br>    <span class="hljs-keyword">case</span> S_READY:<br>        thread_make_runnable(cur, <span class="hljs-literal">true</span> <span class="hljs-comment">/*have lock*/</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> S_SLEEP:<br>        cur-&gt;t_wchan_name = wc-&gt;wc_name;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Add the thread to the list in the wait channel, and</span><br><span class="hljs-comment">		 * unlock same. To avoid a race with someone else</span><br><span class="hljs-comment">		 * calling wchan_wake*, we must keep the wchan&#x27;s</span><br><span class="hljs-comment">		 * associated spinlock locked from the point the</span><br><span class="hljs-comment">		 * caller of wchan_sleep locked it until the thread is</span><br><span class="hljs-comment">		 * on the list.</span><br><span class="hljs-comment">		 */</span><br>        threadlist_addtail(&amp;wc-&gt;wc_threads, cur);<br>        spinlock_release(lk);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> S_ZOMBIE:<br>        cur-&gt;t_wchan_name = <span class="hljs-string">&quot;ZOMBIE&quot;</span>;<br>        threadlist_addtail(&amp;curcpu-&gt;c_zombies, cur);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br>cur-&gt;t_state = newstate;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol start="4">
<li>What does it mean to turn interrupts off? How is this accomplished? Why is it important to turn off interrupts in the thread subsystem code?</li>
</ol>
</blockquote>
<p>Turning interrupts off means that the current processor is temporarily prevented from responding to hardware interrupts, meaning that the current CPU cannot perform a context switch.</p>
<p>In os161, turning interrupts off is accomplished by changing the processor's interrupt priority level(IPL). The function <code>splhigh()</code> is used to set the IPL to its highest level to disable all interrupts.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Explicitly disable interrupts on this processor */</span><br>spl = splhigh();<br></code></pre></td></tr></table></figure>
<p>It is important to turn off interrupts in the thread subsystem code. When we perform operations on threads such as context switching, blocking threads, exit threads, we don't want to be interrupted. If we are interrupted during those operations, we may lose important information of the thread. For example, if we are interrupted during context switching when we are saving the thread's state, we may lose the state during interrupts. Turning off interrupts also helps avoid deadlock and improve performance.</p>
<blockquote>
<ol start="5">
<li>What happens when a thread wakes up another thread? How does a sleeping thread get to run again?</li>
</ol>
</blockquote>
<p>When a thread wants to wake up another thread, it calls the function <code>wchan_wakeone</code>, the function grabs a thread from the wait channel and then calls <code>thread_make_runnable</code> to make the target thread runnable.</p>
<p>In <code>thread_make_runnable</code>, the target thread should lock the run queue of the CPU, ensuring only one thread in the run queue can modify the CPU. Then it puts the target thread on the run queue of the CPU.</p>
<blockquote>
<ol start="6">
<li>What function(s) choose(s) the next thread to run?</li>
</ol>
</blockquote>
<p><code>thread_switch</code></p>
<blockquote>
<ol start="7">
<li>How does it (do they) pick the next thread?</li>
</ol>
</blockquote>
<p><code>schedule</code> and <code>thread_switch</code> both use <code>threadlist_remhead</code> function, which removes and returns the <strong>first thread</strong> from the run queue of the current CPU, which is the next thread to run.</p>
<blockquote>
<ol start="8">
<li>What role does the hardware timer play in scheduling? What hardware independent function is called on a timer interrupt?</li>
</ol>
</blockquote>
<p>The hardware timer generates periodic interrupts to allow the operating system to regain control of the CPU at regular intervals, ensuring that it can check the status of threads and make scheduling decisions.</p>
<p><code>hardclock</code> is the hardware independent function called on a timer interrupt.</p>
<blockquote>
<ol start="9">
<li>Describe how <code>wchan_sleep()</code> and <code>wchan_wakeone()</code> are used to implement semaphores.</li>
</ol>
</blockquote>
<p>For function <code>V</code>, <code>wchan_wakeone()</code> is called after it increments <code>sem_count</code> and wants to wake up another thread.</p>
<p>For function <code>P</code>, <code>wchan_sleep</code> is called when <code>sem_count = 0</code> and wants to put the thread to sleep waiting to be awakened. It should be called after we lock the wait channel(using semaphore spinlock) so that we can put the thread to sleep while also release the wait channel lock afterwards. After being woken up, it locks the wait channel again before returning.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-type">char</span> *sem_name;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wchan</span> *<span class="hljs-title">sem_wchan</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">sem_lock</span>;</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> sem_count;<br>&#125;<br><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">V</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span><br>&#123;<br>    KASSERT(sem != <span class="hljs-literal">NULL</span>);<br><br>    spinlock_acquire(&amp;sem-&gt;sem_lock);<br><br>    sem-&gt;sem_count++;<br>    KASSERT(sem-&gt;sem_count &gt; <span class="hljs-number">0</span>);<br>    wchan_wakeone(sem-&gt;sem_wchan, &amp;sem-&gt;sem_lock);<br><br>    spinlock_release(&amp;sem-&gt;sem_lock);<br>&#125;<br><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span><br>&#123;<br>    KASSERT(sem != <span class="hljs-literal">NULL</span>);<br>    KASSERT(curthread-&gt;t_in_interrupt == <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">/* Use the semaphore spinlock to protect the wchan as well. */</span><br>    spinlock_acquire(&amp;sem-&gt;sem_lock);<br>    <span class="hljs-keyword">while</span> (sem-&gt;sem_count == <span class="hljs-number">0</span>) &#123;<br>        wchan_sleep(sem-&gt;sem_wchan, &amp;sem-&gt;sem_lock);<br>        <span class="hljs-comment">// sem_lock is also the wait channel lock.</span><br>        <span class="hljs-comment">// Before returning from sleep, we should relock.</span><br>    &#125;<br>    KASSERT(sem-&gt;sem_count &gt; <span class="hljs-number">0</span>);<br>    sem-&gt;sem_count--;<br>    spinlock_release(&amp;sem-&gt;sem_lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol start="10">
<li>How does the implementation of <code>wchan</code> ensure that a thread never misses a wakeup signal: that another thread cannot attempt to awaken the first thread just as it is preparing to sleep, but before it is actually placed into the sleep queue?</li>
</ol>
</blockquote>
<p>In <code>P</code>, <code>wchan_sleep</code> is called after we acquire the semaphore spinlock(<code>spinlock_acquire(&amp;sem-&gt;sem_lock)</code>), which also serves as locking the wait channel. In this way, when we call <code>wchan_sleep</code> to put the current thread to sleep, no other threads can manipulate the wait channel(i.e. by calling <code>wchan_wakeone</code>). That is to say, no threads can sneak in and try to awaken the thread during its &quot;sleep&quot; process.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Use the semaphore spinlock to protect the wchan as well. */</span><br>spinlock_acquire(&amp;sem-&gt;sem_lock);<br><span class="hljs-keyword">while</span> (sem-&gt;sem_count == <span class="hljs-number">0</span>) &#123;<br>    wchan_sleep(sem-&gt;sem_wchan, &amp;sem-&gt;sem_lock);<br>    <span class="hljs-comment">// sem_lock is also the wait channel lock.</span><br>    <span class="hljs-comment">// Before returning from sleep, we should relock.</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="step-3-implement-locks-for-os161"><a class="markdownIt-Anchor" href="#step-3-implement-locks-for-os161"></a> Step 3. Implement locks for OS161</h2>
<p>The interface for the lock struct is defined in <code>kern/include/synch.h</code>. Stub code is provided in <code>kern/thread/synch.c</code>.</p>
<p><strong>Requirements:</strong></p>
<ol>
<li><strong>Comply to the interface.</strong> Take a look at the stub code provided in <code>kern/thread/synch.c</code>. Your implementation must conform to this API. Please don't change it, as this will break the tests that we will use to test your assignment.</li>
<li><strong>Mutual exclusion.</strong> It's probably a no-brainer that your locks must provide mutual exclusion. You are going to implement the simplest semantics of locks: only one thread can hold a lock at any given time.</li>
<li><strong>No busy-waiting.</strong> If you carefully read the OS161 code, you noticed that there is an implementation of spinlocks. Spinlocks derive their name from the method that they use to wait until the lock becomes available: they spin, or busy-wait, hogging the CPU and checking if the lock became available. While this is perfectly fine for short critical section and only on a multiprocessor system (why?), a general implementation of locks must be more universal. We must be able to use them on a system with a single CPU and for long critical sections, e.g., those involving I/O operations, where it makes no sense to busy-wait on the CPU. Therefore, your locks implementation must not busy-wait on a taken lock. It must give up the CPU until the lock becomes available.</li>
</ol>
<h3 id="implementation"><a class="markdownIt-Anchor" href="#implementation"></a> Implementation</h3>
<h4 id="faqs"><a class="markdownIt-Anchor" href="#faqs"></a> FAQs</h4>
<blockquote>
<p>How to avoid busy-waiting?</p>
</blockquote>
<p>When a thread tries to <strong>acquire</strong> the lock, if the lock is not avaiable, we puts the thread to sleep. After the thread holding the lock <strong>releases</strong> the lock, it wakes up another thread waiting on the wait channel.</p>
<blockquote>
<p>How to protect the lock and the wait channel?</p>
</blockquote>
<p>We use the spinlock provided by the os161 stub code to protect both the lock and the wait channel.</p>
<h4 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h4>
<p>lock structure:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *lk_name;<br>    <span class="hljs-comment">// add what you need here</span><br>    <span class="hljs-comment">// (don&#x27;t forget to mark things volatile as needed)</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lk_hold;        <span class="hljs-comment">/* 0 means the lock is free, while 1 means the lock is held */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wchan</span> *<span class="hljs-title">lk_wchan</span>;</span>      <span class="hljs-comment">/* wait channel, lists of threads waiting to get the lock */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lk_spinlock</span>;</span> <span class="hljs-comment">/* protect the lock and the wait channel */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">lk_holder</span>;</span>    <span class="hljs-comment">/* thread that holds the lock */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>lock methods:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> lock *<span class="hljs-title function_">lock_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">lock_do_i_hold</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *)</span>;<br></code></pre></td></tr></table></figure>
<p>Methods Implementation:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create the lock. */</span><br><span class="hljs-keyword">struct</span> lock *<br>    <span class="hljs-title function_">lock_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> *<span class="hljs-title">lock</span>;</span><br><br>    lock = kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> lock));<br>    <span class="hljs-keyword">if</span> (lock == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    lock-&gt;lk_name = kstrdup(name);<br>    <span class="hljs-keyword">if</span> (lock-&gt;lk_name == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// add stuff here as needed</span><br><br>    spinlock_init(&amp;lock-&gt;lk_spinlock);            <span class="hljs-comment">/* initialize spinlock */</span><br>    lock-&gt;lk_wchan = wchan_create(lock-&gt;lk_name); <span class="hljs-comment">/* create wait channel */</span><br>    <span class="hljs-comment">/* if failing to create wait channel, free the lock */</span><br>    <span class="hljs-keyword">if</span> (lock-&gt;lk_wchan == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(lock-&gt;lk_name);<br>        kfree(lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">/* initially no thread is holding the lock */</span><br>    lock-&gt;lk_holder = <span class="hljs-literal">NULL</span>;<br>    lock-&gt;lk_hold = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> lock;<br>&#125;<br><br><span class="hljs-comment">/* Clean up the lock. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// add stuff here as needed</span><br><br>    <span class="hljs-comment">/* acquire the spinlock making sure no other threads can modify the lock */</span><br>    spinlock_acquire(&amp;lock-&gt;lk_spinlock);<br><br>    KASSERT(!lock-&gt;lk_hold);                                    <span class="hljs-comment">/* make sure the lock is not used */</span><br>    KASSERT(lock-&gt;lk_holder == <span class="hljs-literal">NULL</span>);                           <span class="hljs-comment">/* make sure no thread is holding the lock */</span><br>    KASSERT(wchan_isempty(lock-&gt;lk_wchan, &amp;lock-&gt;lk_spinlock)); <span class="hljs-comment">/* make sure wait channel is empty */</span><br><br>    spinlock_release(&amp;lock-&gt;lk_spinlock);<br><br>    wchan_destroy(lock-&gt;lk_wchan);        <span class="hljs-comment">/* destroy the wait channel */</span><br>    spinlock_cleanup(&amp;lock-&gt;lk_spinlock); <span class="hljs-comment">/* clean up the spinlock */</span><br><br>    <span class="hljs-comment">/* clean up the lock structure */</span><br>    kfree(lock-&gt;lk_name);<br>    kfree(lock);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get the lock. Only one thread can hold the lock at the same time.</span><br><span class="hljs-comment"> * If the lock is held by another thread, put the current thread to sleep.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">/* must not acquire the lock in an interrupt handler */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt);<br><br>    <span class="hljs-comment">/* acquire the spinlock, protecting the lock and the wait channel */</span><br>    spinlock_acquire(&amp;lock-&gt;lk_spinlock);<br><br>    <span class="hljs-comment">/* if the lock is held by other threads, put the current thread to sleep */</span><br>    <span class="hljs-keyword">while</span> (lock-&gt;lk_hold)<br>    &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * wchan_sleep would unlocks the spinlock before sleeping, and</span><br><span class="hljs-comment">                 * acquire the spinlock again before returning.</span><br><span class="hljs-comment">                 */</span><br>        wchan_sleep(lock-&gt;lk_wchan, &amp;lock-&gt;lk_spinlock);<br>    &#125;<br><br>    <span class="hljs-comment">/* acquire the lock for the current thread */</span><br>    lock-&gt;lk_hold = <span class="hljs-number">1</span>;<br>    lock-&gt;lk_holder = curthread;<br><br>    spinlock_release(&amp;lock-&gt;lk_spinlock);<br>&#125;<br><br><span class="hljs-comment">/* Free the lock. Only the thread holding the lock can do this. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">/* make sure the current thread is holding the lock */</span><br>    KASSERT(lock_do_i_hold(lock));<br><br>    <span class="hljs-comment">/* acquire the spinlock, protecting the lock and the wait channel */</span><br>    spinlock_acquire(&amp;lock-&gt;lk_spinlock);<br><br>    <span class="hljs-comment">/* free the lock */</span><br>    lock-&gt;lk_hold = <span class="hljs-number">0</span>;<br>    lock-&gt;lk_holder = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">/* wake up a thread waiting on the wait channel */</span><br>    wchan_wakeone(lock-&gt;lk_wchan, &amp;lock-&gt;lk_spinlock);<br><br>    spinlock_release(&amp;lock-&gt;lk_spinlock);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Returns true if the current thread is holding the lock.</span><br><span class="hljs-comment"> * Otherwise, return false.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">lock_do_i_hold</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">/* if there is no current thread, nobody is holding the lock */</span><br>    <span class="hljs-keyword">if</span> (curthread == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* acquire the spinlock before checking whether the current threads holds the lock */</span><br>    spinlock_acquire(&amp;lock-&gt;lk_spinlock);<br>    <span class="hljs-type">bool</span> do_i_hold = (lock-&gt;lk_holder == curthread);<br>    spinlock_release(&amp;lock-&gt;lk_spinlock);<br><br>    <span class="hljs-keyword">return</span> do_i_hold;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>test <code>sy2</code> passes!</p>
<img src="/imgs/202409251839431.png" srcset="/img/loading.gif" lazyload alt="" style="zoom: 80%;" />
<h2 id="step-4-implement-condition-variables-for-os161"><a class="markdownIt-Anchor" href="#step-4-implement-condition-variables-for-os161"></a> Step 4. Implement condition variables for OS161</h2>
<p><strong>Requirements:</strong></p>
<p>Just like with locks, your solution must:</p>
<ol>
<li>Comply to the existing interface.</li>
<li>Implement proper cv semantics as explained <a target="_blank" rel="noopener" href="https://sites.google.com/view/cpen331fall2024/assignments/assignment-2">here</a>.</li>
<li>Not use busy-waiting to wait on cv.</li>
</ol>
<h3 id="implementation-2"><a class="markdownIt-Anchor" href="#implementation-2"></a> Implementation</h3>
<h4 id="faqs-2"><a class="markdownIt-Anchor" href="#faqs-2"></a> FAQs</h4>
<blockquote>
<p>How to protect the wait channel?</p>
</blockquote>
<p>Again, we use the spinlock provided by the os161 stub code to protect the wait channel.</p>
<blockquote>
<p>What do we do in <code>wait()</code>?</p>
</blockquote>
<p>First, we check that we hold the lock.</p>
<p>Then, release the lock and go to sleep, protected by the spinlock.</p>
<p>The <code>sleep()</code> function releases the spinlock and atomatically re-acquires the spinlock before returning.</p>
<p>Therefore, after <code>sleep</code> returns, we need to release the spinlock explicitly and re-acquire the lock before returning.</p>
<blockquote>
<p>Do we need to release the lock in <code>signal()</code> after we wake up another thread.</p>
</blockquote>
<p>No. Users who use the cv should explicitly releases the lock after they call <code>signal</code>. It is not <code>signal()</code>'s responsibility to do so. So is the <code>broadcast()</code> function.</p>
<h4 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> Code</h4>
<p>CV structure:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cv</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *cv_name;<br>    <span class="hljs-comment">// add what you need here</span><br>    <span class="hljs-comment">// (don&#x27;t forget to mark things volatile as needed)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wchan</span> *<span class="hljs-title">cv_wchan</span>;</span>     <span class="hljs-comment">/* lists of threads waiting on the cv */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">cv_lock</span>;</span>    <span class="hljs-comment">/* protect the wait channel */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>CV methods:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> cv *<span class="hljs-title function_">cv_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_signal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_broadcast</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span>;<br></code></pre></td></tr></table></figure>
<p>Methods Implementation:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create the cv. */</span><br><span class="hljs-keyword">struct</span> cv *<br>    <span class="hljs-title function_">cv_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cv</span> *<span class="hljs-title">cv</span>;</span><br><br>    cv = kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> cv));<br>    <span class="hljs-keyword">if</span> (cv == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    cv-&gt;cv_name = kstrdup(name);<br>    <span class="hljs-keyword">if</span> (cv-&gt;cv_name == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(cv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// add stuff here as needed</span><br><br>    cv-&gt;cv_wchan = wchan_create(cv-&gt;cv_name); <span class="hljs-comment">/* create the wait channel */</span><br>    <span class="hljs-comment">/* if failing to create wait channel, free the cv */</span><br>    <span class="hljs-keyword">if</span> (cv-&gt;cv_wchan == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        kfree(cv-&gt;cv_name);<br>        kfree(cv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    spinlock_init(&amp;cv-&gt;cv_lock); <span class="hljs-comment">/* initialize the spinlock */</span><br><br>    <span class="hljs-keyword">return</span> cv;<br>&#125;<br><br><span class="hljs-comment">/* Clean up the cv. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv)</span><br>&#123;<br>    KASSERT(cv != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// add stuff here as needed</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * acquire the spinlock making sure no other threads can modify the cv</span><br><span class="hljs-comment">         * when we check the wait channel is empty.</span><br><span class="hljs-comment">         */</span><br>    spinlock_acquire(&amp;cv-&gt;cv_lock);<br>    KASSERT(wchan_isempty(cv-&gt;cv_wchan, &amp;cv-&gt;cv_lock));<br>    spinlock_release(&amp;cv-&gt;cv_lock);<br><br>    wchan_destroy(cv-&gt;cv_wchan);    <span class="hljs-comment">/* destroy the wait channel */</span><br>    spinlock_cleanup(&amp;cv-&gt;cv_lock); <span class="hljs-comment">/* clean up the spinlock */</span><br><br>    kfree(cv-&gt;cv_name);<br>    kfree(cv);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Release the supplied lock, go to sleep, and, after</span><br><span class="hljs-comment"> * waking up again, re-acquire the lock.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(cv != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock_do_i_hold(lock));       <span class="hljs-comment">/* check the current thread is holding the lock passed in */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt); <span class="hljs-comment">/* make sure we are not in an interrupt handler */</span><br><br>    <span class="hljs-comment">/* acquire the spinlock, protecting the wait channel */</span><br>    spinlock_acquire(&amp;cv-&gt;cv_lock);<br><br>    <span class="hljs-comment">/* release the lock passed in */</span><br>    lock_release(lock);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Before wchan_sleep puts the current thread to sleep, it releases the spinlock.</span><br><span class="hljs-comment">         * Before returning from wchan_sleep, it relocks the spinlock.</span><br><span class="hljs-comment">         */</span><br>    wchan_sleep(cv-&gt;cv_wchan, &amp;cv-&gt;cv_lock);<br><br>    spinlock_release(&amp;cv-&gt;cv_lock);<br><br>    <span class="hljs-comment">/* After waking up, re-acquire the lock passed in again before returning. */</span><br>    lock_acquire(lock);<br>&#125;<br><br><span class="hljs-comment">/* Wake up one thread that&#x27;s sleeping on the cv. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_signal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(cv != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock_do_i_hold(lock));       <span class="hljs-comment">/* check the current thread is holding the lock passed in */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt); <span class="hljs-comment">/* make sure we are not in an interrupt handler */</span><br><br>    <span class="hljs-comment">/* acquire the spinlock before manipulating the wait channel */</span><br>    spinlock_acquire(&amp;cv-&gt;cv_lock);<br><br>    <span class="hljs-comment">/* wake up one thread waiting on the cv */</span><br>    wchan_wakeone(cv-&gt;cv_wchan, &amp;cv-&gt;cv_lock);<br><br>    spinlock_release(&amp;cv-&gt;cv_lock);<br>&#125;<br><br><span class="hljs-comment">/* Wake up all threads sleeping on the cv. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cv_broadcast</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cv *cv, <span class="hljs-keyword">struct</span> lock *lock)</span><br>&#123;<br>    <span class="hljs-comment">// Write this</span><br><br>    KASSERT(cv != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock != <span class="hljs-literal">NULL</span>);<br>    KASSERT(lock_do_i_hold(lock));       <span class="hljs-comment">/* check the current thread is holding the lock passed in */</span><br>    KASSERT(!curthread-&gt;t_in_interrupt); <span class="hljs-comment">/* make sure we are not in an interrupt handler */</span><br><br>    <span class="hljs-comment">/* acquire the spinlock before manipulating the wait channel */</span><br>    spinlock_acquire(&amp;cv-&gt;cv_lock);<br><br>    <span class="hljs-comment">/* wake up all threads waiting on the cv */</span><br>    wchan_wakeall(cv-&gt;cv_wchan, &amp;cv-&gt;cv_lock);<br><br>    spinlock_release(&amp;cv-&gt;cv_lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Test <code>sy3</code> and <code>sy4</code> pass!</p>
<center class="half">    <img src="/imgs/202409252300462.png" srcset="/img/loading.gif" lazyload width="400"/>    <img src="/imgs/202409252301416.png" srcset="/img/loading.gif" lazyload width="400"/> </center>
<p>We have finished Assignment2!😊</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OS/" class="category-chain-item">OS</a>
  
  
    <span>></span>
    
  <a href="/categories/OS/OS161/" class="category-chain-item">OS161</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/OS/" class="print-no-link">#OS</a>
      
        <a href="/tags/OS161/" class="print-no-link">#OS161</a>
      
        <a href="/tags/Synchronization/" class="print-no-link">#Synchronization</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>OS161 Assignment 2</div>
      <div>http://oooscar8.github.io/2024/09/27/OS161-A2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Alex Sun</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/10/07/OS161-A3/" title="OS161 Assignment 3">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">OS161 Assignment 3</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/26/Synchronization/" title="Synchronization">
                        <span class="hidden-mobile">Synchronization</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'http://oooscar8.github.io/2024/09/27/OS161-A2/';
          this.page.identifier = '/2024/09/27/OS161-A2/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
